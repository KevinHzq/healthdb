#' Pooling qualified clients from multiple sources
#'
#' @param data A list of data.frame or remote table which should be output from [execute_def()].
#' @param def A tibble of case definition generated by [build_def()].
#' @param output_lvl Either "raw" - output all records (default), or "clnt" - output one record per client with summarized date of first valid record (`first_valid_date`), date of the latest record (`last_entry_date`), and sources that contain valid records.
#' @param valid_src_only A logical for whether remove records from sources which do not contain any record that met the case definition (Defaults to TRUE). For example, src1 and src2 were used in 'def', client1 had valid records only in src1. Then their records in src2 would be removed from the output when valid_src_only. This option will not impact the number of client that would be identified but has impact on the number of records and the latest entry date.
#' @param ... Additional arguments passing to [bind_sources()]
#'
#' @return A data.frame or remote table with clients that satisfied the predefined case definition.
#' @export
#'
#' @examples
#' # toy data
#' sample_size <- 30
#' df <- data.frame(
#'   clnt_id = rep(1:3, each = 10),
#'   service_dt = sample(seq(as.Date("2020-01-01"), as.Date("2020-01-31"), by = 1),
#'     size = sample_size, replace = TRUE
#'   ),
#'   diagx = sample(letters, size = sample_size, replace = TRUE),
#'   diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),
#'   diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE)
#' )
#'
#' # make df a database table
#' db <- dbplyr::tbl_memdb(df)
#'
#' # use build_def to make a toy definition
#' sud_def <- build_def("SUD", # usually a disease name
#'   src_lab = c("src1", "src2"), # identify from multiple sources, e.g., hospitalization, ED visits.
#'   # functions that filter the data with some criteria
#'   def_fn = define_case,
#'   fn_args = list(
#'     vars = starts_with("diagx"),
#'     match = "start", # "start" will be applied to all sources as length = 1
#'     vals = list(c("304"), c("305")),
#'     clnt_id = "clnt_id", # list()/c() could be omitted for single element
#'     # c() can be used in place of list
#'     # if this argument only takes one value for each source
#'     n_per_clnt = c(2, 3)
#'   )
#' )
#'
#' # save the definition for re-use
#' # saveRDS(sud_def, file = some_path)
#'
#' # execute definition
#' sud_by_src <- sud_def %>% execute_def(with_data = list(src1 = db, src2 = db))
#'
#' # pool results from src1 and src2 together at client level
#' sud_pooled <- pool_case(sud_by_src, sud_def, output_lvl = "clnt")
pool_case <- function(data, def, output_lvl = c("raw", "clnt"), valid_src_only = FALSE, ...) {
  . <- clnt_id <- date_var <- flag_restrict_dates <- flag_restrict_n <- flag_valid_record <- src <- max_date <- NULL

  output_lvl <- rlang::arg_match0(output_lvl, c("raw", "clnt"))

  # get variable names to keep from def
  dot <- def_to_dot(def)

  # bind data with obtained names
  bind_data <- bind_sources(data, !!!dot, ...)

  # interpret has date_var or not for later whether dates need to be summarized
  has_date_var <- ifelse("date_var" %in% names(dot), "y", "n")
  partial_date_var <- any(is.na(dot[["date_var"]]))

  # def_long <- def %>%
  #   tidyr::unnest(fn_args) %>%
  #   dplyr::mutate(fn_arg_names = sapply(def$fn_args, function(x) names(x)) %>% c()) %>%
  #   dplyr::select(-def_lab, -def_fn, -fn_call)
  # def_wide <- def_long %>% tidyr::pivot_wider(names_from = fn_arg_names, values_from = fn_args)
  # browser()

  # flag calculation
  # if not flag, assume 1
  has_n_flag <- "flag_restrict_n" %in% names(dot)
  has_date_flag <- "flag_restrict_dates" %in% names(dot)

  if (has_date_flag) {
    bind_data <- bind_data %>%
      dplyr::mutate(flag_valid_record = flag_restrict_dates)
    fill_src <- def$src_labs[which(is.na(dot[["flag_restrict_dates"]]))]
  } else if (has_n_flag) {
    bind_data <- bind_data %>%
      dplyr::mutate(flag_valid_record = flag_restrict_n)
    fill_src <- def$src_labs[which(is.na(dot[["flag_restrict_n"]]))]
  }

  if (has_date_flag | has_n_flag) {
    bind_data <- bind_data %>%
      dplyr::mutate(flag_valid_record = dplyr::case_when(src %in% local(fill_src) ~ 1L,
        .default = flag_valid_record
      ))
  } else {
    bind_data <- bind_data %>%
      dplyr::mutate(flag_valid_record = 1L)
  }
  # browser()

  if (!valid_src_only) {
    # filter out qualified clients
    bind_data <- bind_data %>%
      dplyr::group_by(def, clnt_id) %>%
      dplyr::filter(max(flag_valid_record, na.rm = TRUE) > 0L)
  } else {
    # filter out qualified clients (rows in the validated sources only)
    bind_data <- bind_data %>%
      dplyr::group_by(def, clnt_id, src) %>%
      dplyr::filter(max(flag_valid_record, na.rm = TRUE) > 0L) %>%
      dplyr::group_by(def, clnt_id)
  }
  # browser()

  # treat missing date_var
  order_raw <- c("def", "clnt_id", "date_var", "src", "uid")
  order_raw <- order_raw[order_raw %in% names(dot)]
  if (partial_date_var) {
    order_raw <- order_raw[order_raw != "date_var"]
  }

  # job done if output raw
  # lines after this return is for sum by clients
  if (output_lvl == "raw") {
    if (partial_date_var) {
      warning("'date_var' is missing in some of the sources. Records cannot be sorted by dates.")
    }
    return(bind_data %>%
      dplyr::arrange(dplyr::pick(dplyr::any_of(order_raw))) %>%
      dplyr::ungroup())
  }

  if (has_date_var == "y") {
    if (partial_date_var) {
      has_date_var <- "n"
      warning("'date_var' is missing in some of the sources. First/last date of valid records cannot be determined at client level")
    }
  }

  # start with getting the common steps for both data.frame and database
  # including get the last date
  # then filter valid entries only
  # branching by data type to sum first valid date and valid sources
  if (has_date_var == "y") {
    bind_data <- bind_data %>%
      dplyr::mutate(max_date = max(date_var, na.rm = TRUE))
  }
  bind_data <- bind_data %>%
    dplyr::filter(flag_valid_record == 1)

  # getting source indicators
  src_nm <- unique(def[["src_labs"]])
  src_formula <- purrr::map(src_nm, function(x) rlang::new_formula(NULL, rlang::expr(. == !!x)))
  names(src_formula) <- glue::glue("in_{src_nm}")
  bind_data <- bind_data %>%
    dplyr::mutate(dplyr::across(src, list(!!!src_formula), .names = "{.fn}"))

  if ("tbl_sql" %in% class(bind_data)) {
    win_order <- c("date_var", "src", "uid")
    bind_data <- bind_data %>%
      dbplyr::window_order(dplyr::pick(dplyr::any_of(win_order)))
  } else {
    bind_data <- bind_data %>%
      dplyr::arrange(dplyr::pick(dplyr::any_of(order_raw)))
  }

  switch(has_date_var,
         y = {
           bind_data <- bind_data %>%
             dplyr::summarise(
               first_valid_date = min(date_var, na.rm = TRUE),
               last_entry_date = max(max_date, na.rm = TRUE),
               dplyr::across(dplyr::starts_with("in_"), ~ sum(as.integer(.), na.rm = TRUE))
             )
         },
         n = {
           bind_data <- bind_data %>%
             dplyr::summarise(
               dplyr::across(dplyr::starts_with("in_"), ~ sum(as.integer(.), na.rm = TRUE))
             )
         }
  )

  # if ("tbl_sql" %in% class(bind_data)) {
  #   win_order <- c("date_var", "src", "uid")
  #   bind_data <- bind_data %>%
  #     dbplyr::window_order(dplyr::pick(dplyr::any_of(win_order)))
  #
  #   # SQL server vs SQLite differences
  #   is_mssql_mysql <- stringr::str_detect(dbplyr::remote_con(bind_data) %>% class(), "SQL Server|Maria") %>% any()
  #
  #   if (is_mssql_mysql) {
  #     switch(has_date_var,
  #       y = {
  #         bind_data <- bind_data %>%
  #           dplyr::summarise(
  #             first_valid_date = min(date_var, na.rm = TRUE),
  #             last_entry_date = max(max_date, na.rm = TRUE),
  #             from_src = dbplyr::sql(glue::glue_sql("STRING_AGG(DISTINCT {`src_nm`}, {sep})", .con = dbplyr::remote_con(bind_data), src_nm = "src", sep = ","))
  #           )
  #       },
  #       n = {
  #         bind_data <- bind_data %>%
  #           dplyr::summarise(
  #             from_src = dbplyr::sql(glue::glue_sql("STRING_AGG(DISTINCT {`src_nm`}, {sep})", .con = dbplyr::remote_con(bind_data), src_nm = "src", sep = ","))
  #           )
  #       }
  #     )
  #   } else {
  #     switch(has_date_var,
  #       y = {
  #         bind_data <- bind_data %>%
  #           dplyr::summarise(
  #             first_valid_date = min(date_var, na.rm = TRUE),
  #             last_entry_date = max(max_date, na.rm = TRUE),
  #             from_src = dbplyr::sql(glue::glue_sql("GROUP_CONCAT(DISTINCT {`src_nm`})", .con = dbplyr::remote_con(bind_data), src_nm = "src"))
  #           )
  #       },
  #       n = {
  #         bind_data <- bind_data %>%
  #           dplyr::summarise(
  #             from_src = dbplyr::sql(glue::glue_sql("GROUP_CONCAT(DISTINCT {`src_nm`})", .con = dbplyr::remote_con(bind_data), src_nm = "src"))
  #           )
  #       }
  #     )
  #   }
  # } else {
  #   bind_data <- bind_data %>%
  #     dplyr::arrange(dplyr::pick(dplyr::any_of(order_raw)))
  #
  #   switch(has_date_var,
  #     y = {
  #       bind_data <- bind_data %>%
  #         dplyr::summarise(
  #           first_valid_date = min(date_var, na.rm = TRUE),
  #           last_entry_date = max(max_date, na.rm = TRUE),
  #           from_src = paste(unique(src), collapse = ",")
  #         )
  #     },
  #     n = {
  #       bind_data <- bind_data %>%
  #         dplyr::summarise(
  #           from_src = paste(unique(src), collapse = ",")
  #         )
  #     }
  #   )
  # }

  return(bind_data %>% dplyr::ungroup())
}
