identify_encounter_sql <- function(remote_tbl, clnt_id_nm, var_nm_pattern, val_vector, match_type = "in", n_per_clnt = 1, collapse_by_nm = NULL, multi_var_cols = FALSE, verbose = TRUE, query_only = TRUE) {
  # input checks
  if (!any(class(remote_tbl) %in% c("tbl_dbi", "tbl_sql", "tbl_lazy"))) stop("remote_tbl must be a remote database table made by e.g., tbl(db_connection, in_schema('schema_name', 'table_name'))")

  if (any(sapply(list(clnt_id_nm, var_nm_pattern, collapse_by_nm), function(x) !is.null(x) & !is.character(x)))) stop("Arguments ended with _nm must be characters.")

  if (!(match_type %in% c("start", "regex", "in", "between"))) stop('match_type must be one of "start", "regex", "in", or "between"')

  if (match_type %in% c("in", "between")) {
    db_head <- utils::head(remote_tbl, n = 1) %>% dplyr::collect()
    var_class <- sapply(db_head[, grep(var_nm_pattern, names(db_head))], class)
    if (any(var_class != class(val_vector))) warning("val_vector (", class(val_vector), ") is not the same type as the var_nm column (", paste(var_class, collapse = ", "), ").")
  }

  #place holder for temp column names
  n_collapsed <- n_collapsed_id <- NULL

  # force exact match if single var col
  if (!multi_var_cols) {
    var_nm_regex <- paste0("^", var_nm_pattern, "$")
  } else {
    var_nm_regex <- var_nm_pattern
  }

  # code filter by match types:
  # logic to preserve original record as a row without copying the original data (use extra memory):
  # 1 get a vector of all possible values
  # 2 find the vector of matched values by match_type
  # 3 compute incl indicator by row id across var columns, so that TRUE if any col has a match
  # 4 filter rows by incl

  # Note that SQL does not support regular expression. The match is done by collecting all distinct possible values locally then using regex in R. The result is plugged into subseqent query as: WHERE var_nm IN (match_result).
  all_val <- remote_tbl %>%
    tidyr::pivot_longer(
      cols = dplyr::matches({{ var_nm_regex }}),
      names_to = "position",
      values_to = {{ var_nm_pattern }}
    ) %>%
    dplyr::select({{ var_nm_pattern }}) %>%
    dplyr::distinct() %>%
    dplyr::pull({{ var_nm_pattern }})

  # get matched values set by match_type
  if (match_type == "start") {
    # match_str/msg is for verbose
    match_str <- paste0("^", val_vector, collapse = "|")
    match_msg <- "satisfied regular expression"
    # extract matched values from all possible ones
    match_val <- all_val[data.table::like(all_val, match_str)]
  }
  if (match_type == "regex") {
    match_str <- paste0(val_vector, collapse = "|")
    match_msg <- "satisfied regular expression"
    match_val <- all_val[data.table::like(all_val, match_str)]
  }
  if (match_type == "in") {
    match_str <- deparse(substitute(val_vector))
    match_msg <- "exactly matched values in set"
    match_val <- val_vector
  }
  if (match_type == "between") {
    match_str <- deparse(substitute(val_vector))
    match_msg <- "between range (bounds included)"
    match_val <- all_val[`%between%`(all_val, val_vector)]
  }

  # run filter with matched value set
  q_any_match <- remote_tbl %>%
    dplyr::filter(dplyr::if_any(dplyr::matches(var_nm_regex), ~ . %in% dbplyr::sql(dbplyr::escape_ansi(match_val, collapse = ",", parens = TRUE))))

  # explain the configuration in plain language to prompt user thinking
  if (verbose) {
    cat(
      "\nSearching conditions:\nEach client has at least", n_per_clnt, "record(s)", ifelse(is.null(collapse_by_nm), "", paste("with distinct", collapse_by_nm)),
      "\n - where", ifelse(multi_var_cols, "at least one of the", "the single"), var_nm_pattern, "column in each record",
      "\n   - contains a value", match_msg, match_str, "\n"
    )

    cat("\nList of all matched value(s):\n")
    print(match_val)
  }

  # job done if getting any records
  if (n_per_clnt == 1) {
    if (!query_only) q_any_match <- q_any_match %>% dplyr::collect()
    return(q_any_match)
  }

  # keep records for person with number of records >= n_per_clnt
  else {
    # count differently if unit id is supplied by collaspe_by_nm
    if (!is.null(collapse_by_nm)) {
      q_n <- q_any_match %>%
        dplyr::group_by(.data[[clnt_id_nm]]) %>%
        dbplyr::window_order(.data[[collapse_by_nm]]) %>%
        dplyr::mutate(
          n_collapsed_id = dplyr::dense_rank(.data[[collapse_by_nm]]),
          n_collapsed = max(n_collapsed_id, na.rm = TRUE)
        ) %>%
        dplyr::filter(n_collapsed >= n_per_clnt) %>%
        dplyr::select(-dplyr::starts_with("n_collapsed"))
    } else {
      q_n <- q_any_match %>%
        dplyr::group_by(.data[[clnt_id_nm]]) %>%
        dplyr::filter(dplyr::n() >= {{ n_per_clnt }})
    }

    if (verbose) {
      cat(
        "\nTo see the final query generated by 'dbplyr', use dplyr::show_query() on the output.", ifelse(query_only, "The query result is groupped by client; keep that in mind if you would apply further operations on the output tbl_sql object.\n", "\n"),
        "\nTo get the SQL string, use dbplyr::remote_query(), then as.character() if needed.\n"
      )
    }

    if (!query_only) q_n <- q_n %>% dplyr::collect() %>% dplyr::ungroup()
    return(q_n)
  }
}
