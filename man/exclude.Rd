% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/exclude.R
\name{exclude}
\alias{exclude}
\title{Remove rows based on conditions or another data set}
\usage{
exclude(
  data,
  excl = NULL,
  by = NULL,
  condition = NULL,
  verbose = TRUE,
  report_on = NULL,
  ...
)
}
\arguments{
\item{data}{Data frames or remote tables (e.g., from dbplyr). A subset will be removed from this data.}

\item{excl}{Data frames or remote tables (e.g., from dbplyr). Rows/values present in it will be removed from `data` if there is a match. This will be passed to dplyr::anti_join as the second argument.}

\item{by}{Column names that should be matched by anti_join or dplyr::join_by expressions. See anti_join's `by` argument for detail. Default NULL is the same as setdiff(data, excl).}

\item{condition}{An expression that will be negated then passed to dplyr::filter, so the rows that satisfy `condition` are those to be removed from `data`.}

\item{verbose}{A logical for whether printing explanation for the operation.}

\item{report_on}{A quoted/unquoted column name for counting how many of its distinct values were removed from `data`, e.g., counting how many client IDs were removed. Default is NULL.}

\item{...}{Additional arguments passing to filter/anti_join for finer control of matching, e.g., na action, by-group filtering, etc.}
}
\value{
A data frame or remote table that is a subset of `data`.
}
\description{
This function combines `dplyr::anti_join` and the opposite of `dplyr::filter`. When the second data set is supplied through the `excl` argument, anti join would be performed; otherwise, `data` would be filtered with negation of the expression given via the `condition` argument.
}
\examples{
#exclude with condition
cyl4 <- exclude(mtcars, condition = cyl == 4, report_on = cyl)

#exclude with another data
exclude(mtcars, cyl4, dplyr::join_by(cyl), report_on = cyl)
}
