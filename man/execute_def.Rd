% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/execute_def.R
\name{execute_def}
\alias{execute_def}
\title{Execute parameterized case definitions}
\usage{
execute_def(
  def,
  with_data,
  bind = TRUE,
  force_proceed = FALSE,
  force_collect = FALSE
)
}
\arguments{
\item{def}{A tibble created by build_def().}

\item{with_data}{A named list which the elements are in the form of src_lab = data, where `src_lab` corresponds to the src_labs argument from build_def() and `data` is the data object that will be passed to calls stored in def. The names (and length) of with_data must match the unique values of src_labs in def.}

\item{bind}{A logical for whether row-binding records from multiple sources into one table. Note that the binding may fail in ways that are difficult to anticipate in advance, such as data type conflict (e.g., Date vs. character) between variables in the same name from different sources. The default behavior is to try and return the unbinded result if failed.}

\item{force_proceed}{A logical for whether to ask for user input in order to proceed when remote tables are needed to be collected for binding. The default is TRUE to let user be aware of that the downloading process may be slow.}

\item{force_collect}{A logical for whether collecting remote table as local table regardless of binding. If False (default), remote table would be collected only when bind = TRUE AND the sources are a mix of remote and local data.}
}
\value{
A single (if bind = TRUE) or a list of data.frames or remote tables.
}
\description{
This function executes the function calls stored in the output tibble from build_def() with data objects supplied through a named list and returns the results as a list. It is intended to facilitate re-use of pre-defined calls with different data.
}
\examples{
# toy data
sample_size <- 30
df <- data.frame(
  clnt_id = rep(1:3, each = 10),
  service_dt = sample(seq(as.Date("2020-01-01"), as.Date("2020-01-31"), by = 1),
    size = sample_size, replace = TRUE
  ),
  diagx = sample(letters, size = sample_size, replace = TRUE),
  diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),
  diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE)
)

# make a remote version of df
db <- dbplyr::tbl_memdb(df)

# use build_def to make a toy definition
sud_def <- build_def("SUD", # usually a disease name
  src_lab = c("src1", "src2"), # identify from multiple sources, e.g., hospitalization, ED visits.
  # functions that filter the data with some criteria
  def_fn = list(define_case),
  fn_args = list(
    vars = list(bquote(starts_with("diagx"))), # use bquote to pass tidyselect expressions
    match = "start", # "start" will be applied to all sources as length = 1
    vals = list(c("304"), c("305")),
    clnt_id = "clnt_id",
    # c() can be used in place of list
    # if this argument only takes one value for each source
    n_per_clnt = c(2, 3)
  )
)

# save the definition for re-use
# saveRDS(sud_def, file = some_path)

sud_def \%>\% execute_def(with_data = list(src1 = df, src2 = db), force_proceed = TRUE)
}
