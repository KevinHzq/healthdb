% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/identify_rows.R
\name{identify_rows}
\alias{identify_rows}
\title{Identify rows with a match}
\usage{
identify_rows(
  data,
  vars,
  match = c("in", "start", "regex", "like", "between", "glue_sql"),
  vals,
  if_all = FALSE,
  verbose = TRUE,
  query_only = TRUE,
  ...
)
}
\arguments{
\item{data}{Data frames or remote tables (e.g., from dbplyr)}

\item{vars}{An expression passing to \code{dplyr::select()}. It can be Quoted/unquoted column names, or \code{tidyselect} helper functions, such as \code{starts_with()}.}

\item{match}{One of "in", "start", "regex", "like", "between", and "glue_sql". It determines how values would be matched. The operations under each type:
\itemize{
\item "in" ~ var \%in\% vals
\item "regex" ~ var data.table::\verb{\%like\%} vals. For remote tables, unique values in vars are collected locally before matching (may be slow).
\item "like" ~ stringr::str_like(var, vals). For remote tables, WHERE var LIKE val.
\item "start" ~ same as regex or LIKE with modified vals, e.g., "^val1|^val2" or "va1\%|val2\%"
\item "between" ~ dplyr::between(var, val1, val2)
\item "glue_sql" ~ For remote table only, this gives full control of the WHERE clause using dplyr::filter(dbplyr::sql(glue::glue_sql(...)))
}}

\item{vals}{Depending on \code{match}, it takes different input:
\itemize{
\item "in" ~ a vector of values (numeric/character/Date)
\item "start" ~ a vector of numeric/character that would be modified into a regex or LIKE pattern string by adding "^" in front or "\%" at the end
\item "regex"/"like" ~ a string of the expression
\item "between" ~ a vector of numeric or date with exactly two elements, e.g., c(lower, upper)
\item "glue_sql" ~ a string of the part of query after WHERE, which will be passed to glue::glue_sql(). See ?glue_sql and example for detail.
}}

\item{if_all}{A logical for whether combining the predicates (if multiple columns were selected by vars) with AND instead of OR. Default is FALSE, e.g., var1 in vals OR var2 in vals.}

\item{verbose}{A logical for whether printing explanation and result overview for the query.}

\item{query_only}{A logical for whether keeping the output as remote table (Default TRUE) or downloading the query result as a tibble (FALSE). The argument is ignored when the input data is a data.frame/tibble.}

\item{...}{For remote table method only. Additional arguments passing to \code{glue::glue_sql()} for parameterized queries.}
}
\value{
A data.frame or dplyr::tbl() object depending on the input.
}
\description{
Filter rows which values satisfy the specified conditions. The function is similar to dplyr::filter(if_any/if_all(...)), but it used \code{data.table} for data.frame method, and has regular regular expression support for remote database tables. The motivation is to take away some pain when working with databases which often have no regex and LIKE with multiple patterns support.
}
\examples{
#applying to data.frame; both sepal length and width in range 3-5
identify_rows(iris, starts_with("Sepal"), "between", c(3, 5), if_all = TRUE)

#applying to remote table; species starts with se or ends with ca
iris_db <- dbplyr::memdb_frame(iris)
identify_rows(iris_db, Species, "like", c("se\%", "\%ca"))

#using glue_sql to write the WHERE clause
#use {`vars`} to refer to the variables selected by vars
#supply additional values required in the query through the ...
#note that if you use LIKE here, you cannot supply multiple patterns in what
identify_rows(iris_db, Species, "glue_sql", "{`vars`} LIKE {what}", what = "se\%")

#you could also set query parameters in the global environment
what <- c("setosa", "virginica")
identify_rows(iris_db, Species, "glue_sql", "{`vars`} IN ({what*})")
}
