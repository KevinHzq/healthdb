% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/define_case.R
\name{define_case}
\alias{define_case}
\title{Identify diseases/events from administrative records}
\usage{
define_case(
  data,
  vars,
  match = "in",
  vals,
  clnt_id,
  n_per_clnt = 1,
  date_var = NULL,
  apart = NULL,
  within = NULL,
  excl_vals = NULL,
  excl_args = NULL,
  keep = c("all", "first", "last"),
  if_all = FALSE,
  force_collect = FALSE,
  verbose = getOption("odcfun.verbose"),
  ...
)
}
\arguments{
\item{data}{Data frames or remote tables (e.g., from dbplyr)}

\item{vars}{An expression passing to `dplyr::select()`. It can be Quoted/unquoted column names, or `tidyselect` helper functions, such as `starts_with()`.}

\item{match}{One of "in", "start", "regex", "like", "between", and "glue_sql". It determines how values would be matched. See `identify_rows()` for detail.}

\item{vals}{Depending on `match`, it takes different input. See `identify_rows()`.}

\item{clnt_id}{Grouping variable (quoted/unquoted).}

\item{n_per_clnt}{A single number specifying the minimum number of group size. See `restrict_n()` for detail. It would also be used as the n argument for `restrict_dates()`.}

\item{date_var}{Variable name (quoted/unquoted) for the dates to be interpreted. If present, it would be used as the count_by argument for `restrict_n()`.}

\item{apart}{An integer specifying the minimum gap (in days) between adjacent dates in a draw. See `restrict_dates()`.}

\item{within}{An integer specifying the maximum time span (in days) of a draw.}

\item{excl_vals}{Same as `vals` but groups with these values are going to be removed from the result.}

\item{excl_args}{A named list of arguments for the second `identify_rows()` call for `excl_vals`. If not supplied, `var`, `match` and `if_all` of the first call will be re-used.}

\item{keep}{One of "first" (keeping each client's earliest record), "last" (keeping the latest), and "all" (keeping all relevant records, default).}

\item{if_all}{A logical for whether combining the predicates (if multiple columns were selected by vars) with AND instead of OR. Default is FALSE, e.g., var1 in vals OR var2 in vals.}

\item{force_collect}{A logical for whether force downloading remote table if `apart` is not NULL. For remote table only, because `apart` is implemented for local data frame only. Downloading data could be slow, so the user has to opt in; default FALSE will stop with error.}

\item{verbose}{A logical for whether printing explanation for the operation. Default is fetching from options. Use options(odcfun.verbose = FALSE) to suppress once and for all.}

\item{...}{Additional arguments passing to `restrict_dates()`.}
}
\value{
A subset of input data satisfied the specified case definition.
}
\description{
This function is a composite of identify_rows, exclude, and restrict_. It is aimed to implement case definition, e.g., two or more physician visits with some diagnostic code at least 30 days apart within two years, in one shot. The component functions are chained in the following order if all arguments were supplied (see the verbose output for what was done if some arguments are missing): identify_rows(vals) %>% exclude(identify_rows(excl_vals), by = clnt_id) %>% restrict_n() %>% restrict_dates()
}
\examples{
sample_size <- 30
df <- data.frame(
  clnt_id = rep(1:3, each = 10),
  service_dt = sample(seq(as.Date("2020-01-01"), as.Date("2020-01-31"), by = 1),
    size = sample_size, replace = TRUE
  ),
  diagx = sample(letters, size = sample_size, replace = TRUE),
  diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),
  diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE)
)

# define from one source
define_case(df,
  vars = starts_with("diagx"), "in", vals = letters[1:4],
  clnt_id = clnt_id, date_var = service_dt,
  excl_args = list(if_all = TRUE),
  keep = "first"
)

# multiple sources with purrr::pmap
# arguments with length = 1 will be recycle to match the number of sources
# wrap expressions/unquoted variables with bquote(),
# or rlang:exprs() to prevent immediate evaluation,
# or just use quoted variable names
purrr::pmap(
  list(
    data = list(df, df),
    vars = rlang::exprs(starts_with("diagx")),
    match = c("in", "start"),
    vals = list(letters[1:4], letters[5:10]),
    clnt_id = list(bquote(clnt_id)), n_per_clnt = c(2, 3),
    date_var = "service_dt",
    excl_vals = list(letters[11:13], letters[14:16]),
    excl_args = list(list(if_all = TRUE), list(if_all = FALSE))
  ),
  define_case
)
}
