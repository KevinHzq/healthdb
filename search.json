[{"path":"https://kevinhzq.github.io/healthdb/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 healthdb authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://kevinhzq.github.io/healthdb/articles/Intro.html","id":"sec-what-it-does","dir":"Articles","previous_headings":"","what":"What it does","title":"Intro","text":"package designed identifying disease cases admin data epidemiological studies. implementation focused code readability re-usability. Three types functions included: Interactive functions (e.g., identify_row(), exclude(), fetch_var()) based filter joins dplyr tweaks fix SQL translation add features natively support SQL. also work local data.frame, use ‘data.table’ package (vignette(\"datatable-intro\", package = \"data.table\")) speed processing time large data. functions flexible dplyr::filter(), general enough useful outside health research. Call-building functions (e.g., build_def(), execute_def()) facilitate batch execution re-use case definitions. essence, build_def creates codes definitions (chain interactive functions, e.g., define_case()) immediately ran. execute_def runs built definitions different input data. Miscellaneous functions computing age, collapsing records within time range one episode, (-going effort) built-checks signalling things go wrong.","code":""},{"path":"https://kevinhzq.github.io/healthdb/articles/Intro.html","id":"motivation","dir":"Articles","previous_headings":"What it does","what":"Motivation","title":"Intro","text":"Administrative health data data often stored database strict security measures may disable permission write temporary tables. Writing queries without able cache intermediate results challenging, especially data large downloaded database R (.e., local memory) without filtering process. lack regular expression support SQL makes writing queries searching ICD codes even painful. ‘dbplyr’ package translates ‘dplyr’ syntax SQL also make nesting sub-queries easy pipe operator. ‘dbplyr’, complex query script can built nested sub-queries instead writing temporary tables cost performance (sub-queries ran called multiple times). Nevertheless, building complex queries ‘dbplyr’ useful approach push computation onto SQL server often much efficient resourceful user’s (virtual) machine. However, ‘dbplyr’ SQL translations failed places intended use case needs fixing. motivation package ease pain issues analyst regularly works healthcare database.","code":""},{"path":"https://kevinhzq.github.io/healthdb/articles/Intro.html","id":"sec-installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Intro","text":"Simply run: also need following packages demo.","code":"devtools::install_github(\"kevinHzq/healthdb\", build_vignettes = TRUE) library(dplyr) library(dbplyr) library(lubridate) library(glue) library(purrr) library(healthdb)"},{"path":"https://kevinhzq.github.io/healthdb/articles/Intro.html","id":"sec-intended-use-case","dir":"Articles","previous_headings":"","what":"Intended use case","title":"Intro","text":"Consider case definition substance use disorder (SUD) British Columbia Centre Disease Control’s Chronic Disease Dashboard, One hospitalization substance use disorder diagnostic code, Two physician visits substance use disorder diagnostic code within one year. going implement definition. First, let’s make demo data sets two sources: Physician claims multiple columns ICD-9 diagnostic codes Hospitalization ICD-10 codes","code":"# make_test_dat() makes either a toy data.frame or database table in memory with known number of rows that satisfy the query we will show later claim_db <- make_test_dat(vals_kept = c(\"303\", \"304\", \"305\", \"291\", \"292\", glue(\"30{30:59}\"), glue(\"29{10:29}\"), noise_val = c(\"999\", \"111\")), type = \"database\")  # this is a database table # note that in-memory SQLite database stores dates as numbers claim_db %>% head() #> # Source:   SQL [6 x 6] #> # Database: sqlite 3.45.2 [:memory:] #>     uid clnt_id dates diagx diagx_1 diagx_2 #>   <int>   <int> <dbl> <chr> <chr>   <chr>   #> 1    24       1 16484 2915  3039    NA      #> 2     2       1 16794 2911  2925    NA      #> 3    31       1 18205 3052  2917    999     #> 4    42       2 17232 3056  3035    2923    #> 5    99       2 17496 999   999     999     #> 6    54       3 17583 999   NA      999 hosp_df <- make_test_dat(vals_kept = c(glue(\"F{10:19}\"), glue(\"F{100:199}\"), noise_val = \"999\"), type = \"data.frame\")  # this is a local data.frame/tibble hosp_df %>% head() #>   uid clnt_id      dates diagx diagx_1 diagx_2 #> 1  29       1 2018-11-27  F117    F137    <NA> #> 2  22       1 2020-09-08  F174     F17     999 #> 3  40       2 2015-10-14  F149    F177    <NA> #> 4  97       2 2020-02-05   999     999     999 #> 5  52       3 2017-03-06   999    <NA>     999 #> 6  78       4 2019-12-10   999    <NA>    <NA>"},{"path":"https://kevinhzq.github.io/healthdb/articles/Intro.html","id":"interactive-functions","dir":"Articles","previous_headings":"","what":"Interactive functions","title":"Intro","text":"Let’s focus physician claims. Extracting clients least two records within year difficult, involves steps. codes look like following using dplyr, however, work : 1. SQL support multiple patterns one LIKE operation, 2. dbply currently issue translating n_distinct. ’s use healthdb achieve steps: Identify rows contains target codes Bonus: remove clients exclusion codes step substance use disorder definition, disease definitions often require exclusion ICDs contradicts ones interest. Let’s say want remove clients code “111” . first identify “111” source, exclude clients output previous step’s result. exclude() take either data set (via excl argument) expression (condition argument) input. former, performs anti join matching argument (see dplyr::join_by()). latter, opposite filter, .e., filter(!(some_expression)). Restrict number records per client Restrict temporal pattern diagnoses restrict_date() also supports complicated patterns like n diagnoses least days apart within j years, “apart” feature requires relatively expensive computation implemented local data.frames . Note SQL interpret order dates, result deterministic duplicate dates within client. Therefore, unique row id colume (uid) supplied get consistent result. Fetch variables tables matching common keys point, result query downloaded. Hopefully, shrunken manageable size collection. data now contains diagnoses probably enough analyses. Let’s say want gather client demographics age sex sources. certainly can done multiple dplyr::left_join() calls. provide fetch_var() function make codes concise.","code":"## not run claim_db %>%   # identify the target codes   filter(if_any(starts_with(\"diagx_\"), ~ str_like(., c(\"291%\", \"292%\", \"303%\", \"304%\", \"305%\")))) %>%   # each clnt has at least 2 records on different dates   group_by(clnt_id) %>%   # the n_distinct step is mainly for reducing computation in the next step   filter(n_distinct(dates) >= 2) %>%   # any two dates within one year?   filter((max(dates) - min(dates)) <= 365) ## end result1 <- claim_db %>%   identify_row( vars = starts_with(\"diagx_\"), match = \"start\", vals = c(291:292, 303:305)   ) #>  #> Identify records with condition(s):  #>  - where at least one of the diagx_1, diagx_2 column(s) in each record  #>    - contains a value satisfied SQL LIKE pattern: 291% OR 292% OR 303% OR 304% OR 305%  #>  #> To see the final query generated by 'dbplyr', use dplyr::show_query() on the output.  #> To extract the SQL string, use dbplyr::remote_query(). result2 <- result1 %>%   exclude( excl = identify_row(claim_db, starts_with(\"diagx_\"), \"in\", \"111\"), by = \"clnt_id\"   ) #>  #> Identify records with condition(s):  #>  - where at least one of the diagx_1, diagx_2 column(s) in each record  #>    - contains a value exactly matched values in set: \"111\"  #>  #> To see the final query generated by 'dbplyr', use dplyr::show_query() on the output.  #> To extract the SQL string, use dbplyr::remote_query(). #>  #> Exclude records in `data` through anti_join with `excl` matching on (by argument): \"clnt_id\" result3 <- result2 %>% restrict_n(   clnt_id = clnt_id,   n_per_clnt = 2,   count_by = dates,   # here we use filter mode to remove records that failed the restriction   mode = \"filter\" ) #>  #> Apply restriction that each client must have at least 2 records with distinct dates. Clients/groups whichdid not meetthe condition were excluded. result4 <- result3 %>% restrict_date(   clnt_id = clnt_id,   date_var = dates,   n = 2,   within = 365,   uid = uid,   # here we use flag mode to flag records that met the restriction instead of removing those   mode = \"flag\" ) #>  #> Apply restriction that each client must have 2 records that were  within 365 days. Records that met the condition were flagged. # Class of result4 class(result4) #> [1] \"tbl_SQLiteConnection\" \"tbl_dbi\"              \"tbl_sql\"              #> [4] \"tbl_lazy\"             \"tbl\"  # execute query and download the result result_df <- result4 %>% collect()  # Number of rows in source nrow(claim_db %>% collect()) #> [1] 100  # Number of rows in the current result nrow(result_df) #> [1] 23 # make two look up tables age_tab <- data.frame(   clnt_id = 1:50,   age = sample(1:90, 50),   sex = sample(c(\"F\", \"M\"), 50, replace = TRUE) ) address_tab <- data.frame(   clnt_id = rep(1:50, 5), year = rep(2016:2020, each = 50),   area_code = sample(0:200, 50, replace = TRUE) )  # get year from dates for matching  result_df <- result_df %>% mutate(year = lubridate::year(as.Date(dates, origin = \"1970-01-01\")))  # note that keys must be present in all tables result_df %>%   fetch_var( keys = c(clnt_id, year), linkage = list(   # |clnt_id means matching on clnt_id only   age_tab ~ c(age, sex) | clnt_id,   address_tab ~ area_code )   ) %>%   head() #>  #> The data has 23 rows. After joining, variable(s) from age_tab has 23 rows, and variable(s) from address_tab has 23 rows #> # A tibble: 6 × 12 #>     uid clnt_id dates diagx diagx_1 diagx_2 flag_restrict_n flag_restrict_date #>   <int>   <int> <dbl> <chr> <chr>   <chr>             <int>              <int> #> 1    24       1 16484 2915  3039    NA                    1                  1 #> 2     2       1 16794 2911  2925    NA                    1                  0 #> 3    31       1 18205 3052  2917    999                   1                  0 #> 4    30      12 17862 3044  2924    NA                    1                  1 #> 5    33      12 17888 2917  3039    999                   1                  1 #> 6    10      12 18155 3035  3048    999                   1                  0 #> # ℹ 4 more variables: year <dbl>, age <int>, sex <chr>, area_code <int>"},{"path":"https://kevinhzq.github.io/healthdb/articles/Intro.html","id":"call-building-functions","dir":"Articles","previous_headings":"","what":"Call-building functions","title":"Intro","text":"complete definition, need repeat process shown hospitalization data. studies may use handful data sources define sample. packed steps 1-4 one function define_case(), provide tools perform batch execution different data parameters meet needs. Let’s look inside fn_call list column. Two calls define_case() made different parameters. data arguments left empty purpose re-usability. example, may want repeat analysis data different regions study periods. Executing definition simple. verbose option turned options(healthdb.verbose = FALSE), output message explain done. append multiple build_def() outputs together execute . Definition source labels added result identify outputs different calls. Let’s check results! point, result claim database (result[[1]]) collected locally. collect manually, filtering, combine result hospitalization data way want. just need simple row bind, bind_source() convenient naming feature.","code":"# build the full definition of SUD sud_def <- build_def(   # name of definition   def_lab = \"SUD\",   # place holder names for sources   src_labs = c(\"claim\", \"hosp\"),   def_fn = define_case, # you could alter it and supply your own function   # below are argumets of define_case   fn_args = list(     # if length = 1, the single element will be use for every source     vars = list(starts_with(\"diagx_\")),     match = \"start\", # match ICD starts with vals     vals = list(c(291:292, 303:305), glue(\"F{10:19}\")),     clnt_id = clnt_id,     n_per_clnt = c(2, 1),     date_var = dates,     within = c(365, NULL),     uid = uid,     mode = \"flag\"   ) )  sud_def #> # A tibble: 2 × 5 #>   def_lab src_labs def_fn      fn_args          fn_call    #>   <chr>   <chr>    <chr>       <list>           <list>     #> 1 SUD     claim    define_case <named list [9]> <language> #> 2 SUD     hosp     define_case <named list [9]> <language> sud_def$fn_call #> [[1]] #> define_case(data = , vars = starts_with(\"diagx_\"), match = \"start\",  #>     vals = c(291:292, 303:305), clnt_id = clnt_id, n_per_clnt = 2,  #>     date_var = dates, within = 365, uid = uid, mode = \"flag\") #>  #> [[2]] #> define_case(data = , vars = starts_with(\"diagx_\"), match = \"start\",  #>     vals = glue(\"F{10:19}\"), clnt_id = clnt_id, n_per_clnt = 1,  #>     date_var = dates, within = NULL, uid = uid, mode = \"flag\") # execute the definition result_list <- sud_def %>%   execute_def(with_data = list(     claim = claim_db,     hosp = hosp_df   )) #>  #> Processing source: claim_db #> --------------Inclusion step-------------- #>  #> Identify records with condition(s):  #>  - where at least one of the diagx_1, diagx_2 column(s) in each record  #>    - contains a value satisfied SQL LIKE pattern: 291% OR 292% OR 303% OR 304% OR 305%  #>  #> To see the final query generated by 'dbplyr', use dplyr::show_query() on the output.  #> To extract the SQL string, use dbplyr::remote_query(). #>  #> --------------No. rows restriction-------------- #>  #> Apply restriction that each client must have at least 2 records with distinct dates. Clients/groups whichmetthe condition were flagged.  #>  #> --------------Time span restriction-------------- #>  #> Apply restriction that each client must have 2 records that were  within 365 days. Records that met the condition were flagged.  #>  #> -------------- Output all records-------------- #>  #> Processing source: hosp_df #> --------------Inclusion step-------------- #>  #> Identify records with condition(s):  #>  - where at least one of the diagx_1, diagx_2 column(s) in each record  #>    - contains a value satisfied regular expression: ^F10|^F11|^F12|^F13|^F14|^F15|^F16|^F17|^F18|^F19  #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other columns):  #>  999 F108  F11 F110 F113 F116 F118  F12 F121 F122 F123  F13 F131 F136 F137  F14  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #> F140 F142 F145 F146 F148  F15 F153 F155 F162 F163 F164 F165 F167 F168  F17 F171  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #> F172 F174 F177 F178 F179 F183 F186 F188  F19 F193 F194 F196 F199 NA's  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #>  #> -------------- Output all records-------------- # view the results purrr::walk(result_list, ~ head(.) %>% print()) #> # Source:     SQL [6 x 10] #> # Database:   sqlite 3.45.2 [:memory:] #> # Ordered by: dates, uid #>   def   src     uid clnt_id dates diagx diagx_1 diagx_2 flag_restrict_n #>   <chr> <chr> <int>   <int> <dbl> <chr> <chr>   <chr>             <int> #> 1 SUD   claim    24       1 16484 2915  3039    NA                    1 #> 2 SUD   claim     2       1 16794 2911  2925    NA                    1 #> 3 SUD   claim    31       1 18205 3052  2917    999                   1 #> 4 SUD   claim    42       2 17232 3056  3035    2923                  0 #> 5 SUD   claim    40       5 16798 291   3053    NA                    0 #> 6 SUD   claim    49       6 17195 3054  3043    2928                  0 #> # ℹ 1 more variable: flag_restrict_date <int> #>   def  src uid clnt_id      dates diagx diagx_1 diagx_2 #> 1 SUD hosp  29       1 2018-11-27  F117    F137    <NA> #> 2 SUD hosp  22       1 2020-09-08  F174     F17     999 #> 3 SUD hosp  40       2 2015-10-14  F149    F177    <NA> #> 4 SUD hosp  38       5 2017-05-29  F144    F171     999 #> 5 SUD hosp  47       6 2019-11-24  F183     F19    F183 #> 6 SUD hosp   5       7 2016-09-22  F106    F145     999 bind_source(result_list,   # output_name = c(names in the list elements)   src = \"src\",   uid = \"uid\",   clnt_id = \"clnt_id\",   flag_date = c(\"flag_restrict_date\", NA),   force_proceed = TRUE ) #> # A tibble: 96 × 5 #>    src_No src     uid clnt_id flag_date #>     <int> <chr> <int>   <int>     <int> #>  1      1 claim    24       1         1 #>  2      1 claim     2       1         0 #>  3      1 claim    31       1         0 #>  4      1 claim    42       2         0 #>  5      1 claim    40       5         0 #>  6      1 claim    49       6         0 #>  7      1 claim     7       7         0 #>  8      1 claim    46      10         0 #>  9      1 claim    30      12         1 #> 10      1 claim    33      12         1 #> # ℹ 86 more rows"},{"path":"https://kevinhzq.github.io/healthdb/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kevin Hu. Author, maintainer, copyright holder.","code":""},{"path":"https://kevinhzq.github.io/healthdb/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hu K (2024). healthdb: Working Healthcare Databases. R package version 0.1.0.9000, https://kevinhzq.github.io/healthdb/, https://github.com/KevinHzq/healthdb.","code":"@Manual{,   title = {healthdb: Working with Healthcare Databases},   author = {Kevin Hu},   year = {2024},   note = {R package version 0.1.0.9000, https://kevinhzq.github.io/healthdb/},   url = {https://github.com/KevinHzq/healthdb}, }"},{"path":"https://kevinhzq.github.io/healthdb/index.html","id":"healthdb-","dir":"","previous_headings":"","what":"Working with Healthcare Databases","title":"Working with Healthcare Databases","text":"goal ‘healthdb’ provide set tools identifying diseases events healthcare database preparing data epidemiological studies. features abilities natively support database, matching strings ‘stringr’ style regular expression using ‘LIKE’ operator multiple patterns vector. Three types functions included: interactive functions – customizing complex definitions; call building functions – batch execution simple definition; miscellaneous functions – data wrangling, computing age comorbidity index, etc. package tested SQL Server SQLite access SQL dialects. Please report bugs encounter issues dialects. Administrative health data often stored SQL database strict security measures may disable permission write temporary tables. Writing queries without able cache intermediate results challenging, especially data large downloaded database R (.e., local memory) without filtering process. package leverages ‘dbplyr’, particularly ability chain subqueries, order implement common disease definition one-shot big query. Outputs fully compatible ‘dplyr’ functions. Common disease definitions often form n primary care/hospitalization/prescription records International Classification Diseases (ICD) codes within time span. See example implementing case definition.","code":""},{"path":"https://kevinhzq.github.io/healthdb/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Working with Healthcare Databases","text":"Install CRAN: also install development version GitHub :","code":"install.packages(\"healthdb\") # install.packages(\"devtools\") devtools::install_github(\"KevinHzq/healthdb\")"},{"path":"https://kevinhzq.github.io/healthdb/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Working with Healthcare Databases","text":"Case definition: One hospitalization substance use disorder (SUD) diagnostic code, Two physician claims substance use disorder diagnostic code within one year. going implement definition. First, let’s make demo data sets two sources: Physician claims Hospitalization ’s use healthdb implement SUD definition : Identify rows contains target codes claim database Restrict number records per client Restrict temporal pattern diagnoses Repeat steps hospitalization row bind results. output functions, including identify_row(), exclude(), restrict_n(), restrict_date() can piped ‘dplyr’ functions manipulations. Therefore, wrangling along ‘dplyr’ provide maximum flexibility implementing complex algorithms. However, code look repetitive multiple data sources involved. See “Intro” vignette (vignette(\"Intro\")) much concise way work multiple sources definitions (‘Call-building functions’ section).","code":"library(healthdb) library(tidyverse)  # make_test_dat() makes either a toy data.frame or database table in memory with known number of rows that satisfy the query we will show later claim_db <- make_test_dat(vals_kept = c(\"303\", \"304\", \"305\", \"291\", \"292\", str_glue(\"30{30:59}\"), str_glue(\"29{10:29}\"), noise_val = c(\"999\", \"111\")), type = \"database\")  # this is a database table # note that in-memory SQLite database stores dates as numbers claim_db %>% head() #> # Source:   SQL [6 x 6] #> # Database: sqlite 3.45.2 [:memory:] #>     uid clnt_id dates diagx diagx_1 diagx_2 #>   <int>   <int> <dbl> <chr> <chr>   <chr>   #> 1    11       1 16548 3046  3037    999     #> 2    46       1 18004 3044  2922    2913    #> 3    75       1 18261 999   <NA>    <NA>    #> 4    88       2 17712 999   <NA>    999     #> 5    99       3 17869 999   999     999     #> 6    96       4 18436 999   <NA>    999 hosp_df <- make_test_dat(vals_kept = c(str_glue(\"F{10:19}\"), str_glue(\"F{100:199}\"), noise_val = \"999\"), type = \"data.frame\")  # this is a local data.frame/tibble hosp_df %>% head() #>   uid clnt_id      dates diagx diagx_1 diagx_2 #> 1  83       1 2018-07-14   999    <NA>     999 #> 2  60       3 2018-03-09   999    <NA>     999 #> 3  84       4 2015-12-15   999     999    <NA> #> 4  24       5 2015-02-02  F172     999     999 #> 5  54       5 2017-07-23   999    <NA>    <NA> #> 6  78       7 2016-10-20   999     999     999 result1 <- claim_db %>%   identify_row( vars = starts_with(\"diagx_\"), match = \"start\", vals = c(291:292, 303:305)   ) #>  #> Identify records with condition(s):  #>  - where at least one of the diagx_1, diagx_2 column(s) in each record  #>    - contains a value satisfied SQL LIKE pattern: 291% OR 292% OR 303% OR 304% OR 305%  #>  #> To see the final query generated by 'dbplyr', use dplyr::show_query() on the output.  #> To extract the SQL string, use dbplyr::remote_query(). result2 <- result1 %>% restrict_n(   clnt_id = clnt_id,   n_per_clnt = 2,   count_by = dates,   # here we use filter mode to remove records that failed the restriction   mode = \"filter\" ) #>  #> Apply restriction that each client must have at least 2 records with distinct dates. Clients/groups whichdid not meetthe condition were excluded. result2 %>% head() #> # Source:     SQL [6 x 7] #> # Database:   sqlite 3.45.2 [:memory:] #> # Ordered by: dates #>     uid clnt_id dates diagx diagx_1 diagx_2 flag_restrict_n #>   <int>   <int> <dbl> <chr> <chr>   <chr>             <int> #> 1    11       1 16548 3046  3037    999                   1 #> 2    46       1 18004 3044  2922    2913                  1 #> 3    48       8 17706 3038  3048    3035                  1 #> 4     3       8 17897 3043  3030    <NA>                  1 #> 5    25      12 17652 304   3031    999                   1 #> 6    33      12 18411 3033  2924    999                   1 result3 <- result2 %>% restrict_date(   clnt_id = clnt_id,   date_var = dates,   n = 2,   within = 365,   uid = uid,   # here we use flag mode to flag records that met the restriction instead of removing those   mode = \"flag\" ) #>  #> Apply restriction that each client must have 2 records that were  within 365 days. Records that met the condition were flagged. result3 %>% head() #> # Source:     SQL [6 x 8] #> # Database:   sqlite 3.45.2 [:memory:] #> # Ordered by: dates, uid #>     uid clnt_id dates diagx diagx_1 diagx_2 flag_restrict_n flag_restrict_date #>   <int>   <int> <dbl> <chr> <chr>   <chr>             <int>              <int> #> 1    11       1 16548 3046  3037    999                   1                  0 #> 2    46       1 18004 3044  2922    2913                  1                  0 #> 3    48       8 17706 3038  3048    3035                  1                  1 #> 4     3       8 17897 3043  3030    <NA>                  1                  0 #> 5    25      12 17652 304   3031    999                   1                  0 #> 6    33      12 18411 3033  2924    999                   1                  0"},{"path":"https://kevinhzq.github.io/healthdb/reference/bind_source.html","id":null,"dir":"Reference","previous_headings":"","what":"Row-bind a list of data.frames or remote tables — bind_source","title":"Row-bind a list of data.frames or remote tables — bind_source","text":"Row-bind list data.frames remote tables","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/bind_source.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Row-bind a list of data.frames or remote tables — bind_source","text":"","code":"bind_source(data, ..., force_proceed = getOption(\"healthdb.force_proceed\"))"},{"path":"https://kevinhzq.github.io/healthdb/reference/bind_source.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Row-bind a list of data.frames or remote tables — bind_source","text":"data list data.frame remote tables, e.g., output execute_def(). ... Named arguments variable included output. argument name new name output, right hand side argument character vector original names. name vector list elements data matched position. output variable came sources, fill name vector length equal number sources NA, e.g., var come second three sources, var = c(NA, 'nm_in_src2', NA). force_proceed logical whether ask user input order proceed remote tables needed collected binding. default TRUE let user aware downloading process may slow. Use options(healthdb.force_proceed = FALSE) suppress prompt .","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/bind_source.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Row-bind a list of data.frames or remote tables — bind_source","text":"data.frame remote table containing combined rows input list variables specified ...","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/bind_source.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Row-bind a list of data.frames or remote tables — bind_source","text":"","code":"df1 <- subset(iris, Species == \"setosa\") df2 <- subset(iris, Species == \"versicolor\") df3 <- subset(iris, Species == \"virginica\")  bind_source(list(df1, df2, df3),   s_l = \"Sepal.Length\",   s_w = \"Sepal.Width\",   p_l_setosa = c(\"Petal.Length\", NA, NA),   p_l_virginica = c(NA, NA, \"Petal.Length\") ) #>     src_No s_l s_w p_l_setosa p_l_virginica #> 1        1 5.1 3.5        1.4            NA #> 2        1 4.9 3.0        1.4            NA #> 3        1 4.7 3.2        1.3            NA #> 4        1 4.6 3.1        1.5            NA #> 5        1 5.0 3.6        1.4            NA #> 6        1 5.4 3.9        1.7            NA #> 7        1 4.6 3.4        1.4            NA #> 8        1 5.0 3.4        1.5            NA #> 9        1 4.4 2.9        1.4            NA #> 10       1 4.9 3.1        1.5            NA #> 11       1 5.4 3.7        1.5            NA #> 12       1 4.8 3.4        1.6            NA #> 13       1 4.8 3.0        1.4            NA #> 14       1 4.3 3.0        1.1            NA #> 15       1 5.8 4.0        1.2            NA #> 16       1 5.7 4.4        1.5            NA #> 17       1 5.4 3.9        1.3            NA #> 18       1 5.7 3.8        1.7            NA #> 19       1 5.1 3.8        1.5            NA #> 20       1 5.4 3.4        1.7            NA #> 21       1 5.1 3.7        1.5            NA #> 22       1 4.6 3.6        1.0            NA #> 23       1 5.1 3.3        1.7            NA #> 24       1 4.8 3.4        1.9            NA #> 25       1 5.0 3.0        1.6            NA #> 26       1 5.0 3.4        1.6            NA #> 27       1 5.2 3.5        1.5            NA #> 28       1 5.2 3.4        1.4            NA #> 29       1 4.7 3.2        1.6            NA #> 30       1 4.8 3.1        1.6            NA #> 31       1 5.4 3.4        1.5            NA #> 32       1 5.2 4.1        1.5            NA #> 33       1 5.5 4.2        1.4            NA #> 34       1 5.0 3.2        1.2            NA #> 35       1 5.5 3.5        1.3            NA #> 36       1 4.9 3.6        1.4            NA #> 37       1 4.4 3.0        1.3            NA #> 38       1 5.1 3.4        1.5            NA #> 39       1 5.0 3.5        1.3            NA #> 40       1 4.5 2.3        1.3            NA #> 41       1 4.4 3.2        1.3            NA #> 42       1 5.0 3.5        1.6            NA #> 43       1 5.1 3.8        1.9            NA #> 44       1 5.1 3.8        1.6            NA #> 45       1 4.6 3.2        1.4            NA #> 46       1 5.3 3.7        1.5            NA #> 47       1 5.0 3.3        1.4            NA #> 48       2 7.0 3.2         NA            NA #> 49       2 6.4 3.2         NA            NA #> 50       2 6.9 3.1         NA            NA #> 51       2 5.5 2.3         NA            NA #> 52       2 6.5 2.8         NA            NA #> 53       2 5.7 2.8         NA            NA #> 54       2 6.3 3.3         NA            NA #> 55       2 4.9 2.4         NA            NA #> 56       2 6.6 2.9         NA            NA #> 57       2 5.2 2.7         NA            NA #> 58       2 5.0 2.0         NA            NA #> 59       2 5.9 3.0         NA            NA #> 60       2 6.0 2.2         NA            NA #> 61       2 6.1 2.9         NA            NA #> 62       2 5.6 2.9         NA            NA #> 63       2 6.7 3.1         NA            NA #> 64       2 5.6 3.0         NA            NA #> 65       2 5.8 2.7         NA            NA #> 66       2 6.2 2.2         NA            NA #> 67       2 5.6 2.5         NA            NA #> 68       2 5.9 3.2         NA            NA #> 69       2 6.1 2.8         NA            NA #> 70       2 6.3 2.5         NA            NA #> 71       2 6.4 2.9         NA            NA #> 72       2 6.6 3.0         NA            NA #> 73       2 6.8 2.8         NA            NA #> 74       2 6.7 3.0         NA            NA #> 75       2 6.0 2.9         NA            NA #> 76       2 5.7 2.6         NA            NA #> 77       2 5.5 2.4         NA            NA #> 78       2 6.0 2.7         NA            NA #> 79       2 5.4 3.0         NA            NA #> 80       2 6.0 3.4         NA            NA #> 81       2 6.3 2.3         NA            NA #> 82       2 5.5 2.5         NA            NA #> 83       2 5.5 2.6         NA            NA #> 84       2 6.1 3.0         NA            NA #> 85       2 5.8 2.6         NA            NA #> 86       2 5.0 2.3         NA            NA #> 87       2 5.6 2.7         NA            NA #> 88       2 5.7 3.0         NA            NA #> 89       2 5.7 2.9         NA            NA #> 90       2 6.2 2.9         NA            NA #> 91       2 5.1 2.5         NA            NA #> 92       3 6.3 3.3         NA           6.0 #> 93       3 5.8 2.7         NA           5.1 #> 94       3 7.1 3.0         NA           5.9 #> 95       3 6.3 2.9         NA           5.6 #> 96       3 6.5 3.0         NA           5.8 #> 97       3 7.6 3.0         NA           6.6 #> 98       3 4.9 2.5         NA           4.5 #> 99       3 7.3 2.9         NA           6.3 #> 100      3 6.7 2.5         NA           5.8 #> 101      3 7.2 3.6         NA           6.1 #> 102      3 6.5 3.2         NA           5.1 #> 103      3 6.4 2.7         NA           5.3 #> 104      3 6.8 3.0         NA           5.5 #> 105      3 5.7 2.5         NA           5.0 #> 106      3 5.8 2.8         NA           5.1 #> 107      3 6.4 3.2         NA           5.3 #> 108      3 6.5 3.0         NA           5.5 #> 109      3 7.7 3.8         NA           6.7 #> 110      3 7.7 2.6         NA           6.9 #> 111      3 6.0 2.2         NA           5.0 #> 112      3 6.9 3.2         NA           5.7 #> 113      3 5.6 2.8         NA           4.9 #> 114      3 7.7 2.8         NA           6.7 #> 115      3 6.3 2.7         NA           4.9 #> 116      3 6.7 3.3         NA           5.7 #> 117      3 7.2 3.2         NA           6.0 #> 118      3 6.2 2.8         NA           4.8 #> 119      3 6.1 3.0         NA           4.9 #> 120      3 6.4 2.8         NA           5.6 #> 121      3 7.2 3.0         NA           5.8 #> 122      3 7.4 2.8         NA           6.1 #> 123      3 7.9 3.8         NA           6.4 #> 124      3 6.3 2.8         NA           5.1 #> 125      3 6.1 2.6         NA           5.6 #> 126      3 7.7 3.0         NA           6.1 #> 127      3 6.3 3.4         NA           5.6 #> 128      3 6.4 3.1         NA           5.5 #> 129      3 6.0 3.0         NA           4.8 #> 130      3 6.9 3.1         NA           5.4 #> 131      3 6.7 3.1         NA           5.6 #> 132      3 6.9 3.1         NA           5.1 #> 133      3 6.8 3.2         NA           5.9 #> 134      3 6.7 3.0         NA           5.2 #> 135      3 6.3 2.5         NA           5.0 #> 136      3 6.5 3.0         NA           5.2 #> 137      3 6.2 3.4         NA           5.4 #> 138      3 5.9 3.0         NA           5.1"},{"path":"https://kevinhzq.github.io/healthdb/reference/build_def.html","id":null,"dir":"Reference","previous_headings":"","what":"Build case definition function calls — build_def","title":"Build case definition function calls — build_def","text":"function assembles function calls supplied functions required arguments, leaving data argument empty easy re-use definition calls different data batch execution (see execute_def() detail). useful defining multiple diseases/events across multiple sources.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/build_def.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build case definition function calls — build_def","text":"","code":"build_def(def_lab, src_labs, def_fn = define_case, fn_args)"},{"path":"https://kevinhzq.github.io/healthdb/reference/build_def.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build case definition function calls — build_def","text":"def_lab single character label definition, e.g., disease. src_labs character vector place-holder names data sources used execute definition. def_fn list functions (default: define_case()) filter source data sets keep clients met case definition. length list either 1 equal length src_labs. length = 1, function applied sources; otherwise, def_fn match src_lab position. User can supply custom functions must put input data first argument name data. fn_args named list arguments passing def_fn. element list name argument source-specific def_fn, element length also either 1 equal number sources. def_fn functions taking different sets arguments, include union one list.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/build_def.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build case definition function calls — build_def","text":"tibble number rows equal length src_labs, containing input arguments synthetic function call fn_call column.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/build_def.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build case definition function calls — build_def","text":"","code":"build_def(\"SUD\", # usually a disease name   src_lab = c(\"src1\", \"src2\"), # identify from multiple sources, e.g., hospitalization, ED visits.   # functions that filter the data with some criteria,   # including mean here for src2 as a trivial example   # to show only valid arguments will be in the call   def_fn = list(define_case, mean),   fn_args = list(     vars = list(starts_with(\"diagx\"), \"diagx_2\"),     match = \"start\", # \"start\" will be applied to all sources as length = 1     vals = list(c(\"304\"), c(\"305\")),     clnt_id = \"clnt_id\",     # c() can be used in place of list     # if this argument only takes one value for each source     n_per_clnt = c(2, 3),     x = list(1:10) # src2 with mean as def_fn will only accept this argument   ) ) #> # A tibble: 2 × 5 #>   def_lab src_labs def_fn      fn_args          fn_call      #>   <chr>   <chr>    <chr>       <named list>     <named list> #> 1 SUD     src1     define_case <named list [6]> <language>   #> 2 SUD     src2     mean        <named list [6]> <language>"},{"path":"https://kevinhzq.github.io/healthdb/reference/collapse_episode.html","id":null,"dir":"Reference","previous_headings":"","what":"Grouping records into episodes by date range — collapse_episode","title":"Grouping records into episodes by date range — collapse_episode","text":"function useful collapsing, e.g., medication dispensation hospitalization, records episodes records' dates n days gap apart. length gap can relaxed another grouping variable.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/collapse_episode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Grouping records into episodes by date range — collapse_episode","text":"","code":"collapse_episode(   data,   clnt_id,   start_dt,   end_dt = NULL,   gap,   overwrite = NULL,   gap_overwrite = Inf,   .dt_trans = data.table::as.IDate,   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/collapse_episode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Grouping records into episodes by date range — collapse_episode","text":"data data.frame contains id date variables. clnt_id Column name subject/person ID. start_dt Column name starting date records. end_dt Column name end date records. default NULL assuming record last one day start date used calculate gaps records. gap number days used separate episodes. inclusive upper bound + 1. example, gap = 8 means collapsing records 7 days apart. overwrite Column name grouping variable determining whether consecutive records related different gap value. example, dispensing records may original prescription number, different gap value can assigned situation, e.g., days two records > gap, records still belong prescription. gap_overwrite different gap value used related records. default Inf, means records overwrite variable collapsed. .dt_trans Function transform start_dt/end_dt. Default [data.table::.IDate()]. ... Additional arguments passing .dt_trans function.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/collapse_episode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Grouping records into episodes by date range — collapse_episode","text":"original data.frame new columns indicating episode grouping","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/collapse_episode.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Grouping records into episodes by date range — collapse_episode","text":"","code":"# make toy data df <- make_test_dat()  head(df) #>   uid clnt_id      dates diagx diagx_1 diagx_2 #> 1  68       2 2016-08-03   999     999     999 #> 2  11       2 2020-07-02   305    3055    <NA> #> 3  23       3 2019-07-08  3057    3056     999 #> 4  49       4 2017-10-23  3042    3058    3045 #> 5  89       4 2017-11-04   999     999     999 #> 6   9       5 2018-12-23  3053     304    <NA>  # collapse records no more than 90 days apart collapse_episode(df, clnt_id, dates, gap = 91) #>     uid clnt_id      dates diagx diagx_1 diagx_2 epi_id epi_no epi_seq #> 1    68       2 2016-08-03   999     999     999      1      1       1 #> 2    11       2 2020-07-02   305    3055    <NA>      2      2       1 #> 3    23       3 2019-07-08  3057    3056     999      3      1       1 #> 4    49       4 2017-10-23  3042    3058    3045      4      1       1 #> 5    89       4 2017-11-04   999     999     999      4      1       2 #> 6     9       5 2018-12-23  3053     304    <NA>      5      1       1 #> 7    18       6 2017-03-07  3046    3047    <NA>      6      1       1 #> 8    66       7 2019-07-17   999     999     999      7      1       1 #> 9    58       8 2017-06-08   999    <NA>    <NA>      8      1       1 #> 10   45       8 2018-02-22   304    3041    3056      9      2       1 #> 11   61       8 2020-10-26   999     999     999     10      3       1 #> 12   79       9 2019-05-03   999     999    <NA>     11      1       1 #> 13   85       9 2019-09-04   999    <NA>    <NA>     12      2       1 #> 14   95       9 2020-12-25   999    <NA>    <NA>     13      3       1 #> 15   15      10 2017-05-29   304    3042     999     14      1       1 #> 16   93      11 2015-08-25   999     999     999     15      1       1 #> 17    2      12 2016-01-25  3042    3056     999     16      1       1 #> 18   77      12 2018-04-22   999     999    <NA>     17      2       1 #> 19   54      12 2020-06-10   999     999     999     18      3       1 #> 20    3      13 2018-09-12  3050    3045    <NA>     19      1       1 #> 21   16      14 2015-12-29  3048     305    <NA>     20      1       1 #> 22   97      14 2020-04-30   999     999    <NA>     21      2       1 #> 23   70      14 2020-08-16   999     999     999     22      3       1 #> 24   17      15 2015-10-14  3040    <NA>    <NA>     23      1       1 #> 25   13      15 2017-07-23  3055    3041    <NA>     24      2       1 #> 26   12      15 2018-06-17  3049    3048     999     25      3       1 #> 27   83      16 2018-03-03   999    <NA>     999     26      1       1 #> 28   32      16 2020-05-17  3053    3052     999     27      2       1 #> 29   25      17 2017-01-29  3057    3052    <NA>     28      1       1 #> 30   44      17 2019-12-04  3059    3058     304     29      2       1 #> 31   22      18 2015-05-16  3057    3047    <NA>     30      1       1 #> 32   29      18 2017-03-06  3044    3044    <NA>     31      2       1 #> 33   20      18 2018-03-16  3054    3045     999     32      3       1 #> 34   43      18 2019-07-29  3058    3054    3047     33      4       1 #> 35   88      18 2019-12-29   999    <NA>     999     34      5       1 #> 36   10      19 2018-04-08  3051    3053     999     35      1       1 #> 37   59      19 2020-12-04   999     999    <NA>     36      2       1 #> 38   51      20 2016-01-20   999     999    <NA>     37      1       1 #> 39   31      20 2020-06-09  3058    3056    <NA>     38      2       1 #> 40   60      21 2015-01-19   999     999     999     39      1       1 #> 41   47      21 2016-12-05  3040    3046    3055     40      2       1 #> 42   41      21 2020-06-21   305    3058     305     41      3       1 #> 43   91      21 2020-11-16   999     999    <NA>     42      4       1 #> 44    5      22 2017-10-20  3050    3049     999     43      1       1 #> 45   71      23 2019-03-08   999     999    <NA>     44      1       1 #> 46   72      24 2019-10-10   999    <NA>     999     45      1       1 #> 47   35      24 2020-07-31   305    3047    <NA>     46      2       1 #> 48   84      28 2017-12-30   999    <NA>     999     47      1       1 #> 49   38      28 2018-01-15  3054    3048    <NA>     47      1       2 #> 50  100      29 2018-01-01   999    <NA>     999     48      1       1 #> 51   24      29 2019-11-24  3048    3050     999     49      2       1 #> 52    1      29 2020-12-17   305    3042    <NA>     50      3       1 #> 53   78      30 2015-11-19   999    <NA>     999     51      1       1 #> 54   50      30 2016-04-25  3042    3055    3045     52      2       1 #> 55   96      30 2017-11-14   999    <NA>    <NA>     53      3       1 #> 56    7      30 2019-11-05   305    3047    <NA>     54      4       1 #> 57   63      31 2016-03-24   999    <NA>    <NA>     55      1       1 #> 58   69      31 2016-04-09   999     999    <NA>     55      1       2 #> 59   52      31 2016-09-23   999    <NA>    <NA>     56      2       1 #> 60   75      31 2017-11-26   999    <NA>     999     57      3       1 #> 61   36      32 2020-10-14  3054     304     999     58      1       1 #> 62   94      33 2016-03-01   999    <NA>     999     59      1       1 #> 63   28      33 2016-07-24  3041    3053    <NA>     60      2       1 #> 64    8      33 2019-12-14  3048    3057    <NA>     61      3       1 #> 65   33      35 2017-09-26  3057    3058     999     62      1       1 #> 66   62      35 2018-08-14   999    <NA>    <NA>     63      2       1 #> 67   99      36 2015-12-02   999     999    <NA>     64      1       1 #> 68   80      36 2016-04-22   999     999    <NA>     65      2       1 #> 69   14      36 2018-08-13  3058    3052    <NA>     66      3       1 #> 70   55      36 2019-12-10   999     999     999     67      4       1 #> 71   82      38 2016-11-29   999     999    <NA>     68      1       1 #> 72   57      38 2017-01-25   999     999    <NA>     68      1       2 #> 73   46      39 2017-06-24   305    3053     304     69      1       1 #> 74   81      39 2017-09-23   999     999     999     69      1       2 #> 75    6      39 2018-11-27  3046    3052     999     70      2       1 #> 76   74      39 2020-02-05   999    <NA>    <NA>     71      3       1 #> 77   87      40 2020-07-14   999    <NA>    <NA>     72      1       1 #> 78   19      41 2018-01-14  3051    3055    <NA>     73      1       1 #> 79   64      42 2016-05-21   999     999     999     74      1       1 #> 80   65      42 2018-06-27   999     999     999     75      2       1 #> 81    4      43 2016-01-24  3054    3051     999     76      1       1 #> 82   37      43 2016-07-03  3059    3055     999     77      2       1 #> 83   40      43 2018-11-13   304     304     999     78      3       1 #> 84   21      44 2016-10-18  3053     305     999     79      1       1 #> 85   67      44 2017-04-21   999     999     999     80      2       1 #> 86   56      44 2019-07-17   999    <NA>     999     81      3       1 #> 87   53      45 2015-10-02   999    <NA>    <NA>     82      1       1 #> 88   26      45 2018-08-08  3057    3040    <NA>     83      2       1 #> 89   34      45 2019-07-31  3040    3054     999     84      3       1 #> 90   48      45 2019-08-20  3050    3059     304     84      3       2 #> 91   27      46 2020-02-23  3047    3050     999     85      1       1 #> 92   76      47 2015-11-05   999     999     999     86      1       1 #> 93   30      47 2018-02-21  3057    3045    <NA>     87      2       1 #> 94   42      48 2017-03-21  3048     305    3050     88      1       1 #> 95   73      48 2019-03-09   999    <NA>    <NA>     89      2       1 #> 96   39      48 2019-08-28  3040    3053    <NA>     90      3       1 #> 97   90      49 2015-08-26   999    <NA>    <NA>     91      1       1 #> 98   98      49 2015-09-03   999     999    <NA>     91      1       2 #> 99   86      49 2020-08-17   999     999     999     92      2       1 #> 100  92      50 2019-07-24   999    <NA>     999     93      1       1 #>     epi_start_dt epi_stop_dt #> 1     2016-08-03  2016-08-03 #> 2     2020-07-02  2020-07-02 #> 3     2019-07-08  2019-07-08 #> 4     2017-10-23  2017-11-04 #> 5     2017-10-23  2017-11-04 #> 6     2018-12-23  2018-12-23 #> 7     2017-03-07  2017-03-07 #> 8     2019-07-17  2019-07-17 #> 9     2017-06-08  2017-06-08 #> 10    2018-02-22  2018-02-22 #> 11    2020-10-26  2020-10-26 #> 12    2019-05-03  2019-05-03 #> 13    2019-09-04  2019-09-04 #> 14    2020-12-25  2020-12-25 #> 15    2017-05-29  2017-05-29 #> 16    2015-08-25  2015-08-25 #> 17    2016-01-25  2016-01-25 #> 18    2018-04-22  2018-04-22 #> 19    2020-06-10  2020-06-10 #> 20    2018-09-12  2018-09-12 #> 21    2015-12-29  2015-12-29 #> 22    2020-04-30  2020-04-30 #> 23    2020-08-16  2020-08-16 #> 24    2015-10-14  2015-10-14 #> 25    2017-07-23  2017-07-23 #> 26    2018-06-17  2018-06-17 #> 27    2018-03-03  2018-03-03 #> 28    2020-05-17  2020-05-17 #> 29    2017-01-29  2017-01-29 #> 30    2019-12-04  2019-12-04 #> 31    2015-05-16  2015-05-16 #> 32    2017-03-06  2017-03-06 #> 33    2018-03-16  2018-03-16 #> 34    2019-07-29  2019-07-29 #> 35    2019-12-29  2019-12-29 #> 36    2018-04-08  2018-04-08 #> 37    2020-12-04  2020-12-04 #> 38    2016-01-20  2016-01-20 #> 39    2020-06-09  2020-06-09 #> 40    2015-01-19  2015-01-19 #> 41    2016-12-05  2016-12-05 #> 42    2020-06-21  2020-06-21 #> 43    2020-11-16  2020-11-16 #> 44    2017-10-20  2017-10-20 #> 45    2019-03-08  2019-03-08 #> 46    2019-10-10  2019-10-10 #> 47    2020-07-31  2020-07-31 #> 48    2017-12-30  2018-01-15 #> 49    2017-12-30  2018-01-15 #> 50    2018-01-01  2018-01-01 #> 51    2019-11-24  2019-11-24 #> 52    2020-12-17  2020-12-17 #> 53    2015-11-19  2015-11-19 #> 54    2016-04-25  2016-04-25 #> 55    2017-11-14  2017-11-14 #> 56    2019-11-05  2019-11-05 #> 57    2016-03-24  2016-04-09 #> 58    2016-03-24  2016-04-09 #> 59    2016-09-23  2016-09-23 #> 60    2017-11-26  2017-11-26 #> 61    2020-10-14  2020-10-14 #> 62    2016-03-01  2016-03-01 #> 63    2016-07-24  2016-07-24 #> 64    2019-12-14  2019-12-14 #> 65    2017-09-26  2017-09-26 #> 66    2018-08-14  2018-08-14 #> 67    2015-12-02  2015-12-02 #> 68    2016-04-22  2016-04-22 #> 69    2018-08-13  2018-08-13 #> 70    2019-12-10  2019-12-10 #> 71    2016-11-29  2017-01-25 #> 72    2016-11-29  2017-01-25 #> 73    2017-06-24  2017-09-23 #> 74    2017-06-24  2017-09-23 #> 75    2018-11-27  2018-11-27 #> 76    2020-02-05  2020-02-05 #> 77    2020-07-14  2020-07-14 #> 78    2018-01-14  2018-01-14 #> 79    2016-05-21  2016-05-21 #> 80    2018-06-27  2018-06-27 #> 81    2016-01-24  2016-01-24 #> 82    2016-07-03  2016-07-03 #> 83    2018-11-13  2018-11-13 #> 84    2016-10-18  2016-10-18 #> 85    2017-04-21  2017-04-21 #> 86    2019-07-17  2019-07-17 #> 87    2015-10-02  2015-10-02 #> 88    2018-08-08  2018-08-08 #> 89    2019-07-31  2019-08-20 #> 90    2019-07-31  2019-08-20 #> 91    2020-02-23  2020-02-23 #> 92    2015-11-05  2015-11-05 #> 93    2018-02-21  2018-02-21 #> 94    2017-03-21  2017-03-21 #> 95    2019-03-09  2019-03-09 #> 96    2019-08-28  2019-08-28 #> 97    2015-08-26  2015-09-03 #> 98    2015-08-26  2015-09-03 #> 99    2020-08-17  2020-08-17 #> 100   2019-07-24  2019-07-24"},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Elixhauser Comorbidity Index — compute_comorbidity","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"function computes unweighted Elixhauser Comorbidity Index data.frame remote table input. ICD codes used identify 31 disease categories Quan et al. (2005).","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"","code":"compute_comorbidity(   data,   vars,   icd_ver = c(\"ICD-10\", \"ICD-9-CM-3digits\", \"ICD-9-CM-5digits\"),   clnt_id,   uid = NULL,   sum_by = c(\"row\", \"clnt\"),   excl = NULL )"},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"data Data.frames remote tables (e.g., dbplyr::tbl_sql()) vars expression passing dplyr::select(). can quoted/unquoted column names, helper functions, dplyr::starts_with(). icd_ver One c(\"ICD-10\", \"ICD-9-CM-3digits\", \"ICD-9-CM-5digits\"). Specify ICD code version used data. ICD-10 ICD-9-CM 5 digits version Quan et al. (2005). ICD-9-CM 3 digits version adopted Manitoba Centre Health Policy. uses 3-digit 5-digit codes search. See web page cautions limitations 3 digit version data 3-digit codes (http://mchp-appserv.cpe.umanitoba.ca/viewConcept.php?printer=Y&conceptID=1436#CAUTIONS). clnt_id Grouping variable (quoted/unquoted). uid Variable name unique row identifier. necessary SQL produce consistent result based sorting. sum_by One \"row\" \"clnt\". \"row\" option computes total score row (default), \"clnt\" option summarizes total score clnt_id. disease categories counted calculation regardless multiple records category. excl character vector disease categories labels excluded total score calculation. useful categories exposure/outcome interest, goal measure comorbidity excluding disease. See detail list categories labels.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"data.frame remote table binary indicators categories columns.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"List disease categories - labels (quote): Congestive Heart Failure - \"chf\" Cardiac Arrhythmia - \"arrhy\" Valvular Disease - \"vd\" Pulmonary Circulation Disorders - \"pcd\" Peripheral Vascular Disorders - \"pvd\" Hypertension Uncomplicated - \"hptn_nc\" Hypertension complicated - \"hptn_C\" Paralysis - \"para\" Neurological Disorders - \"Othnd\" Chronic Pulmonary Disease - \"copd\" Diabetes Uncomplicated - \"diab_nc\" Diabetes Complicated - \"diab_c\" Hypothyroidism - \"hptothy\" Renal Failure - \"rf\" Liver Disease - \"ld\" Peptic Ulcer Disease excluding bleeding - \"pud_nb\" AIDS/HIV - \"hiv\" Lymphoma - \"lymp\" Metastatic Cancer - \"mets\" Solid Tumor without Metastasis - \"tumor\" Rheumatoid Arthritis/collagen - \"rheum_a\" Coagulopathy - \"coag\" Obesity - \"obesity\" Weight Loss - \"wl\" Fluid Electrolyte Disorders - \"fluid\" Blood Loss Anemia - \"bla\" Deficiency Anemia - \"da\" Alcohol Abuse - \"alcohol\" Drug Abuse - \"drug\" Psychoses - \"psycho\" Depression - \"dep\"","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"Quan H, Sundararajan V, Halfon P, Fong , Burnand B, Luthi JC, Saunders LD, Beck CA, Feasby TE, Ghali WA. Coding algorithms defining comorbidities ICD-9-CM ICD-10 administrative data. Med Care 2005;43(11):1130-1139.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"","code":"# make ICD-9 toy data df <- data.frame(   uid = 1:10, clnt_id = sample(1:3, 10, replace = TRUE),   diagx_1 = c(\"193\", \"2780\", \"396\", \"4254\", \"4150\", \"401\", \"401\", \"0932\", \"5329\", \"2536\"),   diagx_2 = c(NA, NA, \"72930\", \"V6542\", \"493\", \"405\", \"5880\", \"2409\", \"714\", NA) )  # compute Elixhauser Comorbidity Index by row # uid is needed for by row calculation # 3 categories were excluded in total_eci compute_comorbidity(df,   vars = starts_with(\"diagx\"),   icd_ver = \"ICD-9-CM-5digits\",   clnt_id = clnt_id, uid = uid,   excl = c(\"drug\", \"psycho\", \"dep\") ) #> # A tibble: 10 × 34 #>    clnt_id   uid   chf arrhy    vd   pcd   pvd hptn_nc hptn_c  para othnd  copd #>      <int> <int> <dbl> <dbl> <dbl> <dbl> <dbl>   <dbl>  <dbl> <dbl> <dbl> <dbl> #>  1       1     1     0     0     0     0     0       0      0     0     0     0 #>  2       1     2     0     0     0     0     0       0      0     0     0     0 #>  3       1     4     1     0     0     0     0       0      0     0     0     0 #>  4       1     7     0     0     0     0     0       1      0     0     0     0 #>  5       1    10     0     0     0     0     0       0      0     0     0     0 #>  6       2     8     0     0     1     0     0       0      0     0     0     0 #>  7       3     3     0     0     1     0     0       0      0     0     0     0 #>  8       3     5     0     0     0     1     0       0      0     0     0     1 #>  9       3     6     0     0     0     0     0       1      1     0     0     0 #> 10       3     9     0     0     0     0     0       0      0     0     0     0 #> # ℹ 22 more variables: diab_nc <dbl>, diab_c <dbl>, hptothy <dbl>, rf <dbl>, #> #   ld <dbl>, pud_nb <dbl>, hiv <dbl>, lymp <dbl>, mets <dbl>, tumor <dbl>, #> #   rheum_a <dbl>, coag <dbl>, obesity <dbl>, wl <dbl>, fluid <dbl>, bla <dbl>, #> #   da <dbl>, alcohol <dbl>, drug <dbl>, psycho <dbl>, dep <dbl>, #> #   total_eci <dbl>  # compute ECI by person compute_comorbidity(df,   vars = starts_with(\"diagx\"),   icd_ver = \"ICD-9-CM-5digits\",   clnt_id = clnt_id,   sum_by = \"clnt\" ) #> # A tibble: 3 × 33 #>   clnt_id   chf arrhy    vd   pcd   pvd hptn_nc hptn_c  para othnd  copd diab_nc #>     <int> <dbl> <dbl> <dbl> <dbl> <dbl>   <dbl>  <dbl> <dbl> <dbl> <dbl>   <dbl> #> 1       1     1     0     0     0     0       1      0     0     0     0       0 #> 2       2     0     0     1     0     0       0      0     0     0     0       0 #> 3       3     0     0     1     1     0       1      1     0     0     1       0 #> # ℹ 21 more variables: diab_c <dbl>, hptothy <dbl>, rf <dbl>, ld <dbl>, #> #   pud_nb <dbl>, hiv <dbl>, lymp <dbl>, mets <dbl>, tumor <dbl>, #> #   rheum_a <dbl>, coag <dbl>, obesity <dbl>, wl <dbl>, fluid <dbl>, bla <dbl>, #> #   da <dbl>, alcohol <dbl>, drug <dbl>, psycho <dbl>, dep <dbl>, #> #   total_eci <dbl>"},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_duration.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute duration between two dates — compute_duration","title":"Compute duration between two dates — compute_duration","text":"function meant data frame input used dplyr::mutate() compute age duration two character Date columns. vector breaks given, output converted factor labels generated automatically.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_duration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute duration between two dates — compute_duration","text":"","code":"compute_duration(   from,   to,   lower_brks = NULL,   unit = c(\"year\", \"day\", \"week\", \"month\"),   trans = FALSE,   .transfn = lubridate::ymd,   verbose = getOption(\"healthdb.verbose\"),   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_duration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute duration between two dates — compute_duration","text":"character Date vector start dates. character Date vector end dates. lower_brks numeric vector lower breaks passing base base::cut() function convert numeric result factor. level labels auto generated. example, level labels c(\"<19\", \"19-24\", \"25-34\", \"35-44\", \"45-54\", \"55+\") lower_brks = c(0, 19, 25, 35, 45, 55). Default NULL (conversion). unit character string specifying unit output. One \"year\" (default), \"day\", \"week\", \"month\". trans logical whether transform .transfn function .transfn function transforming inputs. Default lubridate::ymd(). verbose logical whether print summary warning missing values. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . ... Additional arguments passing base::cut().","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_duration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute duration between two dates — compute_duration","text":"numeric factor vector duration.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_duration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute duration between two dates — compute_duration","text":"","code":"# toy data n <- 5 df <- data.frame(id = 1:n, start_dt = sample(seq(as.Date(\"1970-01-01\"), as.Date(\"2000-12-31\"), by = 1), size = n), end_dt = sample(seq(as.Date(\"2001-01-01\"), as.Date(\"2023-12-31\"), by = 1), size = n))  # get age group at a cut-off df %>% dplyr::mutate(  age_grp = compute_duration(start_dt, \"2023-01-01\", lower_brks = c(0, 19, 25, 35, 45, 55)) ) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   29.97   34.15   42.98   41.72   50.48   50.99  #>   <19 19-24 25-34 35-44 45-54   55+  #>     0     0     2     1     2     0  #>   id   start_dt     end_dt age_grp #> 1  1 1988-11-08 2003-10-22   25-34 #> 2  2 1980-01-07 2012-07-27   35-44 #> 3  3 1993-01-10 2012-07-30   25-34 #> 4  4 1972-07-09 2023-06-03   45-54 #> 5  5 1972-01-04 2008-08-23   45-54  # compute gaps between two dates in weeks df %>% dplyr::mutate(  gap_wks = compute_duration(start_dt, end_dt, unit = \"week\") ) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   780.1  1020.1  1698.6  1613.3  1911.6  2655.9  #>   id   start_dt     end_dt   gap_wks #> 1  1 1988-11-08 2003-10-22  780.1429 #> 2  2 1980-01-07 2012-07-27 1698.5714 #> 3  3 1993-01-10 2012-07-30 1020.1429 #> 4  4 1972-07-09 2023-06-03 2655.8571 #> 5  5 1972-01-04 2008-08-23 1911.5714"},{"path":"https://kevinhzq.github.io/healthdb/reference/cut_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut the time period in one row into multiple rows by interval — cut_period","title":"Cut the time period in one row into multiple rows by interval — cut_period","text":"function cutting time periods segments, useful subsequent overlap joins. original period (per row) expanded multiple rows weeks, months, etc. data.frame input accepted output size greater input. Thus, remote tables collected running function optimal performance.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/cut_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut the time period in one row into multiple rows by interval — cut_period","text":"","code":"cut_period(   data,   start,   end,   len,   unit = c(\"day\", \"week\", \"month\", \"quarter\", \"year\"),   .dt_trans = NULL )"},{"path":"https://kevinhzq.github.io/healthdb/reference/cut_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut the time period in one row into multiple rows by interval — cut_period","text":"data Input data.frame row start end dates start Record start date column (unquoted) end Record end date column (unquoted) len integer, interval used divide record duration unit One \"day\" (default), \"week\", \"month\", \"quarter, \"year\" used combination len specify time length interval. .dt_trans Function transform start/end, lubridate::ymd(). Default NULL.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/cut_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut the time period in one row into multiple rows by interval — cut_period","text":"Data frame row now segment period defined c(start, end) original row. Original variables retained repeated segment plus new variables defining segment interval.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/cut_period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut the time period in one row into multiple rows by interval — cut_period","text":"","code":"# toy data df <- data.frame(sample_id = 1, period_id = 1, start_date = \"2015-01-01\", end_date = \"2019-12-31\")  # divide period into segments (multiple rows per period) df_seg <- cut_period(   data = df, start = start_date, end = end_date,   len = 30, .dt_trans = lubridate::ymd )  # categorize segment_id as factor df_seg$segment <- cut(df_seg$segment_id,   breaks = c(0, 1, 2, Inf),   labels = c(\"< 1 month\", \"1 - 2 months\", \"Remainder\") )"},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify diseases/events from administrative records — define_case","title":"Identify diseases/events from administrative records — define_case","text":"function composite identify_row(), exclude(), restrict_n(), restrict_date(). aimed implement common case definitions epidemiological studies using administrative database one-shot big query. intended use case definitions form , e.g., two physician visits diagnostic code least 30 days apart within two years. component functions mentioned chained following order arguments supplied: identify_row(vals) %>% exclude(identify_row(excl_vals), = clnt_id) %>% restrict_n() %>% restrict_date(). necessary steps chain ran arguments missing, see verbose output done. Note date_var supplied, n_per_clnt counted distinct dates instead number records.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify diseases/events from administrative records — define_case","text":"","code":"define_case(   data,   vars,   match = \"in\",   vals,   clnt_id,   n_per_clnt = 1,   date_var = NULL,   apart = NULL,   within = NULL,   uid = NULL,   excl_vals = NULL,   excl_args = NULL,   keep = c(\"all\", \"first\", \"last\"),   if_all = FALSE,   mode = c(\"flag\", \"filter\"),   force_collect = FALSE,   verbose = getOption(\"healthdb.verbose\"),   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify diseases/events from administrative records — define_case","text":"data Data.frames remote tables (e.g., dbplyr::tbl_sql()) vars expression passing dplyr::select(). can quoted/unquoted column names, helper functions, dplyr::starts_with(). match One \"\", \"start\", \"regex\", \"like\", \"\", \"glue_sql\". determines values matched. See identify_row() detail. vals Depending match, takes different input. See identify_row(). clnt_id Grouping variable (quoted/unquoted). n_per_clnt single number specifying minimum number group size. date_var Variable name (quoted/unquoted) dates interpreted. apart integer specifying minimum gap (days) adjacent dates draw. option implemented data.frame input. within integer specifying maximum time span (days) draw. uid Variable name unique row identifier. necessary SQL produce consistent result based sorting. excl_vals vals clients/groups values going removed result. intended exclusion criteria case definition. excl_args named list arguments passing second identify_row() call excl_vals. supplied, var, match if_all first call re-used. keep One : \"first\" (keeping client's earliest record), \"last\" (keeping latest), \"\" (keeping relevant records, default). Note \"first\"/\"last\" used \"flag\" mode. if_all logical whether combining predicates (multiple columns selected vars) instead . Default FALSE, e.g., var1 vals var2 vals. mode Either: \"flag\" - add new columns starting \"flag_\" indicating client met condition, \"filter\" - remove clients meet condition data. passed restrict_n() restrict_date(). Default \"flag\". force_collect logical whether force downloading result table local data.frame. Downloading data slow, user opt ; default FALSE. verbose logical whether printing explanation operation. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . ... Additional arguments, e.g., mode, passing restrict_date().","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify diseases/events from administrative records — define_case","text":"subset input data satisfied specified case definition.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify diseases/events from administrative records — define_case","text":"","code":"sample_size <- 30 df <- data.frame(   clnt_id = rep(1:3, each = 10),   service_dt = sample(seq(as.Date(\"2020-01-01\"), as.Date(\"2020-01-31\"), by = 1),     size = sample_size, replace = TRUE   ),   diagx = sample(letters, size = sample_size, replace = TRUE),   diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),   diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE) )  # define from one source define_case(df,   vars = starts_with(\"diagx\"), \"in\", vals = letters[1:4],   clnt_id = clnt_id, date_var = service_dt,   excl_args = list(if_all = TRUE),   # remove non-case   mode = \"filter\",   # keeping the first record   keep = \"first\" ) #>  #> --------------Inclusion step-------------- #>  #> Identify records with condition(s):  #>  - where at least one of the diagx, diagx_1, diagx_2 column(s) in each record  #>    - contains a value exactly matched values in set: letters[1:4]  #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other columns):  #>    a    b    c    d    e    f    g    i    l    n    p    q    s    t    u    v  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #>    w NA's  #>    1    1  #>  #> -------------- Output first records-------------- #> # A tibble: 3 × 5 #>   clnt_id service_dt diagx diagx_1 diagx_2 #>     <int> <date>     <chr> <chr>   <chr>   #> 1       1 2020-01-02 w     b       e       #> 2       2 2020-01-12 t     e       d       #> 3       3 2020-01-18 p     q       a        # multiple sources with purrr::pmap # arguments with length = 1 will be recycle to match the number of sources # wrap expressions/unquoted variables with bquote(), # or rlang:exprs() to prevent immediate evaluation, # or just use quoted variable names purrr::pmap(   list(     data = list(df, df),     vars = rlang::exprs(starts_with(\"diagx\")),     match = c(\"in\", \"start\"),     vals = list(letters[1:4], letters[5:10]),     clnt_id = list(bquote(clnt_id)), n_per_clnt = c(2, 3),     date_var = \"service_dt\",     excl_vals = list(letters[11:13], letters[14:16]),     excl_args = list(list(if_all = TRUE), list(if_all = FALSE))   ),   define_case ) #>  #> --------------Inclusion step-------------- #>  #> Identify records with condition(s):  #>  - where at least one of the diagx, diagx_1, diagx_2 column(s) in each record  #>    - contains a value exactly matched values in set: c(\"a\", \"b\", \"c\", \"d\")  #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other columns):  #>    a    b    c    d    e    f    g    i    l    n    p    q    s    t    u    v  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #>    w NA's  #>    1    1  #>  #> --------------Exclusion step-------------- #>  #> Identify records with condition(s):  #>  - where all of the diagx, diagx_1, diagx_2 column(s) in each record  #>    - contains a value exactly matched values in set: c(\"k\", \"l\", \"m\")  #>  #> All unique value(s) and frequency in the result :  #> integer(0) #>  #> Exclude records in `data` through anti_join with `excl` matching on (by argument): \"clnt_id\"  #>  #> Of the 3 \"clnt_id\" in data, 0 were excluded. #>  #> --------------No. rows restriction-------------- #>  #> Of the 3 clients in the input, 0 were flagged as 0 by restricting that each client must have at least 2 records with distinct service_dt  #>  #> -------------- Output all records-------------- #>  #> --------------Inclusion step-------------- #>  #> Identify records with condition(s):  #>  - where at least one of the diagx, diagx_1, diagx_2 column(s) in each record  #>    - contains a value satisfied regular expression: ^e|^f|^g|^h|^i|^j  #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other columns):  #>    b    d    e    f    g    h    i    j    l    m    n    o    p    q    r    s  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #>    t    v    w    x    y    z NA's  #>    1    1    1    1    1    1    1  #>  #> --------------Exclusion step-------------- #>  #> Identify records with condition(s):  #>  - where at least one of the diagx, diagx_1, diagx_2 column(s) in each record  #>    - contains a value satisfied regular expression: ^n|^o|^p  #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other columns):  #> a f h i j l m n o p q s t y  #> 1 1 1 1 1 1 1 1 1 1 1 1 1 1  #>  #> Exclude records in `data` through anti_join with `excl` matching on (by argument): \"clnt_id\"  #>  #> Of the 3 \"clnt_id\" in data, 3 were excluded. #>  #> --------------No. rows restriction-------------- #>  #> Of the 0 clients in the input, 0 were flagged as 0 by restricting that each client must have at least 3 records with distinct service_dt  #>  #> -------------- Output all records-------------- #> [[1]] #>   clnt_id service_dt diagx diagx_1 diagx_2 flag_restrict_n #> 1       1 2020-01-27     v       a       u               1 #> 2       1 2020-01-13     a       l       n               1 #> 3       1 2020-01-18     b       i    <NA>               1 #> 4       1 2020-01-02     w       b       e               1 #> 5       2 2020-01-12     t       e       d               1 #> 6       2 2020-01-16     b       c       s               1 #> 7       3 2020-01-22     f       b       g               1 #> 8       3 2020-01-18     p       q       a               1 #>  #> [[2]] #> [1] clnt_id         service_dt      diagx           diagx_1         #> [5] diagx_2         flag_restrict_n #> <0 rows> (or 0-length row.names) #>"},{"path":"https://kevinhzq.github.io/healthdb/reference/exclude.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove rows based on conditions or another data set — exclude","title":"Remove rows based on conditions or another data set — exclude","text":"function combines dplyr::anti_join(), negation dplyr::filter(). second data set supplied excl argument, anti join performed; otherwise, data filtered expression given via condition argument, filter result turn removed using dplyr::setdiff().","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/exclude.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove rows based on conditions or another data set — exclude","text":"","code":"exclude(   data,   excl = NULL,   by = NULL,   condition = NULL,   verbose = getOption(\"healthdb.verbose\"),   report_on = NULL,   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/exclude.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove rows based on conditions or another data set — exclude","text":"data Data.frames remote tables (e.g., dbplyr::tbl_sql()). subset removed data. excl Data frames remote tables (e.g., 'dbplyr'). Rows/values present removed data match. passed dplyr::anti_join() second argument. Column names matched dplyr::anti_join(), expressions dplyr::join_by(). See dplyr::anti_join()'s argument detail. Default NULL setdiff(data, excl). condition expression passed dplyr::filter(). rows satisfy condition removed data. verbose logical whether printing explanation operation. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . report_on quoted/unquoted column name counting many distinct values removed data, e.g., counting many client IDs removed. Default NULL. ... Additional arguments passing dplyr::filter()/dplyr::anti_join() finer control matching, e.g., na action, -group filtering, etc.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/exclude.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove rows based on conditions or another data set — exclude","text":"data frame remote table subset data.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/exclude.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove rows based on conditions or another data set — exclude","text":"","code":"# exclude with condition cyl4 <- exclude(mtcars, condition = cyl == 4, report_on = cyl) #>  #> Exclude a subset of `data` that satisfies condition: cyl == 4  #> Consider being explicit about NA, e.g., condition = var == 'val' | is.na(var) #>  #> Of the 3 cyl in data, 1 were excluded.  # exclude with another data exclude(mtcars, cyl4, dplyr::join_by(cyl), report_on = cyl) #>  #> Exclude records in `data` through anti_join with `excl` matching on (by argument): dplyr::join_by(cyl)  #>  #> Of the 3 cyl in data, 2 were excluded. #>                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb #> Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1 #> Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2 #> Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2 #> Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1 #> Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2 #> Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1 #> Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1 #> Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1 #> Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2 #> Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2 #> Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2"},{"path":"https://kevinhzq.github.io/healthdb/reference/execute_def.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute parameterized case definitions — execute_def","title":"Execute parameterized case definitions — execute_def","text":"function executes function calls stored output tibble [build_def()] data objects supplied named list returns results list. intended facilitate re-use pre-defined calls different data.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/execute_def.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute parameterized case definitions — execute_def","text":"","code":"execute_def(   def,   with_data,   bind = FALSE,   force_proceed = getOption(\"healthdb.force_proceed\") )"},{"path":"https://kevinhzq.github.io/healthdb/reference/execute_def.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Execute parameterized case definitions — execute_def","text":"def tibble created [build_def()]. with_data named list elements form src_lab = data, 'src_lab' corresponds src_labs argument [build_def()] 'data' data object passed calls stored def. names (length) `with_data` must match unique values src_labs `def`. bind logical whether row-binding records multiple sources one table. Note binding may fail ways difficult anticipate advance, data type conflict (e.g., Date vs. character) variables name different sources. default FALSE. TRUE, behavior try return unbinded result failed. force_proceed logical whether ask user input order proceed remote tables needed collected binding. default TRUE let user aware downloading process may slow. Use options(healthdb.force_proceed = FALSE) suppress prompt .","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/execute_def.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Execute parameterized case definitions — execute_def","text":"single (bind = TRUE) list data.frames remote tables.","code":""},{"path":[]},{"path":"https://kevinhzq.github.io/healthdb/reference/execute_def.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Execute parameterized case definitions — execute_def","text":"","code":"# toy data sample_size <- 30 df <- data.frame(   clnt_id = rep(1:3, each = 10),   service_dt = sample(seq(as.Date(\"2020-01-01\"), as.Date(\"2020-01-31\"), by = 1),     size = sample_size, replace = TRUE   ),   diagx = sample(letters, size = sample_size, replace = TRUE),   diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),   diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE) )  # make df a database table db <- dbplyr::tbl_memdb(df)  # use build_def to make a toy definition sud_def <- build_def(\"SUD\", # usually a disease name   src_lab = c(\"src1\", \"src2\"), # identify from multiple sources, e.g., hospitalization, ED visits.   # functions that filter the data with some criteria   def_fn = define_case,   fn_args = list(     vars = starts_with(\"diagx\"),     match = \"start\", # \"start\" will be applied to all sources as length = 1     vals = list(c(\"304\"), c(\"305\")),     clnt_id = \"clnt_id\", # list()/c() could be omitted for single element     # c() can be used in place of list     # if this argument only takes one value for each source     n_per_clnt = c(2, 3)   ) )  # save the definition for re-use # saveRDS(sud_def, file = some_path)  sud_def %>% execute_def(with_data = list(src1 = df, src2 = db), force_proceed = TRUE) #>  #> Processing source: df #> --------------Inclusion step-------------- #>  #> Identify records with condition(s):  #>  - where at least one of the diagx, diagx_1, diagx_2 column(s) in each record  #>    - contains a value satisfied regular expression: ^304  #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other columns):  #> integer(0) #>  #> --------------No. rows restriction-------------- #>  #> Of the 0 clients in the input, 0 were flagged as 0 by restricting that each client must have at least 2 records   #>  #> -------------- Output all records-------------- #>  #> Processing source: db #> --------------Inclusion step-------------- #>  #> Identify records with condition(s):  #>  - where at least one of the diagx, diagx_1, diagx_2 column(s) in each record  #>    - contains a value satisfied SQL LIKE pattern: 305%  #>  #> To see the final query generated by 'dbplyr', use dplyr::show_query() on the output.  #> To extract the SQL string, use dbplyr::remote_query(). #>  #> --------------No. rows restriction-------------- #>  #> Apply restriction that each client must have at least 3 records. Clients/groups whichmetthe condition were flagged.  #>  #> -------------- Output all records-------------- #> [[1]] #> [1] def             src             clnt_id         service_dt      #> [5] diagx           diagx_1         diagx_2         flag_restrict_n #> <0 rows> (or 0-length row.names) #>  #> [[2]] #> # Source:   SQL [0 x 8] #> # Database: sqlite 3.45.2 [:memory:] #> # ℹ 8 variables: def <lgl>, src <lgl>, clnt_id <int>, service_dt <dbl>, #> #   diagx <chr>, diagx_1 <chr>, diagx_2 <chr>, flag_restrict_n <lgl> #>"},{"path":"https://kevinhzq.github.io/healthdb/reference/fetch_var.html","id":null,"dir":"Reference","previous_headings":"","what":"Get variables from multiple tables with common ID columns — fetch_var","title":"Get variables from multiple tables with common ID columns — fetch_var","text":"function fetches variables different tables linked common IDs. calls dplyr::left_join() multiple times different source tables (y argument join) gather variables. meant replace left_join() simplify syntax situation started table study sample wanted gather covariates different sources linked common client IDs, often case working healthcare databases. said, function replace repetitions simple joins allows one--one matching.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/fetch_var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get variables from multiple tables with common ID columns — fetch_var","text":"","code":"fetch_var(data, keys, linkage, verbose = getOption(\"healthdb.verbose\"), ...)"},{"path":"https://kevinhzq.github.io/healthdb/reference/fetch_var.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get variables from multiple tables with common ID columns — fetch_var","text":"data local data.frame, tibble. used x argument left_join(). keys vector quoted/unquoted variable names, 'tidyselect' expression (see dplyr::select()). variables must present data used argument left_join(). y tables must subset . linkage list formulas form \"from_tab ~ get_vars|by_keys\": source table left-hand-side variables right-hand-side source table variables keys, use \"|\" RHS specify subset keys used. example, given keys 3 variables, list( y1 ~ tidyselect_expr1, y2 ~ tidyselect_expr2|key1 + key2) meaning: table y1 get variables picked tidyselect expression matching 3 keys; table y2 get variables matching key1 key2. verbose logical whether report number rows joining source. Default getting options. Use options(healthdb.verbose = FALSE) suppress . ... Additional arguments passing left_join().","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/fetch_var.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get variables from multiple tables with common ID columns — fetch_var","text":"data.frame tibble containing original columns x new variables matched tables based specified linkage.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/fetch_var.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get variables from multiple tables with common ID columns — fetch_var","text":"","code":"# make toy data size <- 30 n <- 10 df1 <- data.frame(   id = sample(1:n, size = size, replace = TRUE),   service_dt = sample(seq(as.Date(\"2020-01-01\"), as.Date(\"2022-01-31\"), by = 1),     size = size   ) ) %>%   dplyr::mutate(year = lubridate::year(service_dt)) df2 <- data.frame(   id = rep(1:n, size / n), year = rep(2020:2022, each = n),   status_1 = sample(0:1, size = size, replace = TRUE),   status_2 = sample(0:1, size = size, replace = TRUE) ) df3 <- data.frame(id = 1:n, sex = sample(c(\"F\", \"M\"), size = n, replace = TRUE))  # simple joins # note that for left_join(df1, df2), boths keys have to be used, # otherwise, error as the relation would not be one-to-one fetch_var(df1,   keys = c(id, year),   linkage = list(     df2 ~ starts_with(\"s\"), # match both keys without '|'     df3 ~ sex | id   ) # match by id only; otherwise failed because df3 has no year ) #>  #> The data has 30 rows. After joining, variable(s) from df2 has 30 rows, and variable(s) from df3 has 30 rows  #>    id service_dt year status_1 status_2 sex #> 1   2 2020-01-01 2020        1        1   F #> 2   9 2020-06-23 2020        0        0   M #> 3   2 2021-02-15 2021        0        1   F #> 4   8 2020-07-27 2020        0        0   F #> 5   9 2020-05-10 2020        0        0   M #> 6   1 2021-03-06 2021        1        0   F #> 7   3 2020-12-10 2020        1        0   M #> 8   9 2020-07-15 2020        0        0   M #> 9   1 2021-08-02 2021        1        0   F #> 10  7 2021-07-19 2021        1        1   F #> 11  4 2021-01-08 2021        0        0   F #> 12  4 2020-02-17 2020        1        1   F #> 13  1 2020-03-24 2020        1        1   F #> 14  1 2021-02-13 2021        1        0   F #> 15  8 2021-10-14 2021        1        0   F #> 16  6 2020-09-12 2020        0        0   F #> 17 10 2020-04-26 2020        0        0   M #> 18  1 2020-11-28 2020        1        1   F #> 19  6 2020-05-21 2020        0        0   F #> 20  8 2021-07-01 2021        1        0   F #> 21  1 2020-06-16 2020        1        1   F #> 22  5 2021-01-23 2021        1        0   F #> 23  6 2020-02-25 2020        0        0   F #> 24  1 2022-01-23 2022        0        1   F #> 25  8 2020-10-05 2020        0        0   F #> 26  4 2021-08-11 2021        0        0   F #> 27  3 2020-01-03 2020        1        0   M #> 28  8 2020-01-05 2020        0        0   F #> 29  2 2020-07-19 2020        1        1   F #> 30 10 2020-08-20 2020        0        0   M  # example if some y is remote # make df2 as database table db2 <- dbplyr::tbl_memdb(df2)  fetch_var(df1,   keys = c(id, year),   linkage = list(     db2 ~ starts_with(\"s\"),     df3 ~ sex | id   ),   copy = TRUE # pass to left_join for forced collection of remote table ) #>  #> The data has 30 rows. After joining, variable(s) from db2 has 30 rows, and variable(s) from df3 has 30 rows  #>    id service_dt year status_1 status_2 sex #> 1   2 2020-01-01 2020        1        1   F #> 2   9 2020-06-23 2020        0        0   M #> 3   2 2021-02-15 2021        0        1   F #> 4   8 2020-07-27 2020        0        0   F #> 5   9 2020-05-10 2020        0        0   M #> 6   1 2021-03-06 2021        1        0   F #> 7   3 2020-12-10 2020        1        0   M #> 8   9 2020-07-15 2020        0        0   M #> 9   1 2021-08-02 2021        1        0   F #> 10  7 2021-07-19 2021        1        1   F #> 11  4 2021-01-08 2021        0        0   F #> 12  4 2020-02-17 2020        1        1   F #> 13  1 2020-03-24 2020        1        1   F #> 14  1 2021-02-13 2021        1        0   F #> 15  8 2021-10-14 2021        1        0   F #> 16  6 2020-09-12 2020        0        0   F #> 17 10 2020-04-26 2020        0        0   M #> 18  1 2020-11-28 2020        1        1   F #> 19  6 2020-05-21 2020        0        0   F #> 20  8 2021-07-01 2021        1        0   F #> 21  1 2020-06-16 2020        1        1   F #> 22  5 2021-01-23 2021        1        0   F #> 23  6 2020-02-25 2020        0        0   F #> 24  1 2022-01-23 2022        0        1   F #> 25  8 2020-10-05 2020        0        0   F #> 26  4 2021-08-11 2021        0        0   F #> 27  3 2020-01-03 2020        1        0   M #> 28  8 2020-01-05 2020        0        0   F #> 29  2 2020-07-19 2020        1        1   F #> 30 10 2020-08-20 2020        0        0   M"},{"path":"https://kevinhzq.github.io/healthdb/reference/healthdb-package.html","id":null,"dir":"Reference","previous_headings":"","what":"healthdb: Working with Healthcare Databases — healthdb-package","title":"healthdb: Working with Healthcare Databases — healthdb-package","text":"system identifying diseases events healthcare databases preparing data epidemiological studies. includes capabilities supported 'SQL', matching strings 'stringr' style regular expressions, can compute comorbidity scores (Quan et al. (2005) doi:10.1097/01.mlr.0000182534.19832.83 ) directly database server. implementation based 'dbplyr' full 'tidyverse' compatibility.","code":""},{"path":[]},{"path":"https://kevinhzq.github.io/healthdb/reference/healthdb-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"healthdb: Working with Healthcare Databases — healthdb-package","text":"Maintainer: Kevin Hu kevin.hu@bccdc.ca (ORCID) [copyright holder]","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/identify_row.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify rows with a match — identify_row","title":"Identify rows with a match — identify_row","text":"Filter rows values satisfy specified conditions. functionality identical dplyr::filter() combined dplyr::if_any() dplyr::if_all(), used 'data.table' package vignette(\"datatable-intro\", package = \"data.table\") data.frame method, regular regular expression support remote database tables. motivation take away pain working databases often support regular expression 'LIKE' operator multiple string patterns.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/identify_row.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify rows with a match — identify_row","text":"","code":"identify_row(   data,   vars,   match = c(\"in\", \"start\", \"regex\", \"like\", \"between\", \"glue_sql\"),   vals,   if_all = FALSE,   verbose = getOption(\"healthdb.verbose\"),   query_only = TRUE,   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/identify_row.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify rows with a match — identify_row","text":"data Data.frames remote tables (e.g., dbplyr::tbl_sql()) vars expression passing dplyr::select(). can quoted/unquoted column names, helper functions, dplyr::starts_with(). match One \"\", \"start\", \"regex\", \"like\", \"\", \"glue_sql\". determines values matched. operations type: \"\": var %% vals (default) \"regex\": stringr::str_detect(var, vals). remote tables, unique values vars collected locally matching (may slow). \"like\": stringr::str_like(var, vals). remote tables, var LIKE val. \"start\": regex LIKE modified vals, e.g., \"^val1|^val2\" \"va1%|val2%\" \"\": dplyr::(var, val1, val2) \"glue_sql\": remote table , gives full control clause using dplyr::filter(dbplyr::sql(glue::glue_sql(...))) vals Depending match, takes different input: \"\": vector values (numeric/character/Date) \"start\": vector numeric/character modified regex LIKE pattern string adding \"^\" front \"%\" end \"regex\"/\"like\": string expression \"\": vector numeric date exactly two elements, e.g., c(lower, upper) \"glue_sql\": string SQL clause, passed glue::glue_sql(). See examples detail. if_all logical whether combining predicates (multiple columns selected vars) instead . Default FALSE, e.g., var1 vals var2 vals. verbose logical whether printing explanation result overview query. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . Result overview remote tables query executed immediately, thus result available summary without adding extra run (may slow) query. query_only logical whether keeping output remote table (Default TRUE) downloading query result tibble (FALSE). argument ignored input data data.frame/tibble. ... remote table method . Additional arguments passing glue::glue_sql() parameterized queries.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/identify_row.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify rows with a match — identify_row","text":"data.frame tbl_sql object depending input.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/identify_row.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify rows with a match — identify_row","text":"","code":"#applying to data.frame; both sepal length and width in range 3-5 identify_row(iris, starts_with(\"Sepal\"), \"between\", c(3, 5), if_all = TRUE) #>  #> Identify records with condition(s):  #>  - where all of the Sepal.Length, Sepal.Width column(s) in each record  #>    - contains a value between range (bounds included): c(3, 5)  #>  #> Summary of values in the result :  #> Range: [1] 3 5 #>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species #> 1           4.9         3.0          1.4         0.2  setosa #> 2           4.7         3.2          1.3         0.2  setosa #> 3           4.6         3.1          1.5         0.2  setosa #> 4           5.0         3.6          1.4         0.2  setosa #> 5           4.6         3.4          1.4         0.3  setosa #> 6           5.0         3.4          1.5         0.2  setosa #> 7           4.9         3.1          1.5         0.1  setosa #> 8           4.8         3.4          1.6         0.2  setosa #> 9           4.8         3.0          1.4         0.1  setosa #> 10          4.3         3.0          1.1         0.1  setosa #> 11          4.6         3.6          1.0         0.2  setosa #> 12          4.8         3.4          1.9         0.2  setosa #> 13          5.0         3.0          1.6         0.2  setosa #> 14          5.0         3.4          1.6         0.4  setosa #> 15          4.7         3.2          1.6         0.2  setosa #> 16          4.8         3.1          1.6         0.2  setosa #> 17          4.9         3.1          1.5         0.2  setosa #> 18          5.0         3.2          1.2         0.2  setosa #> 19          4.9         3.6          1.4         0.1  setosa #> 20          4.4         3.0          1.3         0.2  setosa #> 21          5.0         3.5          1.3         0.3  setosa #> 22          4.4         3.2          1.3         0.2  setosa #> 23          5.0         3.5          1.6         0.6  setosa #> 24          4.8         3.0          1.4         0.3  setosa #> 25          4.6         3.2          1.4         0.2  setosa #> 26          5.0         3.3          1.4         0.2  setosa  #applying to remote table; species starts with se or ends with ca iris_db <- dbplyr::memdb_frame(iris) identify_row(iris_db, Species, \"like\", c(\"se%\", \"%ca\")) #>  #> Identify records with condition(s):  #>  - where the Species column(s) in each record  #>    - contains a value satisfied SQL LIKE pattern: se% OR %ca  #>  #> To see the final query generated by 'dbplyr', use dplyr::show_query() on the output.  #> To extract the SQL string, use dbplyr::remote_query(). #> # Source:   SQL [?? x 5] #> # Database: sqlite 3.45.2 [:memory:] #>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species #>           <dbl>       <dbl>        <dbl>       <dbl> <chr>   #>  1          4.3         3            1.1         0.1 setosa  #>  2          4.4         2.9          1.4         0.2 setosa  #>  3          4.4         3            1.3         0.2 setosa  #>  4          4.4         3.2          1.3         0.2 setosa  #>  5          4.5         2.3          1.3         0.3 setosa  #>  6          4.6         3.1          1.5         0.2 setosa  #>  7          4.6         3.2          1.4         0.2 setosa  #>  8          4.6         3.4          1.4         0.3 setosa  #>  9          4.6         3.6          1           0.2 setosa  #> 10          4.7         3.2          1.3         0.2 setosa  #> # ℹ more rows  #using glue_sql to write the WHERE clause #use {`vars`} to refer to the variables selected by vars #supply additional values required in the query through '...' #note that if you use LIKE here, you cannot supply multiple patterns in what identify_row(iris_db, Species, \"glue_sql\",  \"{`vars`} LIKE {what}\",   what = \"se%\") #>  #> Identify records with condition(s):  #>  - where the Species column(s) in each record  #>    - contains a value satisfied SQL WHERE clause: `Species` LIKE 'se%'  #>  #> To see the final query generated by 'dbplyr', use dplyr::show_query() on the output.  #> To extract the SQL string, use dbplyr::remote_query(). #> # Source:   SQL [?? x 5] #> # Database: sqlite 3.45.2 [:memory:] #>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species #>           <dbl>       <dbl>        <dbl>       <dbl> <chr>   #>  1          5.1         3.5          1.4         0.2 setosa  #>  2          4.9         3            1.4         0.2 setosa  #>  3          4.7         3.2          1.3         0.2 setosa  #>  4          4.6         3.1          1.5         0.2 setosa  #>  5          5           3.6          1.4         0.2 setosa  #>  6          5.4         3.9          1.7         0.4 setosa  #>  7          4.6         3.4          1.4         0.3 setosa  #>  8          5           3.4          1.5         0.2 setosa  #>  9          4.4         2.9          1.4         0.2 setosa  #> 10          4.9         3.1          1.5         0.1 setosa  #> # ℹ more rows  #add * after a vector identify_row(iris_db, Species, \"glue_sql\",  \"{`vars`} IN ({what*})\",  what = c(\"setosa\", \"virginica\")) #>  #> Identify records with condition(s):  #>  - where the Species column(s) in each record  #>    - contains a value satisfied SQL WHERE clause: `Species` IN ('setosa', 'virginica')  #>  #> To see the final query generated by 'dbplyr', use dplyr::show_query() on the output.  #> To extract the SQL string, use dbplyr::remote_query(). #> # Source:   SQL [?? x 5] #> # Database: sqlite 3.45.2 [:memory:] #>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species #>           <dbl>       <dbl>        <dbl>       <dbl> <chr>   #>  1          5.1         3.5          1.4         0.2 setosa  #>  2          4.9         3            1.4         0.2 setosa  #>  3          4.7         3.2          1.3         0.2 setosa  #>  4          4.6         3.1          1.5         0.2 setosa  #>  5          5           3.6          1.4         0.2 setosa  #>  6          5.4         3.9          1.7         0.4 setosa  #>  7          4.6         3.4          1.4         0.3 setosa  #>  8          5           3.4          1.5         0.2 setosa  #>  9          4.4         2.9          1.4         0.2 setosa  #> 10          4.9         3.1          1.5         0.1 setosa  #> # ℹ more rows"},{"path":"https://kevinhzq.github.io/healthdb/reference/if_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Interpret if n dates drawn from a vector could be some days apart within some years — if_date","title":"Interpret if n dates drawn from a vector could be some days apart within some years — if_date","text":"Given vector dates x, interpret least one set n elements taken x satisfy adjacent elements set least certain days apart dates set within specified time span. identifying events/diseases administrative data, definitions often require, e.g., n diagnoses least days apart within years. function intended use optimized avoid looping n-size combinations x. function work remote table input.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/if_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interpret if n dates drawn from a vector could be some days apart within some years — if_date","text":"","code":"if_date(   x,   n,   apart = NULL,   within = NULL,   detail = FALSE,   align = c(\"left\", \"right\"),   dup.rm = TRUE,   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/if_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interpret if n dates drawn from a vector could be some days apart within some years — if_date","text":"x character Date vector n integer size draw apart integer specifying minimum gap (days) adjacent dates draw. within integer specifying maximum time span (days) draw. detail Logical whether return result per element x.default FALSE, returns one logical summarized (). Detail available apart supplied without within sets satisfied condition overlap, records within set may far apart; thus, unambiguous way label element. align Character, define time span record start (\"left\") end (\"right\") current date. Defaults \"left\". See 'flag_at' argument restrict_date() detail. dup.rm Logical whether multiple records date count one calculation. applicable within supplied without apart; duplicated dates impact apart present n dates must distinct apart. Default TRUE. ... Additional argument passing data.table::.IDate() date conversion.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/if_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interpret if n dates drawn from a vector could be some days apart within some years — if_date","text":"Single vector logical whether draw x satisfied conditions","code":""},{"path":[]},{"path":"https://kevinhzq.github.io/healthdb/reference/if_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interpret if n dates drawn from a vector could be some days apart within some years — if_date","text":"","code":"dates_of_records <- sample(seq(as.Date(\"2015-01-01\"), as.Date(\"2021-12-31\"), 7), 10)  # whether there is any 3 records at least 30 days apart within 2 years if_date(dates_of_records, n = 3, apart = 30, within = 365 * 2) #> [1] TRUE  # specified either apart or within or both if_date(dates_of_records, n = 2, within = 365) #> [1] TRUE"},{"path":"https://kevinhzq.github.io/healthdb/reference/lookup.html","id":null,"dir":"Reference","previous_headings":"","what":"Find value corresponding to input vector using a look-up table — lookup","title":"Find value corresponding to input vector using a look-up table — lookup","text":"Find value corresponding input vector using look-table","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/lookup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find value corresponding to input vector using a look-up table — lookup","text":"","code":"lookup(x, link, lu, verbose = getOption(\"healthdb.verbose\"))"},{"path":"https://kevinhzq.github.io/healthdb/reference/lookup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find value corresponding to input vector using a look-up table — lookup","text":"x variable name data.frame; function called inside dplyr::mutate(). link formula form: name_of_x_in_lu ~ name_of_target_value. left-hand-side can omitted x's name also x look-. lu Look-table data.frame class. verbose logical whether warn missing values output.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/lookup.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find value corresponding to input vector using a look-up table — lookup","text":"vector matched values.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/lookup.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find value corresponding to input vector using a look-up table — lookup","text":"","code":"df <- data.frame(drug_code = 1:10) lu <- data.frame(drug_id = 1:20, drug_code = as.character(1:10), drug_name = sample(letters, 20))  df %>% dplyr::mutate(   drug_nm = lookup(drug_code, drug_id ~ drug_name, lu),   # this will work as lu also has drug_code column   drug_nm = lookup(drug_code, ~ drug_name, lu) ) #>    drug_code drug_nm #> 1          1       m #> 2          2       q #> 3          3       g #> 4          4       a #> 5          5       s #> 6          6       c #> 7          7       r #> 8          8       x #> 9          9       p #> 10        10       l"},{"path":"https://kevinhzq.github.io/healthdb/reference/make_test_dat.html","id":null,"dir":"Reference","previous_headings":"","what":"Make test data — make_test_dat","title":"Make test data — make_test_dat","text":"Make toy data set testing demo. internal use purpose intended called users.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/make_test_dat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make test data — make_test_dat","text":"","code":"make_test_dat(   vals_kept = c(\"304\", \"305\", 3040:3049, 3050:3059),   noise_val = \"999\",   IDs = 1:50,   date_range = seq(as.Date(\"2015-01-01\"), as.Date(\"2020-12-31\"), by = 1),   nrows = 100,   n_any = 50,   n_all = 10,   seed = 2024,   answer_id = NULL,   type = c(\"data.frame\", \"database\") )"},{"path":"https://kevinhzq.github.io/healthdb/reference/make_test_dat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make test data — make_test_dat","text":"vals_kept vector values suppose identified. noise_val vector values meant identified. IDs vector client IDs. date_range vector possible dates data. nrows Number rows output. n_any Number rows identified criteria target column contains certain values. n_all Number rows identified criteria target columns contain certain values. seed Seed random number generation. answer_id Column name indicator row identified: , , noise. type Output type, \"data.frame\" \"database\".","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/make_test_dat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make test data — make_test_dat","text":"data.frame remote table 'dbplyr'.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/make_test_dat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make test data — make_test_dat","text":"","code":"make_test_dat() #>     uid clnt_id      dates diagx diagx_1 diagx_2 #> 1    68       2 2016-08-03   999     999     999 #> 2    11       2 2020-07-02   305    3055    <NA> #> 3    23       3 2019-07-08  3057    3056     999 #> 4    49       4 2017-10-23  3042    3058    3045 #> 5    89       4 2017-11-04   999     999     999 #> 6     9       5 2018-12-23  3053     304    <NA> #> 7    18       6 2017-03-07  3046    3047    <NA> #> 8    66       7 2019-07-17   999     999     999 #> 9    58       8 2017-06-08   999    <NA>    <NA> #> 10   45       8 2018-02-22   304    3041    3056 #> 11   61       8 2020-10-26   999     999     999 #> 12   79       9 2019-05-03   999     999    <NA> #> 13   85       9 2019-09-04   999    <NA>    <NA> #> 14   95       9 2020-12-25   999    <NA>    <NA> #> 15   15      10 2017-05-29   304    3042     999 #> 16   93      11 2015-08-25   999     999     999 #> 17    2      12 2016-01-25  3042    3056     999 #> 18   77      12 2018-04-22   999     999    <NA> #> 19   54      12 2020-06-10   999     999     999 #> 20    3      13 2018-09-12  3050    3045    <NA> #> 21   16      14 2015-12-29  3048     305    <NA> #> 22   97      14 2020-04-30   999     999    <NA> #> 23   70      14 2020-08-16   999     999     999 #> 24   17      15 2015-10-14  3040    <NA>    <NA> #> 25   13      15 2017-07-23  3055    3041    <NA> #> 26   12      15 2018-06-17  3049    3048     999 #> 27   83      16 2018-03-03   999    <NA>     999 #> 28   32      16 2020-05-17  3053    3052     999 #> 29   25      17 2017-01-29  3057    3052    <NA> #> 30   44      17 2019-12-04  3059    3058     304 #> 31   22      18 2015-05-16  3057    3047    <NA> #> 32   29      18 2017-03-06  3044    3044    <NA> #> 33   20      18 2018-03-16  3054    3045     999 #> 34   43      18 2019-07-29  3058    3054    3047 #> 35   88      18 2019-12-29   999    <NA>     999 #> 36   10      19 2018-04-08  3051    3053     999 #> 37   59      19 2020-12-04   999     999    <NA> #> 38   51      20 2016-01-20   999     999    <NA> #> 39   31      20 2020-06-09  3058    3056    <NA> #> 40   60      21 2015-01-19   999     999     999 #> 41   47      21 2016-12-05  3040    3046    3055 #> 42   41      21 2020-06-21   305    3058     305 #> 43   91      21 2020-11-16   999     999    <NA> #> 44    5      22 2017-10-20  3050    3049     999 #> 45   71      23 2019-03-08   999     999    <NA> #> 46   72      24 2019-10-10   999    <NA>     999 #> 47   35      24 2020-07-31   305    3047    <NA> #> 48   84      28 2017-12-30   999    <NA>     999 #> 49   38      28 2018-01-15  3054    3048    <NA> #> 50  100      29 2018-01-01   999    <NA>     999 #> 51   24      29 2019-11-24  3048    3050     999 #> 52    1      29 2020-12-17   305    3042    <NA> #> 53   78      30 2015-11-19   999    <NA>     999 #> 54   50      30 2016-04-25  3042    3055    3045 #> 55   96      30 2017-11-14   999    <NA>    <NA> #> 56    7      30 2019-11-05   305    3047    <NA> #> 57   63      31 2016-03-24   999    <NA>    <NA> #> 58   69      31 2016-04-09   999     999    <NA> #> 59   52      31 2016-09-23   999    <NA>    <NA> #> 60   75      31 2017-11-26   999    <NA>     999 #> 61   36      32 2020-10-14  3054     304     999 #> 62   94      33 2016-03-01   999    <NA>     999 #> 63   28      33 2016-07-24  3041    3053    <NA> #> 64    8      33 2019-12-14  3048    3057    <NA> #> 65   33      35 2017-09-26  3057    3058     999 #> 66   62      35 2018-08-14   999    <NA>    <NA> #> 67   99      36 2015-12-02   999     999    <NA> #> 68   80      36 2016-04-22   999     999    <NA> #> 69   14      36 2018-08-13  3058    3052    <NA> #> 70   55      36 2019-12-10   999     999     999 #> 71   82      38 2016-11-29   999     999    <NA> #> 72   57      38 2017-01-25   999     999    <NA> #> 73   46      39 2017-06-24   305    3053     304 #> 74   81      39 2017-09-23   999     999     999 #> 75    6      39 2018-11-27  3046    3052     999 #> 76   74      39 2020-02-05   999    <NA>    <NA> #> 77   87      40 2020-07-14   999    <NA>    <NA> #> 78   19      41 2018-01-14  3051    3055    <NA> #> 79   64      42 2016-05-21   999     999     999 #> 80   65      42 2018-06-27   999     999     999 #> 81    4      43 2016-01-24  3054    3051     999 #> 82   37      43 2016-07-03  3059    3055     999 #> 83   40      43 2018-11-13   304     304     999 #> 84   21      44 2016-10-18  3053     305     999 #> 85   67      44 2017-04-21   999     999     999 #> 86   56      44 2019-07-17   999    <NA>     999 #> 87   53      45 2015-10-02   999    <NA>    <NA> #> 88   26      45 2018-08-08  3057    3040    <NA> #> 89   34      45 2019-07-31  3040    3054     999 #> 90   48      45 2019-08-20  3050    3059     304 #> 91   27      46 2020-02-23  3047    3050     999 #> 92   76      47 2015-11-05   999     999     999 #> 93   30      47 2018-02-21  3057    3045    <NA> #> 94   42      48 2017-03-21  3048     305    3050 #> 95   73      48 2019-03-09   999    <NA>    <NA> #> 96   39      48 2019-08-28  3040    3053    <NA> #> 97   90      49 2015-08-26   999    <NA>    <NA> #> 98   98      49 2015-09-03   999     999    <NA> #> 99   86      49 2020-08-17   999     999     999 #> 100  92      50 2019-07-24   999    <NA>     999"},{"path":"https://kevinhzq.github.io/healthdb/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://kevinhzq.github.io/healthdb/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling `rhs(lhs)`.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/pool_case.html","id":null,"dir":"Reference","previous_headings":"","what":"Pooling qualified clients from multiple sources — pool_case","title":"Pooling qualified clients from multiple sources — pool_case","text":"function filters pools, .e., row bind, qualified clients/groups different source option summarize client. Unlike bind_source(), need supply variable names; function guess included names supplied definition build_def(). Whether client qualified relies flag variables set define_case(). Therefore, function intended use built-define_case() def_fn build_def().","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/pool_case.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pooling qualified clients from multiple sources — pool_case","text":"","code":"pool_case(   data,   def,   output_lvl = c(\"raw\", \"clnt\"),   include_src = c(\"all\", \"has_valid\", \"n_per_clnt\"),   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/pool_case.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pooling qualified clients from multiple sources — pool_case","text":"data list data.frame remote table output execute_def(). def tibble case definition generated build_def(). output_lvl Either: \"raw\" - output records (default), \"clnt\" - output one record per client summaries including date first valid record ('first_valid_date'), date latest record ('last_entry_date'), sources contain valid records. include_src Character. determines records sources included. matters clients identified , , sources. choice impact number client identified impact number records latest entry date. options one : \"\" - records sources included; \"has_valid\" - client, records sources contain least one valid record included; \"n_per_clnt\" - client, fewer n_per_clnt records source (see restrict_n()), records source removed. ... Additional arguments passing bind_source()","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/pool_case.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pooling qualified clients from multiple sources — pool_case","text":"data.frame remote table clients satisfied predefined case definition. Columns started \"raw_in_\" source-specific counts raw records, columns started \"valid_in_\" number valid entries (number flags) source.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/pool_case.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pooling qualified clients from multiple sources — pool_case","text":"","code":"# toy data sample_size <- 30 df <- data.frame(   clnt_id = rep(1:3, each = 10),   service_dt = sample(seq(as.Date(\"2020-01-01\"), as.Date(\"2020-01-31\"), by = 1),     size = sample_size, replace = TRUE   ),   diagx = sample(letters, size = sample_size, replace = TRUE),   diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),   diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE) )  # make df a database table db <- dbplyr::tbl_memdb(df) #> Error in db_copy_to(dest$con, name, df, overwrite = overwrite, types = types,     temporary = temporary, unique_indexes = unique_indexes, indexes = indexes,     analyze = analyze, in_transaction = in_transaction, ...): Can't copy data to table `df`. #> Caused by error in `dplyr::db_write_table()`: #> ! Can't write table table `df`. #> Caused by error: #> ! Table `df` exists in database, and both overwrite and append are FALSE  # use build_def to make a toy definition sud_def <- build_def(\"SUD\", # usually a disease name   src_lab = c(\"src1\", \"src2\"), # identify from multiple sources, e.g., hospitalization, ED visits.   # functions that filter the data with some criteria   def_fn = define_case,   fn_args = list(     vars = starts_with(\"diagx\"),     match = \"start\", # \"start\" will be applied to all sources as length = 1     vals = list(c(\"304\"), c(\"305\")),     clnt_id = \"clnt_id\", # list()/c() could be omitted for single element     # c() can be used in place of list     # if this argument only takes one value for each source     n_per_clnt = c(2, 3)   ) )  # save the definition for re-use # saveRDS(sud_def, file = some_path)  # execute definition sud_by_src <- sud_def %>% execute_def(with_data = list(src1 = db, src2 = db)) #> Error: object 'db' not found  # pool results from src1 and src2 together at client level sud_pooled <- pool_case(sud_by_src, sud_def, output_lvl = \"clnt\") #> Error in eval(expr, envir, enclos): object 'sud_by_src' not found"},{"path":"https://kevinhzq.github.io/healthdb/reference/report_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Report number of distinct value in a column across data frames — report_n","title":"Report number of distinct value in a column across data frames — report_n","text":"function intended mimic dplyr::n_distinct() multiple inputs. useful report number clients series inclusion exclusion steps. use case getting Ns sample definition flowchart epidemiological study. also useful inline reporting Ns Rmarkdown document.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/report_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Report number of distinct value in a column across data frames — report_n","text":"","code":"report_n(..., on, force_proceed = getOption(\"healthdb.force_proceed\"))"},{"path":"https://kevinhzq.github.io/healthdb/reference/report_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Report number of distinct value in a column across data frames — report_n","text":"... Data frames remote tables (e.g., 'dbplyr') column report . must present data sources. force_proceed logical whether ask user input order proceed data local data.frames, query needs executed reporting. default fetching options. Use options(healthdb.force_proceed = FALSE) suppress prompt .","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/report_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Report number of distinct value in a column across data frames — report_n","text":"sequence number distinct data frames","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/report_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Report number of distinct value in a column across data frames — report_n","text":"","code":"# some exclusions iris_1 <- subset(iris, Petal.Length > 1) iris_2 <- subset(iris, Petal.Length > 2)  # get n at each operation n <- report_n(iris, iris_1, iris_2, on = Species) n #> [1] 3 3 2  # get the difference at each step diff(n) #> [1]  0 -1"},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Removes or flags groups failed to meet conditions based on dates — restrict_date","title":"Removes or flags groups failed to meet conditions based on dates — restrict_date","text":"client group, interpret n records least certain days apart within specified time span. identifying events/diseases administrative data, definitions often require, e.g., n diagnoses least days apart within years. function intended use optimized avoid looping n-size combinations dates per client.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Removes or flags groups failed to meet conditions based on dates — restrict_date","text":"","code":"restrict_date(   data,   clnt_id,   date_var,   n,   apart = NULL,   within = NULL,   uid = NULL,   mode = c(\"flag\", \"filter\"),   flag_at = c(\"left\", \"right\"),   dup.rm = TRUE,   force_collect = FALSE,   verbose = getOption(\"healthdb.verbose\"),   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Removes or flags groups failed to meet conditions based on dates — restrict_date","text":"data Data frames remote tables (e.g., dbplyr::tbl_sql()) clnt_id Grouping variable (quoted/unquoted). date_var Variable name (quoted/unquoted) dates interpreted. n integer size draw. apart integer specifying minimum gap (days) adjacent dates draw. option implemented data.frame input. within integer specifying maximum time span (days) draw. uid Variable name unique row identifier. necessary SQL produce consistent result based sorting. mode Either: \"flag\" - add new column 'flag_restrict_date' indicating condition met (flag = 1 time period starting ending current record satisfied apart-within condition), \"filter\" - remove clients without qualified record data. Default \"flag\". flag_at Character, define flag placed start (\"left\") end (\"right\") time period contains n qualified records. Defaults \"left\". Note impact first last qualified/diagnosed dates client, e.g., using \"right\" first flag earliest date client became qualified. example, condition 2 records within year, c(\"2023-01-01\", \"2023-04-01\", \"2024-05-01\"), flag c(0, 1, 0) \"right\" c(1,0,0) \"left\". dup.rm Logical whether multiple records date count one calculation. applicable within supplied without apart; duplicated dates impact apart present n dates must distinct apart. Default TRUE. force_collect logical whether force downloading remote table apart NULL. remote table , apart implemented local data frame . Downloading data slow, user opt ; default FALSE stop error. verbose logical whether explain query report many groups removed. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . Reporting remote tables query executed immediately, thus result available summary without adding extra run (may slow) query. ... Additional argument passing data.table::.IDate() date conversion.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Removes or flags groups failed to meet conditions based on dates — restrict_date","text":"subset input data satisfied dates requirement, raw input data new flag column.","code":""},{"path":[]},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Removes or flags groups failed to meet conditions based on dates — restrict_date","text":"","code":"sample_size <- 30 df <- data.frame(clnt_id = sample(1:sample_size, sample_size, replace = TRUE),  service_dt = sample(seq(as.Date(\"2020-01-01\"), as.Date(\"2020-01-31\"), by = 1),                      size = sample_size, replace = TRUE),  diagx = sample(letters, size = sample_size, replace = TRUE),  diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),  diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE))  #Keep clients with 2 records that were 1 week apart within 1 month restrict_date(df, clnt_id, service_dt, n = 2, apart = 7, within = 30) #>  #>  Of the 19 clients in the input, 14 were flagged as 0 by restricting that each client must have 2 records that were at least 7 days apart within 30 days.  #> # A tibble: 30 × 6 #>    clnt_id service_dt diagx diagx_1 diagx_2 flag_restrict_date #>      <int> <date>     <chr> <chr>   <chr>                <dbl> #>  1       1 2020-01-09 k     r       s                        0 #>  2       1 2020-01-11 f     r       n                        0 #>  3       2 2020-01-12 t     w       x                        0 #>  4       2 2020-01-17 p     j       c                        0 #>  5       5 2020-01-21 l     a       y                        0 #>  6       6 2020-01-20 o     j       x                        0 #>  7       6 2020-01-20 w     b       l                        0 #>  8       7 2020-01-14 b     k       g                        0 #>  9       8 2020-01-14 t     c       z                        1 #> 10       8 2020-01-22 u     m       a                        0 #> # ℹ 20 more rows"},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Removes or flags groups with n less than some number — restrict_n","title":"Removes or flags groups with n less than some number — restrict_n","text":"Remove flags groups clients less number rows number distinct values variable. example, can used remove clients less n visits service different dates administrative records. offers filtering dplyr::n_distinct() functionality database input.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Removes or flags groups with n less than some number — restrict_n","text":"","code":"restrict_n(   data,   clnt_id,   n_per_clnt,   count_by = NULL,   mode = c(\"flag\", \"filter\"),   verbose = getOption(\"healthdb.verbose\") )"},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Removes or flags groups with n less than some number — restrict_n","text":"data Data.frames remote tables (e.g., dbplyr::tbl_sql()) clnt_id Grouping variable (quoted/unquoted). n_per_clnt single number specifying minimum number group size. count_by Another variable dictating counting unit n_per_clnt. default NULL meaning inclusion criteria number row, .e., dplyr::n() >= n_per_clnt. NULL, criteria becomes equivalent dplyr::n_distinct(count_by) >= n_per_clnt. mode Either \"flag\" - add new column 'flag_restrict_n' indicating client met condition (rows qualified client flag = 1), \"filter\" - remove clients meet condition data. Default \"flag\". verbose logical whether explain query report many groups removed. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . Reporting remote tables query executed immediately, thus result available summary without adding extra run (may slow) query.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Removes or flags groups with n less than some number — restrict_n","text":"subset input data satisfied group size requirement, raw input data new flag column.","code":""},{"path":[]},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Removes or flags groups with n less than some number — restrict_n","text":"","code":"#remove cyl groups with less than 8 cars restrict_n(mtcars, clnt_id = cyl, n_per_clnt = 8) #>  #> Of the 3 clients in the input, 1 were flagged as 0 by restricting that each client must have at least 8 records   #>     mpg cyl  disp  hp drat    wt  qsec vs am gear carb flag_restrict_n #> 1  21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4               0 #> 2  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4               0 #> 3  22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1               1 #> 4  21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1               0 #> 5  18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2               1 #> 6  18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1               0 #> 7  14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4               1 #> 8  24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2               1 #> 9  22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2               1 #> 10 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4               0 #> 11 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4               0 #> 12 16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3               1 #> 13 17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3               1 #> 14 15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3               1 #> 15 10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4               1 #> 16 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4               1 #> 17 14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4               1 #> 18 32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1               1 #> 19 30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2               1 #> 20 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1               1 #> 21 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1               1 #> 22 15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2               1 #> 23 15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2               1 #> 24 13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4               1 #> 25 19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2               1 #> 26 27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1               1 #> 27 26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2               1 #> 28 30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2               1 #> 29 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4               1 #> 30 19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6               0 #> 31 15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8               1 #> 32 21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2               1  #remove cyl groups with less than 2 types of gear boxes restrict_n(mtcars, clnt_id = cyl, n_per_clnt = 3, count_by = gear) #>  #> Of the 3 clients in the input, 1 were flagged as 0 by restricting that each client must have at least 3 records with distinct gear  #>     mpg cyl  disp  hp drat    wt  qsec vs am gear carb flag_restrict_n #> 1  21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4               1 #> 2  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4               1 #> 3  22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1               1 #> 4  21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1               1 #> 5  18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2               0 #> 6  18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1               1 #> 7  14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4               0 #> 8  24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2               1 #> 9  22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2               1 #> 10 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4               1 #> 11 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4               1 #> 12 16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3               0 #> 13 17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3               0 #> 14 15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3               0 #> 15 10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4               0 #> 16 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4               0 #> 17 14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4               0 #> 18 32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1               1 #> 19 30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2               1 #> 20 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1               1 #> 21 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1               1 #> 22 15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2               0 #> 23 15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2               0 #> 24 13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4               0 #> 25 19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2               0 #> 26 27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1               1 #> 27 26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2               1 #> 28 30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2               1 #> 29 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4               0 #> 30 19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6               1 #> 31 15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8               0 #> 32 21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2               1"},{"path":[]},{"path":"https://kevinhzq.github.io/healthdb/news/index.html","id":"bug-fixes-development-version","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"healthdb (development version)","text":"Fixed if_date() gave output shorter input detail dup.rm TRUE. if_date() now assume dates sorted returns elements original unsorted order. Fixed restrict_date remote table might miss cases duplicated dates n > 2.","code":""},{"path":"https://kevinhzq.github.io/healthdb/news/index.html","id":"improvements-development-version","dir":"Changelog","previous_headings":"","what":"Improvements","title":"healthdb (development version)","text":"restrict_date() give warning missing entries date_var. description dup.rm re-written clarify applicable apart absent. pool_case() now outputs number raw (raw_in_src) valid (valid_in_src) entries source.","code":""}]
