[{"path":"https://kevinhzq.github.io/healthdb/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 healthdb authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://kevinhzq.github.io/healthdb/articles/healthdb.html","id":"sec-what-it-does","dir":"Articles","previous_headings":"","what":"What it does","title":"Introduction to healthdb","text":"package designed identifying disease cases admin data epidemiological studies. implementation focused code readability re-usability. Three types functions included: Interactive functions (e.g., identify_row(), exclude(), fetch_var()) based filter joins dplyr tweaks fix SQL translation add features natively support SQL. also work local data.frame, use ‘data.table’ package (vignette(\"datatable-intro\", package = \"data.table\")) speed processing time large data. functions flexible dplyr::filter(), general enough useful even outside health research. Call-building functions (e.g., build_def(), execute_def()) facilitate batch execution re-use case definitions. essence, build_def creates codes definitions (chain interactive functions, e.g., define_case()) immediately ran. execute_def runs built definitions different input data. Miscellaneous functions computing age compute_duration(), collapsing records within time range one episode collapse_episode(), (-going effort). functions built-checks signalling things might go wrong, e.g., missing values calculated ages.","code":""},{"path":"https://kevinhzq.github.io/healthdb/articles/healthdb.html","id":"motivation","dir":"Articles","previous_headings":"What it does","what":"Motivation","title":"Introduction to healthdb","text":"health research surveillance, identifying diseases events administrative databases often initial step. However, crafting case-finding algorithms complex task. Existing algorithms, often written SAS experienced analysts, can complex difficult decipher growing number analysts trained primarily R. algorithms may also affect performance depend Data Step SAS, due lack translation Data Step SQL. can result SAS downloading data remote database local machine, leading poor performance handling large, population-based databases. ‘healthdb’ R package created address challenges. minimizes need download data offers easy--use interface working healthcare databases. also includes capabilities supported ‘SQL’, matching strings ‘stringr’ style regular expressions, can compute comorbidity scores (compute_comorbidity()) directly database server. vignette present example common use cases.","code":""},{"path":"https://kevinhzq.github.io/healthdb/articles/healthdb.html","id":"sec-installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Introduction to healthdb","text":"Simply run: need following packages demo.","code":"install.packages(\"healthdb\") library(dplyr) library(dbplyr) library(lubridate) library(glue) library(purrr) library(healthdb)"},{"path":"https://kevinhzq.github.io/healthdb/articles/healthdb.html","id":"sec-intended-use-case","dir":"Articles","previous_headings":"","what":"Intended use case","title":"Introduction to healthdb","text":"Consider case definition substance use disorder (SUD) British Columbia Centre Disease Control’s Chronic Disease Dashboard, One hospitalization substance use disorder diagnostic code, Two physician visits substance use disorder diagnostic code within one year. going implement definition. First, let’s make demo data sets two sources: Physician claims multiple columns ICD-9 diagnostic codes Hospitalization ICD-10 codes","code":"# make_test_dat() makes either a toy data.frame or database table in memory with known number of rows that satisfy the query we will show later claim_db <- make_test_dat(vals_kept = c(\"303\", \"304\", \"305\", \"291\", \"292\", glue(\"30{30:59}\"), glue(\"29{10:29}\"), noise_val = c(\"999\", \"111\")), type = \"database\")  # this is a database table # note that in-memory SQLite database stores dates as numbers claim_db %>% head() #> # Source:   SQL [?? x 6] #> # Database: sqlite 3.51.1 [:memory:] #>     uid clnt_id dates diagx diagx_1 diagx_2 #>   <int>   <int> <dbl> <chr> <chr>   <chr>   #> 1    25       3 17909 3030  2921    NA      #> 2    46       4 18497 2925  3047    2925    #> 3    79       5 16559 999   999     NA      #> 4    40       5 17134 3056  3042    NA      #> 5    63       5 17213 999   999     999     #> 6    77       5 17976 999   NA      NA hosp_df <- make_test_dat(vals_kept = c(glue(\"F{10:19}\"), glue(\"F{100:199}\"), noise_val = \"999\"), type = \"data.frame\")  # this is a local data.frame/tibble hosp_df %>% head() #>   uid clnt_id      dates diagx diagx_1 diagx_2 #> 1 100       1 2015-02-01   999     999     999 #> 2  85       1 2017-07-17   999    <NA>     999 #> 3   3       1 2019-06-17  F133    F159     999 #> 4  65       2 2019-01-08   999    <NA>     999 #> 5  52       2 2019-06-01   999    <NA>    <NA> #> 6  75       3 2016-07-11   999    <NA>    <NA>  # convert Date to numeric to be consistent with claim_db hosp_df <- hosp_df %>%   mutate(dates = julian(dates))"},{"path":"https://kevinhzq.github.io/healthdb/articles/healthdb.html","id":"interactive-functions","dir":"Articles","previous_headings":"","what":"Interactive functions","title":"Introduction to healthdb","text":"Let’s focus physician claims. Extracting clients least two records within year difficult, involves steps. codes look like following using dplyr, however, work : 1. SQL support multiple patterns one LIKE operation, 2. dbply currently issue translating n_distinct. ’s use healthdb achieve steps: Identify rows contains target codes. Use ?identify_row see list supported matching types. Bonus: remove clients exclusion codes step substance use disorder definition, disease definitions often require exclusion ICDs contradicts ones interest. Let’s say want remove clients code “111” . first identify “111” source, exclude clients output previous step’s result. exclude() take either data set (via excl argument) expression (condition argument) input. former, performs anti join matching argument (see dplyr::join_by()). latter, opposite filter, .e., filter(!(some_expression)). Restrict number records per client Restrict temporal pattern diagnoses restrict_date() supports complicated patterns like n diagnoses least days apart within j years. Note SQL interpret order dates, result deterministic duplicate dates within client. Therefore, unique row id (uid) supplied get consistent result. Fetch variables tables matching common keys point, result query downloaded. Hopefully, data shrunken manageable size collection. data now contains diagnoses probably enough analyses. Let’s say want gather client demographics age sex sources. certainly can done multiple dplyr::left_join() calls. provide fetch_var() function make codes concise. Note input must named object pipe (.e., don’t data %>% some_action %>% fetch_var()).","code":"## not run claim_db %>%   # identify the target codes   filter(if_any(starts_with(\"diagx\"), ~ str_like(., c(\"291%\", \"292%\", \"303%\", \"304%\", \"305%\")))) %>%   # each clnt has at least 2 records on different dates   group_by(clnt_id) %>%   # the n_distinct step is mainly for reducing computation in the next step   filter(n_distinct(dates) >= 2) %>%   # any two dates within one year?   filter((max(dates) - min(dates)) <= 365) ## end result1 <- claim_db %>%   identify_row( vars = starts_with(\"diagx\"), match = \"start\", vals = c(291:292, 303:305)   ) #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value satisfied SQL LIKE pattern: 291% OR 292% OR 303% OR 304% OR 305% #> ℹ To see the final query generated by 'dbplyr', use dplyr::show_query() on the output. #> To extract the SQL string, use dbplyr::remote_query(). result2 <- result1 %>%   exclude( excl = identify_row(claim_db, starts_with(\"diagx\"), \"in\", \"111\"), by = \"clnt_id\"   ) #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value exactly matched values in set: \"111\" #> ℹ Exclude records in `data` through anti_join with `excl` matching on (by argument): \"clnt_id\" result3 <- result2 %>% restrict_n(   clnt_id = clnt_id,   n_per_clnt = 2,   count_by = dates,   # here we use filter mode to remove records that failed the restriction   mode = \"filter\" ) #> ℹ Apply restriction that each client must have at least 2 records with #> distinct dates. Clients/groups which did not met the condition were excluded. result4 <- result3 %>% restrict_date(   clnt_id = clnt_id,   date_var = dates,   n = 2,   within = 365,   uid = uid,   # here we use flag mode to flag records that met the restriction instead of removing those   mode = \"flag\" ) #> ℹ Apply restriction that each client must have 2 records that were #> within 365 days. Records that met the condition were flagged. # Class of result4 class(result4) #> [1] \"tbl_SQLiteConnection\" \"tbl_dbi\"              \"tbl_sql\"              #> [4] \"tbl_lazy\"             \"tbl\"  # execute query and download the result result_df <- result4 %>% collect()  # Number of rows in source nrow(claim_db %>% collect()) #> [1] 100  # Number of rows in the current result nrow(result_df) #> [1] 27 # make two look up tables age_tab <- data.frame(   clnt_id = 1:50,   age = sample(1:90, 50),   sex = sample(c(\"F\", \"M\"), 50, replace = TRUE) ) address_tab <- data.frame(   clnt_id = rep(1:50, 5), year = rep(2016:2020, each = 50),   area_code = sample(0:200, 50, replace = TRUE) )  # get year from dates for matching  result_df <- result_df %>% mutate(year = lubridate::year(as.Date(dates, origin = \"1970-01-01\")))  # note that keys must be present in all tables fetch_var(result_df,   keys = c(clnt_id, year),   linkage = list( # the formula means from_table ~ get_variable # |clnt_id means matching on clnt_id only age_tab ~ c(age, sex) | clnt_id, address_tab ~ area_code   ) ) %>%   select(uid, clnt_id, dates, age, sex, area_code) %>%   head() #> # A tibble: 6 × 6 #>     uid clnt_id dates   age sex   area_code #>   <int>   <int> <dbl> <int> <chr>     <int> #> 1     1      18 16988     4 M           193 #> 2    34      18 17810     4 M           193 #> 3    45      20 16517    62 M            NA #> 4    39      20 17305    62 M           154 #> 5    33      21 16451     8 F            NA #> 6    50      21 16818     8 F           196"},{"path":"https://kevinhzq.github.io/healthdb/articles/healthdb.html","id":"call-building-functions","dir":"Articles","previous_headings":"","what":"Call-building functions","title":"Introduction to healthdb","text":"complete definition, need repeat process shown hospitalization data. studies may use handful data sources define sample. packed steps 1-4 one function define_case(), provide tools perform batch execution different data parameters meet needs. Let’s look inside fn_call list column. Two calls define_case() made different parameters. data arguments left empty purpose re-usability. example, may want repeat analysis data different regions study periods. Executing definition simply call execute_def(). verbose option turned options(healthdb.verbose = FALSE), output message explain done. append multiple build_def() outputs together execute . Definition source labels added result identify outputs different calls. Let’s check results! point, result claim database (result[[1]]) collected locally. collect manually, filtering, combine result hospitalization data way want. just need simple row bind, bind_source() convenient naming feature. pool_case() goes steps row bind. also filters records valid flags can summarize client/group. Since decide variables summarized advance, output may flexible enough meet needs.","code":"# build the full definition of SUD sud_def <- build_def(   # name of definition   def_lab = \"SUD\",   # place holder names for sources   src_labs = c(\"claim\", \"hosp\"),   def_fn = define_case, # you could alter it and supply your own function   # below are argumets of define_case   fn_args = list(     # if length = 1, the single element will be use for every source     vars = list(starts_with(\"diagx\")),     match = \"start\", # match ICD starts with vals     vals = list(c(291:292, 303:305), glue(\"F{10:19}\")),     clnt_id = clnt_id,     n_per_clnt = c(2, 1),     date_var = dates,     within = c(365, NULL),     uid = uid,     mode = \"flag\"   ) )  sud_def #> # A tibble: 2 × 5 #>   def_lab src_labs def_fn      fn_args          fn_call    #>   <chr>   <chr>    <chr>       <list>           <list>     #> 1 SUD     claim    define_case <named list [9]> <language> #> 2 SUD     hosp     define_case <named list [9]> <language> sud_def$fn_call #> [[1]] #> define_case(data = , vars = starts_with(\"diagx\"), match = \"start\",  #>     vals = c(291:292, 303:305), clnt_id = clnt_id, n_per_clnt = 2,  #>     date_var = dates, within = 365, uid = uid, mode = \"flag\") #>  #> [[2]] #> define_case(data = , vars = starts_with(\"diagx\"), match = \"start\",  #>     vals = glue(\"F{10:19}\"), clnt_id = clnt_id, n_per_clnt = 1,  #>     date_var = dates, within = NULL, uid = uid, mode = \"flag\") # execute the definition result_list <- sud_def %>%   execute_def(with_data = list(     claim = claim_db,     hosp = hosp_df   )) #>  #> Actions for definition SUD using source claim_db: #> → --------------Inclusion step-------------- #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value satisfied SQL LIKE pattern: 291% OR 292% OR 303% OR 304% OR 305% #> → --------------No. rows restriction-------------- #>  #> ℹ Apply restriction that each client must have at least 2 records with distinct dates. Records that met the condition were flagged. #> → --------------Time span restriction-------------- #>  #> ℹ Apply restriction that each client must have 2 records that were within 365 days. Records that met the condition were flagged. #> → -------------- Output all records-------------- #>  #>  #> Actions for definition SUD using source hosp_df: #>  #> → --------------Inclusion step-------------- #>  #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value satisfied regular expression: ^F10|^F11|^F12|^F13|^F14|^F15|^F16|^F17|^F18|^F19 #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other vars columns):  #>  999  F10 F101 F103 F104 F105 F107 F108 F109 F111 F112 F113 F114 F115 F116 F117  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #> F118 F119  F12 F121 F122 F123 F124 F125 F128 F129  F13 F132 F133 F134 F135 F137  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #> F138  F14 F140 F141 F143 F144 F145 F146 F147  F15 F154 F155 F159  F16 F160 F161  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #> F162 F164 F165 F166 F168  F17 F170 F172 F173 F174 F175 F176 F179 F181 F183 F184  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #> F185 F187 F188 F189  F19 F191 F192 F193 F196 F197 F198 NA's  #>    1    1    1    1    1    1    1    1    1    1    1    1 #> → -------------- Output all records-------------- # view the results purrr::walk(result_list, ~ head(.) %>% print()) #> # Source:   SQL [?? x 10] #> # Database: sqlite 3.51.1 [:memory:] #>   def   src     uid clnt_id dates diagx diagx_1 diagx_2 flag_restrict_n #>   <chr> <chr> <int>   <int> <dbl> <chr> <chr>   <chr>             <int> #> 1 SUD   claim    25       3 17909 3030  2921    NA                    0 #> 2 SUD   claim    46       4 18497 2925  3047    2925                  0 #> 3 SUD   claim    40       5 17134 3056  3042    NA                    0 #> 4 SUD   claim    10       8 17237 2912  3057    999                   0 #> 5 SUD   claim    41      12 17520 3047  3049    2915                  0 #> 6 SUD   claim    22      13 18489 3045  3042    NA                    0 #> # ℹ 1 more variable: flag_restrict_date <int> #>   def  src uid clnt_id dates diagx diagx_1 diagx_2 #> 1 SUD hosp   3       1 18064  F133    F159     999 #> 2 SUD hosp  38       4 16625  F191    F147     999 #> 3 SUD hosp  17       4 17279  F114    F154     999 #> 4 SUD hosp  30       5 16614  F101    F107    <NA> #> 5 SUD hosp  27       5 17079  F165    F174    <NA> #> 6 SUD hosp  24       5 17414  F118    F111    <NA> bind_source(result_list,   # output_name = c(names in the list elements)   src = \"src\",   uid = \"uid\",   clnt_id = \"clnt_id\",   flag = c(\"flag_restrict_date\", NA),   # force_proceed is needed to collect remote tables to local memory   force_proceed = TRUE ) #> # A tibble: 100 × 5 #>    src_No src     uid clnt_id  flag #>     <int> <chr> <int>   <int> <int> #>  1      1 claim    25       3     0 #>  2      1 claim    46       4     0 #>  3      1 claim    40       5     0 #>  4      1 claim    10       8     0 #>  5      1 claim    41      12     0 #>  6      1 claim    22      13     0 #>  7      1 claim     3      15     0 #>  8      1 claim    14      16     0 #>  9      1 claim    26      17     0 #> 10      1 claim     1      18     0 #> # ℹ 90 more rows pool_case(result_list,   def = sud_def,   # your could skip summary with output_lvl = \"raw\"   output_lvl = \"clnt\",   # include records only from sources having valid records, see function documentation for more detail and other options   include_src = \"has_valid\",   force_proceed = TRUE ) #> # A tibble: 29 × 10 #>    def   clnt_id first_valid_date first_valid_src last_entry_date last_entry_src #>    <chr>   <int>            <dbl> <chr>                     <dbl> <chr>          #>  1 SUD         1            18064 hosp                      18064 hosp           #>  2 SUD         4            16625 hosp                      17279 hosp           #>  3 SUD         5            16614 hosp                      17414 hosp           #>  4 SUD         7            17700 hosp                      17865 hosp           #>  5 SUD         8            17821 hosp                      18135 hosp           #>  6 SUD         9            17637 hosp                      18344 hosp           #>  7 SUD        11            17675 hosp                      18395 hosp           #>  8 SUD        12            17888 hosp                      17888 hosp           #>  9 SUD        13            18342 hosp                      18342 hosp           #> 10 SUD        16            18088 hosp                      18088 hosp           #> # ℹ 19 more rows #> # ℹ 4 more variables: raw_in_claim <dbl>, raw_in_hosp <dbl>, #> #   valid_in_claim <int>, valid_in_hosp <int>"},{"path":"https://kevinhzq.github.io/healthdb/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kevin Hu. Author, maintainer, copyright holder.","code":""},{"path":"https://kevinhzq.github.io/healthdb/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hu K (2026). healthdb: Working Healthcare Databases. R package version 0.5.0, https://github.com/KevinHzq/healthdb.","code":"@Manual{,   title = {healthdb: Working with Healthcare Databases},   author = {Kevin Hu},   year = {2026},   note = {R package version 0.5.0},   url = {https://github.com/KevinHzq/healthdb}, }"},{"path":"https://kevinhzq.github.io/healthdb/index.html","id":"healthdb-","dir":"","previous_headings":"","what":"Working with Healthcare Databases","title":"Working with Healthcare Databases","text":"goal ‘healthdb’ provide set tools identifying diseases events healthcare database preparing data epidemiological studies. features abilities natively support database, matching strings ‘stringr’ style regular expression using ‘LIKE’ operator multiple patterns vector. Three types functions included: interactive functions – customizing complex definitions; call building functions – batch execution simple definition; miscellaneous functions – data wrangling, computing age comorbidity index, etc. package tested SQL Server SQLite access SQL dialects. Please report bugs encounter issues dialects. Administrative health data often stored SQL database strict security measures may disable permission write temporary tables. Writing queries without able cache intermediate results challenging, especially data large downloaded database R (.e., local memory) without filtering process. package leverages ‘dbplyr’, particularly ability chain subqueries, order implement common disease definition one-shot big query. Outputs fully compatible ‘dplyr’ functions. Common disease definitions often form n primary care/hospitalization/prescription records International Classification Diseases (ICD) codes within time span. See example implementing case definition.","code":""},{"path":"https://kevinhzq.github.io/healthdb/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Working with Healthcare Databases","text":"Install CRAN: also install development version GitHub :","code":"install.packages(\"healthdb\") # install.packages(\"devtools\") devtools::install_github(\"KevinHzq/healthdb\")"},{"path":"https://kevinhzq.github.io/healthdb/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Working with Healthcare Databases","text":"going implement following case definition: One hospitalization substance use disorder (SUD) ICD-9 diagnostic code, Two physician claims substance use disorder ICD-10 diagnostic code within one year. get started, please see connect database write query ‘dbplyr’ don’t experience working database R. First, let’s make demo data sets two sources: Physician claims Hospitalization ’s use healthdb implement SUD definition : Identify rows contains target codes claim database Restrict number records per client Restrict temporal pattern diagnoses Repeat steps hospitalization row bind results. output functions, including identify_row(), exclude(), restrict_n(), restrict_date() , can piped ‘dplyr’ functions manipulations. Therefore, wrangling along ‘dplyr’ provide maximum flexibility implementing complex algorithms. However, code look repetitive multiple data sources involved. See introduction vignette (vignette(\"healthdb\")) much concise way work multiple sources definitions (‘Call-building functions’ section).","code":"library(healthdb) library(tidyverse)  # make_test_dat() makes either a toy data.frame or database table in memory with known number of rows that satisfy the query we will show later claim_db <- make_test_dat(vals_kept = c(\"303\", \"304\", \"305\", \"291\", \"292\", str_glue(\"30{30:59}\"), str_glue(\"29{10:29}\"), noise_val = c(\"999\", \"111\")), type = \"database\")  # this is a database table # note that in-memory SQLite database stores dates as numbers claim_db %>% head() #> # Source:   SQL [?? x 6] #> # Database: sqlite 3.51.0 [:memory:] #>     uid clnt_id dates diagx diagx_1 diagx_2 #>   <int>   <int> <dbl> <chr> <chr>   <chr>   #> 1    59       1 16650 999   <NA>    <NA>    #> 2    14       1 17100 3046  3058    <NA>    #> 3    65       1 17381 999   <NA>    <NA>    #> 4    19       1 17948 2916  2915    999     #> 5    71       1 18479 999   999     999     #> 6    66       2 16553 999   <NA>    999 hosp_df <- make_test_dat(vals_kept = c(str_glue(\"F{10:19}\"), str_glue(\"F{100:199}\"), noise_val = \"999\"), type = \"data.frame\")  # this is a local data.frame/tibble hosp_df %>% head() #>   uid clnt_id      dates diagx diagx_1 diagx_2 #> 1  96       1 2016-01-04   999     999     999 #> 2 100       1 2020-09-15   999    <NA>    <NA> #> 3  79       1 2020-12-26   999     999    <NA> #> 4  15       2 2019-08-24  F185    F170    <NA> #> 5  48       2 2020-02-12  F102    F138    F180 #> 6  10       3 2016-02-06  F163    F174     999 result1 <- claim_db %>%   identify_row( vars = starts_with(\"diagx\"), match = \"start\", vals = c(291:292, 303:305)   ) #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value satisfied SQL LIKE pattern: 291% OR 292% OR 303% OR 304% OR 305% #> ℹ To see the final query generated by 'dbplyr', use dplyr::show_query() on the output. #> To extract the SQL string, use dbplyr::remote_query(). result2 <- result1 %>% restrict_n(   clnt_id = clnt_id,   n_per_clnt = 2,   count_by = dates,   # here we use filter mode to remove records that failed the restriction   mode = \"filter\" ) #> ℹ Apply restriction that each client must have at least 2 records with distinct #> dates. Clients/groups which did not met the condition were excluded. result2 %>% head() #> # Source:   SQL [?? x 7] #> # Database: sqlite 3.51.0 [:memory:] #>     uid clnt_id dates diagx diagx_1 diagx_2 flag_restrict_n #>   <int>   <int> <dbl> <chr> <chr>   <chr>             <int> #> 1    14       1 17100 3046  3058    <NA>                  1 #> 2    19       1 17948 2916  2915    999                   1 #> 3    36       3 17235 3047  3037    999                   1 #> 4    37       3 17984 3055  292     <NA>                  1 #> 5    16       3 18169 3051  999     <NA>                  1 #> 6    49       5 17935 3051  2922    3052                  1 result3 <- result2 %>% restrict_date(   clnt_id = clnt_id,   date_var = dates,   n = 2,   within = 365,   uid = uid,   # here we use flag mode to flag records that met the restriction instead of removing those   mode = \"flag\" ) #> ℹ Apply restriction that each client must have 2 records that were within 365 #> days. Records that met the condition were flagged. result3 %>% head() #> # Source:   SQL [?? x 8] #> # Database: sqlite 3.51.0 [:memory:] #>     uid clnt_id dates diagx diagx_1 diagx_2 flag_restrict_n flag_restrict_date #>   <int>   <int> <dbl> <chr> <chr>   <chr>             <int>              <int> #> 1    14       1 17100 3046  3058    <NA>                  1                  0 #> 2    19       1 17948 2916  2915    999                   1                  0 #> 3    36       3 17235 3047  3037    999                   1                  0 #> 4    37       3 17984 3055  292     <NA>                  1                  1 #> 5    16       3 18169 3051  999     <NA>                  1                  0 #> 6    49       5 17935 3051  2922    3052                  1                  1"},{"path":"https://kevinhzq.github.io/healthdb/reference/bind_source.html","id":null,"dir":"Reference","previous_headings":"","what":"Row-bind a list of data.frames or remote tables with variable selection and renaming — bind_source","title":"Row-bind a list of data.frames or remote tables with variable selection and renaming — bind_source","text":"Row bind list data.frames remote tables variable selection renaming.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/bind_source.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Row-bind a list of data.frames or remote tables with variable selection and renaming — bind_source","text":"","code":"bind_source(data, ..., force_proceed = getOption(\"healthdb.force_proceed\"))"},{"path":"https://kevinhzq.github.io/healthdb/reference/bind_source.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Row-bind a list of data.frames or remote tables with variable selection and renaming — bind_source","text":"data list data.frame remote tables, e.g., output execute_def(). ... Named arguments variable included output. argument name new name output, right hand side argument character vector original names. name vector list elements data matched position. output variable came sources, fill name vector length equal number sources NA, e.g., var come second three sources, var = c(NA, 'nm_in_src2', NA). force_proceed logical whether ask user input order proceed remote tables needed collected binding. default FALSE let user aware downloading process may slow. Use options(healthdb.force_proceed = TRUE) suppress prompt .","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/bind_source.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Row-bind a list of data.frames or remote tables with variable selection and renaming — bind_source","text":"data.frame remote table containing combined rows input list variables specified ...","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/bind_source.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Row-bind a list of data.frames or remote tables with variable selection and renaming — bind_source","text":"","code":"df1 <- subset(iris, Species == \"setosa\") df2 <- subset(iris, Species == \"versicolor\") df3 <- subset(iris, Species == \"virginica\")  bind_source(list(df1, df2, df3),   s_l = \"Sepal.Length\",   s_w = \"Sepal.Width\",   p_l_setosa = c(\"Petal.Length\", NA, NA),   p_l_virginica = c(NA, NA, \"Petal.Length\") ) %>%   head() #>   src_No s_l s_w p_l_setosa p_l_virginica #> 1      1 5.1 3.5        1.4            NA #> 2      1 4.9 3.0        1.4            NA #> 3      1 4.7 3.2        1.3            NA #> 4      1 4.6 3.1        1.5            NA #> 5      1 5.0 3.6        1.4            NA #> 6      1 5.4 3.9        1.7            NA"},{"path":"https://kevinhzq.github.io/healthdb/reference/build_def.html","id":null,"dir":"Reference","previous_headings":"","what":"Build case definition function calls — build_def","title":"Build case definition function calls — build_def","text":"function assembles function calls supplied functions required arguments, leaving data argument empty easy re-use definition calls different data batch execution (see execute_def() detail). useful defining multiple diseases/events across multiple sources.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/build_def.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build case definition function calls — build_def","text":"","code":"build_def(def_lab, src_labs, def_fn = define_case, fn_args)"},{"path":"https://kevinhzq.github.io/healthdb/reference/build_def.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build case definition function calls — build_def","text":"def_lab single character label definition, e.g., disease. src_labs character vector place-holder names data sources used execute definition. def_fn list functions (default: define_case()) filter source data sets keep clients met case definition. length list either 1 equal length src_labs. length = 1, function applied sources; otherwise, def_fn match src_lab position. User can supply custom functions must put input data first argument name data. Note: Mixing define functions (e.g., define_case() define_case_with_age()) accept ... additional arguments may cause error. recommended use define function sources. fn_args named list arguments passing def_fn. element list name argument source-specific def_fn, element length also either 1 equal number sources. def_fn functions taking different sets arguments, include union one list.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/build_def.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build case definition function calls — build_def","text":"tibble number rows equal length src_labs, containing input arguments synthetic function call fn_call column.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/build_def.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build case definition function calls — build_def","text":"","code":"sud_def <- build_def(\"SUD\", # usually a disease name   src_lab = c(\"src1\", \"src2\"), # identify from multiple sources, e.g., hospitalization, ED visits.   # functions that filter the data with some criteria,   # including mean here for src2 as a trivial example   # to show only valid arguments will be in the call   def_fn = list(define_case, mean),   fn_args = list(     vars = list(starts_with(\"diagx\"), \"diagx_2\"),     match = \"start\", # \"start\" will be applied to all sources as length = 1     vals = list(c(\"304\"), c(\"305\")),     clnt_id = \"clnt_id\",     # c() can be used in place of list     # if this argument only takes one value for each source     n_per_clnt = c(2, 3),     x = list(1:10) # src2 with mean as def_fn will only accept this argument   ) )  # the result is a tibble sud_def #> # A tibble: 2 × 5 #>   def_lab src_labs def_fn      fn_args          fn_call      #>   <chr>   <chr>    <chr>       <named list>     <named list> #> 1 SUD     src1     define_case <named list [6]> <language>   #> 2 SUD     src2     mean        <named list [6]> <language>    # the fn_call column stores the code that can be ran with execute_def sud_def # fn_call #> # A tibble: 2 × 5 #>   def_lab src_labs def_fn      fn_args          fn_call      #>   <chr>   <chr>    <chr>       <named list>     <named list> #> 1 SUD     src1     define_case <named list [6]> <language>   #> 2 SUD     src2     mean        <named list [6]> <language>"},{"path":"https://kevinhzq.github.io/healthdb/reference/collapse_episode.html","id":null,"dir":"Reference","previous_headings":"","what":"Group records no more than n days apart as episodes — collapse_episode","title":"Group records no more than n days apart as episodes — collapse_episode","text":"function useful collapsing, e.g., medication dispensation hospitalization, records episodes records' dates n days gap apart. length gap can relaxed another grouping variable.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/collapse_episode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group records no more than n days apart as episodes — collapse_episode","text":"","code":"collapse_episode(   data,   clnt_id,   start_dt,   end_dt = NULL,   gap,   overwrite = NULL,   gap_overwrite = 99999,   .dt_trans = data.table::as.IDate,   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/collapse_episode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group records no more than n days apart as episodes — collapse_episode","text":"data data.frame remote table contains id date variables. clnt_id Column name subject/person ID. start_dt Column name starting date records. end_dt Column name end date records. default NULL assuming record last one day start date used calculate gaps records. gap number days used separate episodes. example, gap = 7 means collapsing records 7 days apart. Note number days apart calculated numeric difference two days, 2020-01-07 2020-01-01 considered 6 days apart. overwrite Column name grouping variable determining whether consecutive records related different gap value. example, dispensing records may original prescription number, different gap value can assigned situation, e.g., days two records > gap, records still belong prescription. gap_overwrite different gap value used related records. default 99999, practically means records overwrite variable collapsed. .dt_trans Function transform start_dt/end_dt. data.frame input . Default data.table::.IDate(). ... Additional arguments passing .dt_trans function. data.frame input .","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/collapse_episode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group records no more than n days apart as episodes — collapse_episode","text":"original data.frame remote table new columns indicating episode grouping. new variables include: epi_id: unique identifier episodes across whole data set epi_no: identifier episodes within client/group epi_seq: identifier records within episode epi_start/stop_dt: start end dates corresponding epi_id","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/collapse_episode.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group records no more than n days apart as episodes — collapse_episode","text":"","code":"# make toy data df <- make_test_dat() %>%   dplyr::select(clnt_id, dates)  head(df) #>   clnt_id      dates #> 1       2 2016-01-24 #> 2       3 2019-11-04 #> 3       4 2017-01-15 #> 4       5 2015-04-19 #> 5       5 2016-12-25 #> 6       5 2017-12-20  # collapse records no more than 90 days apart # end_dt could be absent then it is assumed to be the same as start_dt collapse_episode(df, clnt_id, start_dt = dates, gap = 90) #>     clnt_id      dates epi_id epi_no epi_seq epi_start_dt epi_stop_dt #> 1         2 2016-01-24      1      1       1   2016-01-24  2016-01-24 #> 2         3 2019-11-04      2      1       1   2019-11-04  2019-11-04 #> 3         4 2017-01-15      3      1       1   2017-01-15  2017-01-15 #> 4         5 2015-04-19      4      1       1   2015-04-19  2015-04-19 #> 5         5 2016-12-25      5      2       1   2016-12-25  2016-12-25 #> 6         5 2017-12-20      6      3       1   2017-12-20  2017-12-20 #> 7         5 2020-02-08      7      4       1   2020-02-08  2020-02-08 #> 8         6 2015-06-06      8      1       1   2015-06-06  2015-06-06 #> 9         6 2017-02-16      9      2       1   2017-02-16  2017-02-16 #> 10        6 2019-10-11     10      3       1   2019-10-11  2019-10-11 #> 11        7 2017-05-27     11      1       1   2017-05-27  2017-05-27 #> 12        7 2018-04-16     12      2       1   2018-04-16  2018-04-16 #> 13        7 2019-02-21     13      3       1   2019-02-21  2019-02-21 #> 14        7 2020-06-28     14      4       1   2020-06-28  2020-06-28 #> 15        8 2015-07-26     15      1       1   2015-07-26  2015-07-26 #> 16        8 2018-03-10     16      2       1   2018-03-10  2018-03-10 #> 17        9 2019-03-28     17      1       1   2019-03-28  2019-03-28 #> 18       10 2017-11-23     18      1       1   2017-11-23  2017-11-23 #> 19       10 2018-08-31     19      2       1   2018-08-31  2018-08-31 #> 20       10 2019-02-09     20      3       1   2019-02-09  2019-02-09 #> 21       11 2017-08-01     21      1       1   2017-08-01  2017-10-18 #> 22       11 2017-10-18     21      1       2   2017-08-01  2017-10-18 #> 23       11 2019-05-11     22      2       1   2019-05-11  2019-05-11 #> 24       11 2020-12-25     23      3       1   2020-12-25  2020-12-25 #> 25       12 2015-09-17     24      1       1   2015-09-17  2015-09-17 #> 26       12 2016-02-18     25      2       1   2016-02-18  2016-02-18 #> 27       12 2017-06-11     26      3       1   2017-06-11  2017-06-15 #> 28       12 2017-06-15     26      3       2   2017-06-11  2017-06-15 #> 29       12 2017-11-03     27      4       1   2017-11-03  2017-11-03 #> 30       13 2019-05-22     28      1       1   2019-05-22  2019-05-22 #> 31       13 2020-10-06     29      2       1   2020-10-06  2020-10-06 #> 32       14 2016-04-02     30      1       1   2016-04-02  2016-04-02 #> 33       15 2015-05-04     31      1       1   2015-05-04  2015-05-04 #> 34       16 2020-10-19     32      1       1   2020-10-19  2020-10-19 #> 35       17 2015-01-17     33      1       1   2015-01-17  2015-04-06 #> 36       17 2015-04-06     33      1       2   2015-01-17  2015-04-06 #> 37       17 2019-03-21     34      2       1   2019-03-21  2019-03-21 #> 38       18 2015-02-10     35      1       1   2015-02-10  2015-02-10 #> 39       18 2017-03-06     36      2       1   2017-03-06  2017-03-06 #> 40       18 2018-10-07     37      3       1   2018-10-07  2018-10-07 #> 41       19 2018-05-15     38      1       1   2018-05-15  2018-06-07 #> 42       19 2018-06-07     38      1       2   2018-05-15  2018-06-07 #> 43       20 2015-07-22     39      1       1   2015-07-22  2015-07-22 #> 44       20 2016-11-29     40      2       1   2016-11-29  2016-11-29 #> 45       20 2020-08-23     41      3       1   2020-08-23  2020-08-23 #> 46       21 2017-03-04     42      1       1   2017-03-04  2017-03-04 #> 47       21 2017-10-26     43      2       1   2017-10-26  2017-10-26 #> 48       21 2018-10-06     44      3       1   2018-10-06  2018-10-06 #> 49       21 2020-01-04     45      4       1   2020-01-04  2020-02-24 #> 50       21 2020-02-24     45      4       2   2020-01-04  2020-02-24 #> 51       22 2016-01-18     46      1       1   2016-01-18  2016-01-18 #> 52       22 2020-10-17     47      2       1   2020-10-17  2020-10-17 #> 53       23 2018-12-13     48      1       1   2018-12-13  2018-12-13 #> 54       23 2019-04-04     49      2       1   2019-04-04  2019-04-04 #> 55       23 2020-08-15     50      3       1   2020-08-15  2020-08-17 #> 56       23 2020-08-17     50      3       2   2020-08-15  2020-08-17 #> 57       24 2015-12-23     51      1       1   2015-12-23  2015-12-23 #> 58       24 2018-05-01     52      2       1   2018-05-01  2018-05-01 #> 59       25 2018-06-15     53      1       1   2018-06-15  2018-06-15 #> 60       25 2019-01-24     54      2       1   2019-01-24  2019-01-24 #> 61       26 2016-06-20     55      1       1   2016-06-20  2016-06-20 #> 62       26 2018-01-06     56      2       1   2018-01-06  2018-01-06 #> 63       26 2019-01-13     57      3       1   2019-01-13  2019-01-13 #> 64       27 2020-08-05     58      1       1   2020-08-05  2020-09-23 #> 65       27 2020-09-23     58      1       2   2020-08-05  2020-09-23 #> 66       28 2015-09-20     59      1       1   2015-09-20  2015-09-20 #> 67       28 2017-07-10     60      2       1   2017-07-10  2017-07-10 #> 68       28 2019-06-19     61      3       1   2019-06-19  2019-06-19 #> 69       28 2020-01-07     62      4       1   2020-01-07  2020-01-07 #> 70       29 2020-02-25     63      1       1   2020-02-25  2020-02-25 #> 71       31 2017-01-07     64      1       1   2017-01-07  2017-01-07 #> 72       32 2016-07-21     65      1       1   2016-07-21  2016-07-21 #> 73       32 2018-11-19     66      2       1   2018-11-19  2018-11-19 #> 74       33 2017-10-07     67      1       1   2017-10-07  2017-10-07 #> 75       33 2020-01-31     68      2       1   2020-01-31  2020-01-31 #> 76       34 2016-12-12     69      1       1   2016-12-12  2016-12-12 #> 77       34 2017-05-19     70      2       1   2017-05-19  2017-05-19 #> 78       34 2017-08-22     71      3       1   2017-08-22  2017-08-22 #> 79       35 2019-09-09     72      1       1   2019-09-09  2019-09-09 #> 80       38 2020-09-10     73      1       1   2020-09-10  2020-09-10 #> 81       41 2016-07-11     74      1       1   2016-07-11  2016-07-11 #> 82       41 2018-03-30     75      2       1   2018-03-30  2018-03-30 #> 83       41 2019-08-19     76      3       1   2019-08-19  2019-08-19 #> 84       42 2016-02-01     77      1       1   2016-02-01  2016-02-01 #> 85       42 2017-01-23     78      2       1   2017-01-23  2017-01-23 #> 86       42 2017-11-06     79      3       1   2017-11-06  2017-11-06 #> 87       42 2018-08-07     80      4       1   2018-08-07  2018-08-30 #> 88       42 2018-08-30     80      4       2   2018-08-07  2018-08-30 #> 89       42 2020-11-17     81      5       1   2020-11-17  2020-11-17 #> 90       43 2015-01-16     82      1       1   2015-01-16  2015-01-16 #> 91       44 2015-10-17     83      1       1   2015-10-17  2015-10-17 #> 92       44 2018-11-28     84      2       1   2018-11-28  2018-11-28 #> 93       45 2015-03-23     85      1       1   2015-03-23  2015-03-23 #> 94       46 2017-11-25     86      1       1   2017-11-25  2017-11-25 #> 95       46 2019-12-08     87      2       1   2019-12-08  2019-12-08 #> 96       47 2019-08-26     88      1       1   2019-08-26  2019-08-26 #> 97       48 2016-07-01     89      1       1   2016-07-01  2016-07-01 #> 98       48 2017-01-06     90      2       1   2017-01-06  2017-01-06 #> 99       48 2017-07-29     91      3       1   2017-07-29  2017-07-29 #> 100      48 2020-09-15     92      4       1   2020-09-15  2020-09-15"},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Elixhauser Comorbidity Index — compute_comorbidity","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"function computes unweighted Elixhauser Comorbidity Index data.frame remote table input. ICD codes used identify 31 disease categories Quan et al. (2005).","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"","code":"compute_comorbidity(   data,   vars,   icd_ver = c(\"ICD-10\", \"ICD-9-CM-3digits\", \"ICD-9-CM-5digits\"),   clnt_id,   uid = NULL,   sum_by = c(\"row\", \"clnt\"),   excl = NULL )"},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"data Data.frames remote tables (e.g., dbplyr::tbl_sql()) vars expression passing dplyr::select(). can quoted/unquoted column names, helper functions, dplyr::starts_with(). icd_ver One c(\"ICD-10\", \"ICD-9-CM-3digits\", \"ICD-9-CM-5digits\"). Specify ICD code version used data. ICD-10 ICD-9-CM 5 digits version Quan et al. (2005). ICD-9-CM 3 digits version adopted Manitoba Centre Health Policy. uses 3-digit 5-digit codes search. See web page cautions limitations 3 digit version data 3-digit codes (http://mchp-appserv.cpe.umanitoba.ca/viewConcept.php?printer=Y&conceptID=1436#CAUTIONS). clnt_id Grouping variable (quoted/unquoted). uid Variable name unique row identifier. necessary SQL produce consistent result based sorting. sum_by One \"row\" \"clnt\". \"row\" option computes total score row (default), \"clnt\" option summarizes total score clnt_id. disease categories counted calculation regardless multiple records category. excl character vector disease categories labels excluded total score calculation. useful categories exposure/outcome interest, goal measure comorbidity excluding disease. See detail list categories labels.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"data.frame remote table binary indicators categories columns.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"List disease categories - labels (quote): Congestive Heart Failure - \"chf\" Cardiac Arrhythmia - \"arrhy\" Valvular Disease - \"vd\" Pulmonary Circulation Disorders - \"pcd\" Peripheral Vascular Disorders - \"pvd\" Hypertension Uncomplicated - \"hptn_nc\" Hypertension complicated - \"hptn_C\" Paralysis - \"para\" Neurological Disorders - \"Othnd\" Chronic Pulmonary Disease - \"copd\" Diabetes Uncomplicated - \"diab_nc\" Diabetes Complicated - \"diab_c\" Hypothyroidism - \"hptothy\" Renal Failure - \"rf\" Liver Disease - \"ld\" Peptic Ulcer Disease excluding bleeding - \"pud_nb\" AIDS/HIV - \"hiv\" Lymphoma - \"lymp\" Metastatic Cancer - \"mets\" Solid Tumor without Metastasis - \"tumor\" Rheumatoid Arthritis/collagen - \"rheum_a\" Coagulopathy - \"coag\" Obesity - \"obesity\" Weight Loss - \"wl\" Fluid Electrolyte Disorders - \"fluid\" Blood Loss Anemia - \"bla\" Deficiency Anemia - \"da\" Alcohol Abuse - \"alcohol\" Drug Abuse - \"drug\" Psychoses - \"psycho\" Depression - \"dep\"","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"Quan H, Sundararajan V, Halfon P, Fong , Burnand B, Luthi JC, Saunders LD, Beck CA, Feasby TE, Ghali WA. Coding algorithms defining comorbidities ICD-9-CM ICD-10 administrative data. Med Care 2005;43(11):1130-1139.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"","code":"# make ICD-9 toy data df <- data.frame(   uid = 1:10, clnt_id = sample(1:3, 10, replace = TRUE),   diagx_1 = c(\"193\", \"2780\", \"396\", \"4254\", \"4150\", \"401\", \"401\", \"0932\", \"5329\", \"2536\"),   diagx_2 = c(NA, NA, \"72930\", \"V6542\", \"493\", \"405\", \"5880\", \"2409\", \"714\", NA) )  # compute Elixhauser Comorbidity Index by row # uid is needed for by row calculation # 3 categories were excluded in total_eci compute_comorbidity(df,   vars = starts_with(\"diagx\"),   icd_ver = \"ICD-9-CM-5digits\",   clnt_id = clnt_id, uid = uid,   excl = c(\"drug\", \"psycho\", \"dep\") ) #> # A tibble: 10 × 34 #>    clnt_id   uid   chf arrhy    vd   pcd   pvd hptn_nc hptn_c  para othnd  copd #>      <int> <int> <dbl> <dbl> <dbl> <dbl> <dbl>   <dbl>  <dbl> <dbl> <dbl> <dbl> #>  1       1     8     0     0     1     0     0       0      0     0     0     0 #>  2       1    10     0     0     0     0     0       0      0     0     0     0 #>  3       2     1     0     0     0     0     0       0      0     0     0     0 #>  4       2     2     0     0     0     0     0       0      0     0     0     0 #>  5       2     3     0     0     1     0     0       0      0     0     0     0 #>  6       2     5     0     0     0     1     0       0      0     0     0     1 #>  7       2     6     0     0     0     0     0       1      1     0     0     0 #>  8       2     9     0     0     0     0     0       0      0     0     0     0 #>  9       3     4     1     0     0     0     0       0      0     0     0     0 #> 10       3     7     0     0     0     0     0       1      0     0     0     0 #> # ℹ 22 more variables: diab_nc <dbl>, diab_c <dbl>, hptothy <dbl>, rf <dbl>, #> #   ld <dbl>, pud_nb <dbl>, hiv <dbl>, lymp <dbl>, mets <dbl>, tumor <dbl>, #> #   rheum_a <dbl>, coag <dbl>, obesity <dbl>, wl <dbl>, fluid <dbl>, bla <dbl>, #> #   da <dbl>, alcohol <dbl>, drug <dbl>, psycho <dbl>, dep <dbl>, #> #   total_eci <dbl>  # compute ECI by person compute_comorbidity(df,   vars = starts_with(\"diagx\"),   icd_ver = \"ICD-9-CM-5digits\",   clnt_id = clnt_id,   sum_by = \"clnt\" ) #> # A tibble: 3 × 33 #>   clnt_id   chf arrhy    vd   pcd   pvd hptn_nc hptn_c  para othnd  copd diab_nc #>     <int> <dbl> <dbl> <dbl> <dbl> <dbl>   <dbl>  <dbl> <dbl> <dbl> <dbl>   <dbl> #> 1       1     0     0     1     0     0       0      0     0     0     0       0 #> 2       2     0     0     1     1     0       1      1     0     0     1       0 #> 3       3     1     0     0     0     0       1      0     0     0     0       0 #> # ℹ 21 more variables: diab_c <dbl>, hptothy <dbl>, rf <dbl>, ld <dbl>, #> #   pud_nb <dbl>, hiv <dbl>, lymp <dbl>, mets <dbl>, tumor <dbl>, #> #   rheum_a <dbl>, coag <dbl>, obesity <dbl>, wl <dbl>, fluid <dbl>, bla <dbl>, #> #   da <dbl>, alcohol <dbl>, drug <dbl>, psycho <dbl>, dep <dbl>, #> #   total_eci <dbl>"},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_duration.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute duration between two dates — compute_duration","title":"Compute duration between two dates — compute_duration","text":"function meant data frame input used dplyr::mutate() compute age duration two character Date columns. vector breaks given, output converted factor labels generated automatically.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_duration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute duration between two dates — compute_duration","text":"","code":"compute_duration(   from,   to,   lower_brks = NULL,   unit = c(\"year\", \"day\", \"week\", \"month\"),   trans = FALSE,   .transfn = lubridate::ymd,   verbose = getOption(\"healthdb.verbose\"),   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_duration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute duration between two dates — compute_duration","text":"character Date vector start dates. character Date vector end dates. lower_brks numeric vector lower breaks passing base base::cut() function convert numeric result factor. level labels auto generated. example, level labels c(\"<19\", \"19-24\", \"25-34\", \"35-44\", \"45-54\", \"55+\") lower_brks = c(0, 19, 25, 35, 45, 55). Default NULL (conversion). unit character string specifying unit output. One \"year\" (default), \"day\", \"week\", \"month\". trans logical whether transform .transfn function .transfn function transforming inputs. Default lubridate::ymd(). verbose logical whether print summary warning missing values. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . ... Additional arguments passing base::cut().","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_duration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute duration between two dates — compute_duration","text":"numeric factor vector duration.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_duration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute duration between two dates — compute_duration","text":"","code":"# toy data n <- 5 df <- data.frame(   id = 1:n,   start_dt = sample(seq(as.Date(\"1970-01-01\"), as.Date(\"2000-12-31\"), by = 1), size = n),   end_dt = sample(seq(as.Date(\"2001-01-01\"), as.Date(\"2023-12-31\"), by = 1), size = n) )  # get age group at a cut-off df %>% dplyr::mutate(   age_grp = compute_duration(start_dt, \"2023-01-01\", lower_brks = c(0, 19, 25, 35, 45, 55)) ) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   28.50   34.41   43.42   39.98   44.86   48.72  #>   <19 19-24 25-34 35-44 45-54   55+  #>     0     0     2     2     1     0  #>   id   start_dt     end_dt age_grp #> 1  1 1988-08-05 2018-12-14   25-34 #> 2  2 1979-08-02 2021-10-26   35-44 #> 3  3 1974-04-14 2004-05-31   45-54 #> 4  4 1978-02-21 2023-12-28   35-44 #> 5  5 1994-07-02 2007-12-07   25-34  # compute gaps between two dates in weeks df %>% dplyr::mutate(   gap_wks = compute_duration(start_dt, end_dt, unit = \"week\") ) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   700.9  1572.1  1584.0  1690.6  2203.7  2392.3  #>   id   start_dt     end_dt   gap_wks #> 1  1 1988-08-05 2018-12-14 1584.0000 #> 2  2 1979-08-02 2021-10-26 2203.7143 #> 3  3 1974-04-14 2004-05-31 1572.1429 #> 4  4 1978-02-21 2023-12-28 2392.2857 #> 5  5 1994-07-02 2007-12-07  700.8571"},{"path":"https://kevinhzq.github.io/healthdb/reference/cut_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut the time period in one row into multiple rows by interval — cut_period","title":"Cut the time period in one row into multiple rows by interval — cut_period","text":"function cutting time periods segments, useful subsequent overlap joins. original period (per row) expanded multiple rows weeks, months, etc. data.frame input accepted output size greater input. Thus, remote tables collected running function optimal performance.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/cut_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut the time period in one row into multiple rows by interval — cut_period","text":"","code":"cut_period(   data,   start,   end,   len,   unit = c(\"day\", \"week\", \"month\", \"quarter\", \"year\"),   .dt_trans = NULL )"},{"path":"https://kevinhzq.github.io/healthdb/reference/cut_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut the time period in one row into multiple rows by interval — cut_period","text":"data Input data.frame row start end dates start Record start date column (unquoted) end Record end date column (unquoted) len integer, interval used divide record duration unit One \"day\" (default), \"week\", \"month\", \"quarter, \"year\" used combination len specify time length interval. .dt_trans Function transform start/end, lubridate::ymd(). Default NULL.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/cut_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut the time period in one row into multiple rows by interval — cut_period","text":"Data frame row now segment period defined c(start, end) original row. Original variables retained repeated segment plus new variables defining segment interval.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/cut_period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut the time period in one row into multiple rows by interval — cut_period","text":"","code":"# toy data df <- data.frame(sample_id = 1, period_id = 1, start_date = \"2015-01-01\", end_date = \"2019-12-31\")  # divide period into segments (multiple rows per period) df_seg <- cut_period(   data = df, start = start_date, end = end_date,   len = 1,   unit = \"year\",   .dt_trans = lubridate::ymd )  # categorize segment_id as factor df_seg$segment <- cut(df_seg$segment_id,   breaks = c(0, 1, 2, Inf),   labels = c(\"< 1 year\", \"1 - 2 years\", \"Remainder\") )  head(df_seg) #> # A tibble: 5 × 8 #>   sample_id period_id start_date end_date   segment_start segment_end segment_id #>       <dbl>     <dbl> <date>     <date>     <date>        <date>           <int> #> 1         1         1 2015-01-01 2019-12-31 2015-01-01    2015-12-31           1 #> 2         1         1 2015-01-01 2019-12-31 2016-01-01    2016-12-31           2 #> 3         1         1 2015-01-01 2019-12-31 2017-01-01    2017-12-31           3 #> 4         1         1 2015-01-01 2019-12-31 2018-01-01    2018-12-31           4 #> 5         1         1 2015-01-01 2019-12-31 2019-01-01    2019-12-31           5 #> # ℹ 1 more variable: segment <fct>"},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify diseases/events from administrative records — define_case","title":"Identify diseases/events from administrative records — define_case","text":"function composite identify_row(), exclude(), restrict_n(), restrict_date(). aimed implement common case definitions epidemiological studies using administrative database one-shot big query. intended use case definitions form , e.g., two physician visits diagnostic code least 30 days apart within two years. component functions mentioned chained following order arguments supplied: identify_row(vals) %>% exclude(identify_row(excl_vals), = clnt_id) %>% restrict_n() %>% restrict_date(). necessary steps chain ran arguments missing, see verbose output done. Note date_var supplied, n_per_clnt counted distinct dates instead number records.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify diseases/events from administrative records — define_case","text":"","code":"define_case(   data,   vars,   match = \"in\",   vals,   clnt_id,   n_per_clnt = 1,   date_var = NULL,   apart = NULL,   within = NULL,   uid = NULL,   excl_vals = NULL,   excl_args = NULL,   keep = c(\"all\", \"first\", \"last\"),   if_all = FALSE,   mode = c(\"flag\", \"filter\"),   force_collect = FALSE,   verbose = getOption(\"healthdb.verbose\"),   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify diseases/events from administrative records — define_case","text":"data Data.frames remote tables (e.g., dbplyr::tbl_sql()) vars expression passing dplyr::select(). can quoted/unquoted column names, helper functions, dplyr::starts_with(). match One \"\", \"start\", \"regex\", \"like\", \"\", \"glue_sql\". determines values matched. See identify_row() detail. vals Depending match, takes different input. See identify_row(). clnt_id Grouping variable (quoted/unquoted). n_per_clnt single number specifying minimum number group size. date_var Variable name (quoted/unquoted) dates interpreted. apart integer specifying minimum gap (days) adjacent dates draw. within integer specifying maximum time span (days) draw. uid Variable name unique row identifier. necessary SQL produce consistent result based sorting. excl_vals vals clients/groups values going removed result. intended exclusion criteria case definition. excl_args named list arguments passing second identify_row() call excl_vals. supplied, var, match if_all first call re-used. keep One : \"first\" (keeping client's earliest record), \"last\" (keeping latest), \"\" (keeping relevant records, default). Note \"first\"/\"last\" used \"flag\" mode. if_all logical whether combining predicates (multiple columns selected vars) instead . Default FALSE, e.g., var1 vals var2 vals. mode Either: \"flag\" - add new columns starting \"flag_\" indicating client met condition, \"filter\" - remove clients meet condition data. passed restrict_n() restrict_date(). Default \"flag\". force_collect logical whether force downloading result table local data.frame. Downloading data slow, user opt ; default FALSE. verbose logical whether printing explanation operation. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . ... Additional arguments, e.g., flag_at, passing restrict_date().","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify diseases/events from administrative records — define_case","text":"subset input data satisfied specified case definition.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify diseases/events from administrative records — define_case","text":"","code":"sample_size <- 30 df <- data.frame(   clnt_id = rep(1:3, each = 10),   service_dt = sample(seq(as.Date(\"2020-01-01\"), as.Date(\"2020-01-31\"), by = 1),     size = sample_size, replace = TRUE   ),   diagx = sample(letters, size = sample_size, replace = TRUE),   diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),   diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE) )  # define from one source define_case(df,   vars = starts_with(\"diagx\"), \"in\", vals = letters[1:4],   clnt_id = clnt_id, date_var = service_dt,   excl_args = list(if_all = TRUE),   # remove non-case   mode = \"filter\",   # keeping the first record   keep = \"first\" ) #> → --------------Inclusion step-------------- #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value exactly matched values in set: letters[1:4] #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other vars columns):  #>    a    b    c    d    e    f    h    i    j    m    n    q    r    s    u    v  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #>    w    z NA's  #>    1    1    1  #> → -------------- Output first records-------------- #> # A tibble: 3 × 5 #>   clnt_id service_dt diagx diagx_1 diagx_2 #>     <int> <date>     <chr> <chr>   <chr>   #> 1       1 2020-01-07 z     d       f       #> 2       2 2020-01-09 i     b       s       #> 3       3 2020-01-02 e     a       j        # multiple sources with purrr::pmap # arguments with length = 1 will be recycle to match the number of sources # wrap expressions/unquoted variables with bquote(), # or rlang:exprs() to prevent immediate evaluation, # or just use quoted variable names purrr::pmap(   list(     data = list(df, df),     vars = rlang::exprs(starts_with(\"diagx\")),     match = c(\"in\", \"start\"),     vals = list(letters[1:4], letters[5:10]),     clnt_id = list(bquote(clnt_id)), n_per_clnt = c(2, 3),     date_var = \"service_dt\",     excl_vals = list(letters[11:13], letters[14:16]),     excl_args = list(list(if_all = TRUE), list(if_all = FALSE))   ),   define_case ) #> → --------------Inclusion step-------------- #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value exactly matched values in set: c(\"a\", \"b\", \"c\", \"d\") #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other vars columns):  #>    a    b    c    d    e    f    h    i    j    m    n    q    r    s    u    v  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #>    w    z NA's  #>    1    1    1  #> → --------------Exclusion step-------------- #> ℹ Identify records with condition(s): #> • where all of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value exactly matched values in set: c(\"k\", \"l\", \"m\") #>  #> All unique value(s) and frequency in the result :  #> integer(0) #> ℹ Exclude records in `data` through anti_join with `excl` matching on (by argument): \"clnt_id\"  #> ℹ Of the 3 \"clnt_id\" in data, 0 were excluded. #> → --------------No. rows restriction-------------- #> ℹ Of the 3 clients in the input, 0 were flagged as 0 by restricting that each client must have at least 2 records with distinct service_dt #> → -------------- Output all records-------------- #> → --------------Inclusion step-------------- #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value satisfied regular expression: ^e|^f|^g|^h|^i|^j #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other vars columns):  #>    a    b    d    e    f    h    i    j    k    l    m    o    p    s    t    u  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #>    v    w    x    y    z NA's  #>    1    1    1    1    1    1  #> → --------------Exclusion step-------------- #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value satisfied regular expression: ^n|^o|^p #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other vars columns):  #> a b f i j m n o p r s u w x  #> 1 1 1 1 1 1 1 1 1 1 1 1 1 1  #> ℹ Exclude records in `data` through anti_join with `excl` matching on (by argument): \"clnt_id\"  #> ℹ Of the 3 \"clnt_id\" in data, 3 were excluded. #> → --------------No. rows restriction-------------- #> ℹ Of the 0 clients in the input, 0 were flagged as 0 by restricting that each client must have at least 3 records with distinct service_dt #> → -------------- Output all records-------------- #> [[1]] #>    clnt_id service_dt diagx diagx_1 diagx_2 flag_restrict_n #> 1        1 2020-01-27     a       q       m               1 #> 2        1 2020-01-07     z       d       f               1 #> 3        1 2020-01-18     h    <NA>       b               1 #> 4        1 2020-01-20     w       n       a               1 #> 5        1 2020-01-20     b       r       u               1 #> 6        2 2020-01-09     i       b       s               1 #> 7        2 2020-01-15     c    <NA>       c               1 #> 8        3 2020-01-02     e       a       j               1 #> 9        3 2020-01-20     a       v       j               1 #> 10       3 2020-01-03     n       b       a               1 #>  #> [[2]] #> [1] clnt_id         service_dt      diagx           diagx_1         #> [5] diagx_2         flag_restrict_n #> <0 rows> (or 0-length row.names) #>"},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case_with_age.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify diseases/events from administrative records with age restriction — define_case_with_age","title":"Identify diseases/events from administrative records with age restriction — define_case_with_age","text":"function extends standard case definition function define_case() allowing age-based filtering. See define_case() general description function . Note using function existing age variable, age determined time record. Records eligible age range remove interpreting temporal relationship records. words, age restriction applied restrict_date(). age restrictions based fixed time point (e.g., age baseline follow-), can done filtering input data output define_case() instead using function.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case_with_age.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify diseases/events from administrative records with age restriction — define_case_with_age","text":"","code":"define_case_with_age(   data,   vars,   match = \"in\",   vals,   clnt_id,   n_per_clnt = 1,   date_var = NULL,   apart = NULL,   within = NULL,   uid = NULL,   excl_vals = NULL,   excl_args = NULL,   keep = c(\"all\", \"first\", \"last\"),   if_all = FALSE,   mode = c(\"flag\", \"filter\"),   birth_date = NULL,   age = NULL,   age_range = NULL,   force_collect = FALSE,   verbose = getOption(\"healthdb.verbose\"),   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case_with_age.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify diseases/events from administrative records with age restriction — define_case_with_age","text":"data Data.frames remote tables (e.g., dbplyr::tbl_sql()) vars expression passing dplyr::select(). can quoted/unquoted column names, helper functions, dplyr::starts_with(). match One \"\", \"start\", \"regex\", \"like\", \"\", \"glue_sql\". determines values matched. See identify_row() detail. vals Depending match, takes different input. See identify_row(). clnt_id Grouping variable (quoted/unquoted). n_per_clnt single number specifying minimum number group size. date_var Variable name (quoted/unquoted) dates interpreted. apart integer specifying minimum gap (days) adjacent dates draw. within integer specifying maximum time span (days) draw. uid Variable name unique row identifier. necessary SQL produce consistent result based sorting. excl_vals vals clients/groups values going removed result. intended exclusion criteria case definition. excl_args named list arguments passing second identify_row() call excl_vals. supplied, var, match if_all first call re-used. keep One : \"first\" (keeping client's earliest record), \"last\" (keeping latest), \"\" (keeping relevant records, default). Note \"first\"/\"last\" used \"flag\" mode. if_all logical whether combining predicates (multiple columns selected vars) instead . Default FALSE, e.g., var1 vals var2 vals. mode Either: \"flag\" - add new columns starting \"flag_\" indicating client met condition, \"filter\" - remove clients meet condition data. passed restrict_n() restrict_date(). Default \"flag\". birth_date Optional. name column containing birth dates. Used calculate age age_range specified. Requires date_var supplied. Age calculated (date_var - birth_date)/365.25. age Optional. name column containing age values. Used directly age filtering age_range specified. age_range Optional. length 2 numeric vector c(min, max) specifying age range years. Use NA one-sided bounds (e.g., c(10, NA) age >= 10, c(NA, 65) age <= 65). least one non-NA value must provided. force_collect logical whether force downloading result table local data.frame. Downloading data slow, user opt ; default FALSE. verbose logical whether printing explanation operation. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . ... Additional arguments, e.g., mode, passing restrict_date().","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case_with_age.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify diseases/events from administrative records with age restriction — define_case_with_age","text":"subset input data satisfied specified case definition.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case_with_age.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify diseases/events from administrative records with age restriction — define_case_with_age","text":"","code":"sample_size <- 30 df <- data.frame(   clnt_id = rep(1:3, each = 10),   service_dt = sample(seq(as.Date(\"2020-01-01\"), as.Date(\"2020-01-31\"), by = 1),     size = sample_size, replace = TRUE   ),   diagx = sample(letters, size = sample_size, replace = TRUE),   diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),   diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE) )  # define from one source define_case_with_age(df,   vars = starts_with(\"diagx\"), \"in\", vals = letters[1:4],   clnt_id = clnt_id, date_var = service_dt,   excl_args = list(if_all = TRUE),   # remove non-case   mode = \"filter\",   # keeping the first record   keep = \"first\" ) #> → --------------Inclusion step-------------- #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value exactly matched values in set: letters[1:4] #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other vars columns):  #>    a    b    c    d    e    h    i    j    o    p    r    t    u    w    x    z  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #> NA's  #>    1  #> → -------------- Output first records-------------- #> # A tibble: 3 × 5 #>   clnt_id service_dt diagx diagx_1 diagx_2 #>     <int> <date>     <chr> <chr>   <chr>   #> 1       1 2020-01-03 j     u       a       #> 2       2 2020-01-12 o     d       e       #> 3       3 2020-01-07 j     c       x        # with age restriction using birth_date df_with_birth <- df df_with_birth$birth_dt <- as.Date(\"1990-01-01\") define_case_with_age(df_with_birth,   vars = starts_with(\"diagx\"), \"in\", vals = letters[1:4],   clnt_id = clnt_id, date_var = service_dt,   birth_date = birth_dt, age_range = c(18, 65),   mode = \"filter\" ) #> → --------------Inclusion step-------------- #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value exactly matched values in set: letters[1:4] #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other vars columns):  #>    a    b    c    d    e    h    i    j    o    p    r    t    u    w    x    z  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #> NA's  #>    1  #> → --------------Age restriction-------------- #> → -------------- Output all records-------------- #>    clnt_id service_dt diagx diagx_1 diagx_2   birth_dt #> 1        1 2020-01-16     c       w       c 1990-01-01 #> 2        1 2020-01-25     t       p       b 1990-01-01 #> 3        1 2020-01-03     j       u       a 1990-01-01 #> 4        2 2020-01-16     o       h       d 1990-01-01 #> 5        2 2020-01-12     o       d       e 1990-01-01 #> 6        2 2020-01-27     b       u       j 1990-01-01 #> 7        2 2020-01-18     z       z       a 1990-01-01 #> 8        3 2020-01-26     b       j       b 1990-01-01 #> 9        3 2020-01-16     d       i       h 1990-01-01 #> 10       3 2020-01-09     b       r    <NA> 1990-01-01 #> 11       3 2020-01-07     j       c       x 1990-01-01  # age restriction with one-sided bound (age >= 18 only) define_case_with_age(df_with_birth,   vars = starts_with(\"diagx\"), \"in\", vals = letters[1:4],   clnt_id = clnt_id, date_var = service_dt,   birth_date = birth_dt, age_range = c(18, NA),   mode = \"filter\" ) #> → --------------Inclusion step-------------- #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value exactly matched values in set: letters[1:4] #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other vars columns):  #>    a    b    c    d    e    h    i    j    o    p    r    t    u    w    x    z  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #> NA's  #>    1  #> → --------------Age restriction-------------- #> → -------------- Output all records-------------- #>    clnt_id service_dt diagx diagx_1 diagx_2   birth_dt #> 1        1 2020-01-16     c       w       c 1990-01-01 #> 2        1 2020-01-25     t       p       b 1990-01-01 #> 3        1 2020-01-03     j       u       a 1990-01-01 #> 4        2 2020-01-16     o       h       d 1990-01-01 #> 5        2 2020-01-12     o       d       e 1990-01-01 #> 6        2 2020-01-27     b       u       j 1990-01-01 #> 7        2 2020-01-18     z       z       a 1990-01-01 #> 8        3 2020-01-26     b       j       b 1990-01-01 #> 9        3 2020-01-16     d       i       h 1990-01-01 #> 10       3 2020-01-09     b       r    <NA> 1990-01-01 #> 11       3 2020-01-07     j       c       x 1990-01-01  # multiple sources with purrr::pmap # arguments with length = 1 will be recycle to match the number of sources # wrap expressions/unquoted variables with bquote(), # or rlang:exprs() to prevent immediate evaluation, # or just use quoted variable names purrr::pmap(   list(     data = list(df, df),     vars = rlang::exprs(starts_with(\"diagx\")),     match = c(\"in\", \"start\"),     vals = list(letters[1:4], letters[5:10]),     clnt_id = list(bquote(clnt_id)), n_per_clnt = c(2, 3),     date_var = \"service_dt\",     excl_vals = list(letters[11:13], letters[14:16]),     excl_args = list(list(if_all = TRUE), list(if_all = FALSE))   ),   define_case_with_age ) #> → --------------Inclusion step-------------- #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value exactly matched values in set: c(\"a\", \"b\", \"c\", \"d\") #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other vars columns):  #>    a    b    c    d    e    h    i    j    o    p    r    t    u    w    x    z  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #> NA's  #>    1  #> → --------------Exclusion step-------------- #> ℹ Identify records with condition(s): #> • where all of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value exactly matched values in set: c(\"k\", \"l\", \"m\") #>  #> All unique value(s) and frequency in the result :  #> integer(0) #> ℹ Exclude records in `data` through anti_join with `excl` matching on (by argument): \"clnt_id\"  #> ℹ Of the 3 \"clnt_id\" in data, 0 were excluded. #> → --------------No. rows restriction-------------- #> ℹ Of the 3 clients in the input, 0 were flagged as 0 by restricting that each client must have at least 2 records with distinct service_dt #> → -------------- Output all records-------------- #> → --------------Inclusion step-------------- #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value satisfied regular expression: ^e|^f|^g|^h|^i|^j #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other vars columns):  #>    a    b    c    d    e    f    g    h    i    j    k    l    o    p    r    t  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #>    u    w    x    y    z NA's  #>    1    1    1    1    1    1  #> → --------------Exclusion step-------------- #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value satisfied regular expression: ^n|^o|^p #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other vars columns):  #>    b    d    e    h    i    j    l    m    n    o    p    q    r    s    t    v  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #>    x    y    z NA's  #>    1    1    1    1  #> ℹ Exclude records in `data` through anti_join with `excl` matching on (by argument): \"clnt_id\"  #> ℹ Of the 3 \"clnt_id\" in data, 3 were excluded. #> → --------------No. rows restriction-------------- #> ℹ Of the 0 clients in the input, 0 were flagged as 0 by restricting that each client must have at least 3 records with distinct service_dt #> → -------------- Output all records-------------- #> [[1]] #>    clnt_id service_dt diagx diagx_1 diagx_2 flag_restrict_n #> 1        1 2020-01-16     c       w       c               1 #> 2        1 2020-01-25     t       p       b               1 #> 3        1 2020-01-03     j       u       a               1 #> 4        2 2020-01-16     o       h       d               1 #> 5        2 2020-01-12     o       d       e               1 #> 6        2 2020-01-27     b       u       j               1 #> 7        2 2020-01-18     z       z       a               1 #> 8        3 2020-01-26     b       j       b               1 #> 9        3 2020-01-16     d       i       h               1 #> 10       3 2020-01-09     b       r    <NA>               1 #> 11       3 2020-01-07     j       c       x               1 #>  #> [[2]] #> [1] clnt_id         service_dt      diagx           diagx_1         #> [5] diagx_2         flag_restrict_n #> <0 rows> (or 0-length row.names) #>"},{"path":"https://kevinhzq.github.io/healthdb/reference/exclude.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove rows based on conditions or another data set — exclude","title":"Remove rows based on conditions or another data set — exclude","text":"function combines dplyr::anti_join(), negation dplyr::filter(). second data set supplied excl argument, anti join performed; otherwise, data filtered expression given via condition argument, filter result turn removed using dplyr::setdiff().","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/exclude.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove rows based on conditions or another data set — exclude","text":"","code":"exclude(   data,   excl = NULL,   by = NULL,   condition = NULL,   verbose = getOption(\"healthdb.verbose\"),   report_on = NULL,   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/exclude.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove rows based on conditions or another data set — exclude","text":"data Data.frames remote tables (e.g., dbplyr::tbl_sql()). subset removed data. excl Data frames remote tables (e.g., 'dbplyr'). Rows/values present removed data match. passed dplyr::anti_join() second argument. Column names matched dplyr::anti_join(), expressions dplyr::join_by(). See dplyr::anti_join()'s argument detail. Default NULL setdiff(data, excl). condition expression passed dplyr::filter(). rows satisfy condition removed data. verbose logical whether printing explanation operation. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . report_on quoted/unquoted column name counting many distinct values removed data, e.g., counting many client IDs removed. Default NULL. ... Additional arguments passing dplyr::filter()/dplyr::anti_join() finer control matching, e.g., na action, -group filtering, etc.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/exclude.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove rows based on conditions or another data set — exclude","text":"data frame remote table subset data.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/exclude.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove rows based on conditions or another data set — exclude","text":"","code":"# exclude with condition cyl_not_4 <- exclude(mtcars, condition = cyl == 4, report_on = cyl) #> ℹ Exclude a subset of `data` that satisfies condition: cyl == 4  #> ℹ Consider being explicit about NA, e.g., condition = var == 'val' | is.na(var) #> ℹ Of the 3 cyl in data, 1 were excluded.  # exclude with another data exclude(mtcars, cyl_not_4, dplyr::join_by(cyl), report_on = cyl) #> ℹ Exclude records in `data` through anti_join with `excl` matching on (by argument): dplyr::join_by(cyl)  #> ℹ Of the 3 cyl in data, 2 were excluded. #>                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb #> Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1 #> Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2 #> Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2 #> Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1 #> Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2 #> Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1 #> Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1 #> Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1 #> Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2 #> Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2 #> Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2"},{"path":"https://kevinhzq.github.io/healthdb/reference/execute_def.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute parameterized case definitions — execute_def","title":"Execute parameterized case definitions — execute_def","text":"function executes function calls stored output tibble [build_def()] data objects supplied named list returns results list. intended facilitate re-use pre-defined calls different data.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/execute_def.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute parameterized case definitions — execute_def","text":"","code":"execute_def(   def,   with_data,   bind = FALSE,   force_proceed = getOption(\"healthdb.force_proceed\") )"},{"path":"https://kevinhzq.github.io/healthdb/reference/execute_def.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Execute parameterized case definitions — execute_def","text":"def tibble created [build_def()]. with_data named list elements form src_lab = data, 'src_lab' corresponds src_labs argument [build_def()] 'data' data object passed calls stored def. names (length) `with_data` must match unique values src_labs `def`. bind logical whether row-binding records multiple sources one table. Note binding may fail ways difficult anticipate advance, data type conflict (e.g., Date vs. character) variables name different sources. default FALSE. TRUE, behavior try return unbinded result failed. force_proceed logical whether ask user input order proceed remote tables needed collected binding. default FALSE let user aware downloading process may slow. Use options(healthdb.force_proceed = TRUE) suppress prompt .","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/execute_def.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Execute parameterized case definitions — execute_def","text":"single (bind = TRUE) list data.frames remote tables.","code":""},{"path":[]},{"path":"https://kevinhzq.github.io/healthdb/reference/execute_def.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Execute parameterized case definitions — execute_def","text":"","code":"# toy data sample_size <- 30 df <- data.frame(   clnt_id = rep(1:3, each = 10),   service_dt = sample(seq(as.Date(\"2020-01-01\"), as.Date(\"2020-01-31\"), by = 1),     size = sample_size, replace = TRUE   ),   diagx = sample(letters, size = sample_size, replace = TRUE),   diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),   diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE) )  # make df a database table db <- dbplyr::tbl_memdb(df)  # use build_def to make a toy definition sud_def <- build_def(\"SUD\", # usually a disease name   src_lab = c(\"src1\", \"src2\"), # identify from multiple sources, e.g., hospitalization, ED visits.   # functions that filter the data with some criteria   def_fn = define_case,   fn_args = list(     vars = starts_with(\"diagx\"),     match = \"start\", # \"start\" will be applied to all sources as length = 1     vals = list(c(\"304\"), c(\"305\")),     clnt_id = \"clnt_id\", # list()/c() could be omitted for single element     # c() can be used in place of list     # if this argument only takes one value for each source     n_per_clnt = c(2, 3)   ) )  # save the definition for re-use # saveRDS(sud_def, file = some_path)  sud_def %>% execute_def(with_data = list(src1 = df, src2 = db), force_proceed = TRUE) #>  #> Actions for definition SUD using source df: #> → --------------Inclusion step-------------- #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value satisfied regular expression: ^304 #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other vars columns):  #> integer(0) #> → --------------No. rows restriction-------------- #> ℹ Of the 0 clients in the input, 0 were flagged as 0 by restricting that each client must have at least 2 records  #> → -------------- Output all records-------------- #>  #> Actions for definition SUD using source db: #> → --------------Inclusion step-------------- #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value satisfied SQL LIKE pattern: 305% #> ℹ To see the final query generated by 'dbplyr', use dplyr::show_query() on the output. #> To extract the SQL string, use dbplyr::remote_query(). #>  #> This message is displayed once per session. #> → --------------No. rows restriction-------------- #> ℹ Apply restriction that each client must have at least 3 records. Records that met the condition were flagged. #> → -------------- Output all records-------------- #> $SUD.src1 #> [1] def             src             clnt_id         service_dt      #> [5] diagx           diagx_1         diagx_2         flag_restrict_n #> <0 rows> (or 0-length row.names) #>  #> $SUD.src2 #> # Source:   SQL [?? x 8] #> # Database: sqlite 3.51.1 [:memory:] #> # ℹ 8 variables: def <lgl>, src <lgl>, clnt_id <int>, service_dt <int>, #> #   diagx <chr>, diagx_1 <chr>, diagx_2 <chr>, flag_restrict_n <lgl> #>"},{"path":"https://kevinhzq.github.io/healthdb/reference/fetch_var.html","id":null,"dir":"Reference","previous_headings":"","what":"Get variables from multiple tables with common ID columns — fetch_var","title":"Get variables from multiple tables with common ID columns — fetch_var","text":"function fetches variables different tables linked common IDs. calls dplyr::left_join() multiple times various source tables (y argument join) gather variables. meant replace left_join() simplify syntax situation started table study sample wanted gather covariates different sources linked common client IDs, often case working healthcare databases. Caution: function intended one--one joins problematic know source caused one--many join changed number rows. data.frame input, error given one--many joins detected. However, checking expensive operation remote source. Therefore, database input, result checked.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/fetch_var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get variables from multiple tables with common ID columns — fetch_var","text":"","code":"fetch_var(data, keys, linkage, ...)"},{"path":"https://kevinhzq.github.io/healthdb/reference/fetch_var.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get variables from multiple tables with common ID columns — fetch_var","text":"data data.frame remote table (tbl_sql) must object pipe. used x argument left_join(). keys vector quoted/unquoted variable names, 'tidyselect' expression (see dplyr::select()). variables must present data used argument left_join(). y tables must subset . linkage list formulas form \"from_tab ~ get_vars|by_keys\": source table left-hand-side variables right-hand-side source table variables keys, use \"|\" RHS specify subset keys used. example, given keys 3 variables, list( y1 ~ tidyselect_expr1, y2 ~ tidyselect_expr2|key1 + key2) meaning: table y1 get variables picked tidyselect expression matching 3 keys; table y2 get variables matching key1 key2. ... Additional arguments, e.g., copy = TRUE, passing left_join().","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/fetch_var.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get variables from multiple tables with common ID columns — fetch_var","text":"data.frame remote table containing original columns x new variables matched tables based specified linkage.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/fetch_var.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get variables from multiple tables with common ID columns — fetch_var","text":"","code":"# make toy data size <- 30 n <- 10 df1 <- data.frame(   id = sample(1:n, size = size, replace = TRUE),   service_dt = sample(seq(as.Date(\"2020-01-01\"), as.Date(\"2022-01-31\"), by = 1),     size = size   ) ) %>%   dplyr::mutate(year = lubridate::year(service_dt)) df2 <- data.frame(   id = rep(1:n, size / n), year = rep(2020:2022, each = n),   status_1 = sample(0:1, size = size, replace = TRUE),   status_2 = sample(0:1, size = size, replace = TRUE) ) df3 <- data.frame(id = 1:n, sex = sample(c(\"F\", \"M\"), size = n, replace = TRUE))  # simple joins # note that for left_join(df1, df2), boths keys have to be used, # otherwise, error as the relation would not be one-to-one fetch_var(df1,   keys = c(id, year),   linkage = list(     df2 ~ starts_with(\"s\"), # match both keys without '|'     df3 ~ sex | id   ) # match by id only; otherwise failed because df3 has no year ) #>    id service_dt year status_1 status_2 sex #> 1   3 2021-04-06 2021        1        1   F #> 2   7 2020-05-30 2020        1        0   M #> 3   7 2020-12-12 2020        1        0   M #> 4   8 2020-05-01 2020        1        1   M #> 5   8 2020-08-17 2020        1        1   M #> 6   4 2020-08-23 2020        1        0   M #> 7   9 2021-06-10 2021        0        0   M #> 8   6 2021-06-28 2021        0        1   F #> 9   2 2021-02-25 2021        1        1   M #> 10  6 2020-10-30 2020        0        1   F #> 11 10 2021-10-07 2021        0        0   M #> 12  8 2020-12-09 2020        1        1   M #> 13  5 2022-01-29 2022        0        0   F #> 14  1 2021-09-21 2021        0        1   M #> 15  2 2021-09-28 2021        1        1   M #> 16  1 2022-01-22 2022        1        0   M #> 17  3 2020-08-14 2020        0        0   F #> 18  6 2021-03-20 2021        0        1   F #> 19  9 2021-02-10 2021        0        0   M #> 20  2 2021-05-02 2021        1        1   M #> 21  6 2021-02-08 2021        0        1   F #> 22  8 2021-04-30 2021        1        1   M #> 23  5 2021-02-28 2021        0        1   F #> 24  3 2020-03-02 2020        0        0   F #> 25 10 2021-06-06 2021        0        0   M #> 26  9 2021-01-11 2021        0        0   M #> 27  7 2020-03-03 2020        1        0   M #> 28  5 2021-04-17 2021        0        1   F #> 29  8 2020-04-02 2020        1        1   M #> 30 10 2021-09-11 2021        0        0   M  # example if some y is remote # make df2 as database table db2 <- dbplyr::tbl_memdb(df2)  fetch_var(df1,   keys = c(id, year),   linkage = list(     db2 ~ starts_with(\"s\"),     df3 ~ sex | id   ),   copy = TRUE # pass to left_join for forced collection of remote table ) #>    id service_dt year status_1 status_2 sex #> 1   3 2021-04-06 2021        1        1   F #> 2   7 2020-05-30 2020        1        0   M #> 3   7 2020-12-12 2020        1        0   M #> 4   8 2020-05-01 2020        1        1   M #> 5   8 2020-08-17 2020        1        1   M #> 6   4 2020-08-23 2020        1        0   M #> 7   9 2021-06-10 2021        0        0   M #> 8   6 2021-06-28 2021        0        1   F #> 9   2 2021-02-25 2021        1        1   M #> 10  6 2020-10-30 2020        0        1   F #> 11 10 2021-10-07 2021        0        0   M #> 12  8 2020-12-09 2020        1        1   M #> 13  5 2022-01-29 2022        0        0   F #> 14  1 2021-09-21 2021        0        1   M #> 15  2 2021-09-28 2021        1        1   M #> 16  1 2022-01-22 2022        1        0   M #> 17  3 2020-08-14 2020        0        0   F #> 18  6 2021-03-20 2021        0        1   F #> 19  9 2021-02-10 2021        0        0   M #> 20  2 2021-05-02 2021        1        1   M #> 21  6 2021-02-08 2021        0        1   F #> 22  8 2021-04-30 2021        1        1   M #> 23  5 2021-02-28 2021        0        1   F #> 24  3 2020-03-02 2020        0        0   F #> 25 10 2021-06-06 2021        0        0   M #> 26  9 2021-01-11 2021        0        0   M #> 27  7 2020-03-03 2020        1        0   M #> 28  5 2021-04-17 2021        0        1   F #> 29  8 2020-04-02 2020        1        1   M #> 30 10 2021-09-11 2021        0        0   M"},{"path":"https://kevinhzq.github.io/healthdb/reference/healthdb-package.html","id":null,"dir":"Reference","previous_headings":"","what":"healthdb: Working with Healthcare Databases — healthdb-package","title":"healthdb: Working with Healthcare Databases — healthdb-package","text":"system identifying diseases events healthcare databases preparing data epidemiological studies. includes capabilities supported 'SQL', matching strings 'stringr' style regular expressions, can compute comorbidity scores (Quan et al. (2005) doi:10.1097/01.mlr.0000182534.19832.83 ) directly database server. implementation based 'dbplyr' full 'tidyverse' compatibility.","code":""},{"path":[]},{"path":"https://kevinhzq.github.io/healthdb/reference/healthdb-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"healthdb: Working with Healthcare Databases — healthdb-package","text":"Maintainer: Kevin Hu kevin.hu@bccdc.ca (ORCID) [copyright holder]","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/identify_row.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify rows with a match — identify_row","title":"Identify rows with a match — identify_row","text":"Filter rows values satisfy specified conditions. functionality identical dplyr::filter() combined dplyr::if_any() dplyr::if_all(), used 'data.table' package vignette(\"datatable-intro\", package = \"data.table\") data.frame method, regular regular expression support remote database tables. motivation take away pain working databases often support regular expression 'LIKE' operator multiple string patterns.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/identify_row.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify rows with a match — identify_row","text":"","code":"identify_row(   data,   vars,   match = c(\"in\", \"start\", \"regex\", \"like\", \"between\", \"glue_sql\"),   vals,   if_all = FALSE,   verbose = getOption(\"healthdb.verbose\"),   query_only = TRUE,   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/identify_row.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify rows with a match — identify_row","text":"data Data.frames remote tables (e.g., dbplyr::tbl_sql()) vars expression passing dplyr::select(). can quoted/unquoted column names, helper functions, dplyr::starts_with(). match One \"\", \"start\", \"regex\", \"like\", \"\", \"glue_sql\". determines values matched. operations type: \"\": var %% vals (default) \"regex\": stringr::str_detect(var, vals). remote tables, unique values vars collected locally matching (may slow). \"like\": stringr::str_like(var, vals). remote tables, var LIKE val. \"start\": regex LIKE modified vals, e.g., \"^val1|^val2\" \"va1%|val2%\" \"\": dplyr::(var, val1, val2) \"glue_sql\": remote table , gives full control clause using dplyr::filter(dbplyr::sql(glue::glue_sql(...))) vals Depending match, takes different input: \"\": vector values (numeric/character/Date) \"start\": vector numeric/character modified regex LIKE pattern string adding \"^\" front \"%\" end \"regex\"/\"like\": string expression \"\": vector numeric date exactly two elements, e.g., c(lower, upper) \"glue_sql\": string SQL clause, passed glue::glue_sql(). See examples detail. if_all logical whether combining predicates (multiple columns selected vars) instead . Default FALSE, e.g., var1 vals var2 vals. verbose logical whether printing explanation result overview query. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . Result overview remote tables query executed immediately, thus result available summary without adding extra run (may slow) query. query_only logical whether keeping output remote table (Default TRUE) downloading query result tibble (FALSE). argument ignored input data data.frame/tibble. ... remote table method . Additional arguments passing glue::glue_sql() parameterized queries.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/identify_row.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify rows with a match — identify_row","text":"data.frame tbl_sql object depending input.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/identify_row.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify rows with a match — identify_row","text":"","code":"# applying to data.frame; both sepal length and width in range 3-5 identify_row(iris, starts_with(\"Sepal\"), \"between\", c(3, 5), if_all = TRUE) #> ℹ Identify records with condition(s): #> • where all of the Sepal.Length, Sepal.Width column(s) in each record #> • contains a value between range (bounds included): c(3, 5) #>  #> Summary of values in the result :  #> Range: [1] 3 5 #>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species #> 1           4.9         3.0          1.4         0.2  setosa #> 2           4.7         3.2          1.3         0.2  setosa #> 3           4.6         3.1          1.5         0.2  setosa #> 4           5.0         3.6          1.4         0.2  setosa #> 5           4.6         3.4          1.4         0.3  setosa #> 6           5.0         3.4          1.5         0.2  setosa #> 7           4.9         3.1          1.5         0.1  setosa #> 8           4.8         3.4          1.6         0.2  setosa #> 9           4.8         3.0          1.4         0.1  setosa #> 10          4.3         3.0          1.1         0.1  setosa #> 11          4.6         3.6          1.0         0.2  setosa #> 12          4.8         3.4          1.9         0.2  setosa #> 13          5.0         3.0          1.6         0.2  setosa #> 14          5.0         3.4          1.6         0.4  setosa #> 15          4.7         3.2          1.6         0.2  setosa #> 16          4.8         3.1          1.6         0.2  setosa #> 17          4.9         3.1          1.5         0.2  setosa #> 18          5.0         3.2          1.2         0.2  setosa #> 19          4.9         3.6          1.4         0.1  setosa #> 20          4.4         3.0          1.3         0.2  setosa #> 21          5.0         3.5          1.3         0.3  setosa #> 22          4.4         3.2          1.3         0.2  setosa #> 23          5.0         3.5          1.6         0.6  setosa #> 24          4.8         3.0          1.4         0.3  setosa #> 25          4.6         3.2          1.4         0.2  setosa #> 26          5.0         3.3          1.4         0.2  setosa  # applying to remote table; species starts with se or ends with ca iris_db <- dbplyr::memdb_frame(iris) identify_row(iris_db, Species, \"like\", c(\"se%\", \"%ca\")) #> ℹ Identify records with condition(s): #> • where the Species column(s) in each record #> • contains a value satisfied SQL LIKE pattern: se% OR %ca #> # Source:   SQL [?? x 5] #> # Database: sqlite 3.51.1 [:memory:] #>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species #>           <dbl>       <dbl>        <dbl>       <dbl> <chr>   #>  1          4.3         3            1.1         0.1 setosa  #>  2          4.4         2.9          1.4         0.2 setosa  #>  3          4.4         3            1.3         0.2 setosa  #>  4          4.4         3.2          1.3         0.2 setosa  #>  5          4.5         2.3          1.3         0.3 setosa  #>  6          4.6         3.1          1.5         0.2 setosa  #>  7          4.6         3.2          1.4         0.2 setosa  #>  8          4.6         3.4          1.4         0.3 setosa  #>  9          4.6         3.6          1           0.2 setosa  #> 10          4.7         3.2          1.3         0.2 setosa  #> # ℹ more rows  # using glue_sql to write the WHERE clause # use {`vars`} to refer to the variables selected by vars # supply additional values required in the query through '...' # note that if you use LIKE here, you cannot supply multiple patterns in what identify_row(iris_db, Species, \"glue_sql\",   \"{`vars`} LIKE {what}\",   what = \"se%\" ) #> ℹ Identify records with condition(s): #> • where the Species column(s) in each record #> • contains a value satisfied SQL WHERE clause: `Species` LIKE 'se%' #> # Source:   SQL [?? x 5] #> # Database: sqlite 3.51.1 [:memory:] #>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species #>           <dbl>       <dbl>        <dbl>       <dbl> <chr>   #>  1          5.1         3.5          1.4         0.2 setosa  #>  2          4.9         3            1.4         0.2 setosa  #>  3          4.7         3.2          1.3         0.2 setosa  #>  4          4.6         3.1          1.5         0.2 setosa  #>  5          5           3.6          1.4         0.2 setosa  #>  6          5.4         3.9          1.7         0.4 setosa  #>  7          4.6         3.4          1.4         0.3 setosa  #>  8          5           3.4          1.5         0.2 setosa  #>  9          4.4         2.9          1.4         0.2 setosa  #> 10          4.9         3.1          1.5         0.1 setosa  #> # ℹ more rows  # add * after a vector identify_row(iris_db, Species, \"glue_sql\",   \"{`vars`} IN ({what*})\",   what = c(\"setosa\", \"virginica\") ) #> ℹ Identify records with condition(s): #> • where the Species column(s) in each record #> • contains a value satisfied SQL WHERE clause: `Species` IN ('setosa', 'virginica') #> # Source:   SQL [?? x 5] #> # Database: sqlite 3.51.1 [:memory:] #>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species #>           <dbl>       <dbl>        <dbl>       <dbl> <chr>   #>  1          5.1         3.5          1.4         0.2 setosa  #>  2          4.9         3            1.4         0.2 setosa  #>  3          4.7         3.2          1.3         0.2 setosa  #>  4          4.6         3.1          1.5         0.2 setosa  #>  5          5           3.6          1.4         0.2 setosa  #>  6          5.4         3.9          1.7         0.4 setosa  #>  7          4.6         3.4          1.4         0.3 setosa  #>  8          5           3.4          1.5         0.2 setosa  #>  9          4.4         2.9          1.4         0.2 setosa  #> 10          4.9         3.1          1.5         0.1 setosa  #> # ℹ more rows"},{"path":"https://kevinhzq.github.io/healthdb/reference/if_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Interpret if any n elements drawn from a date vector could be some days apart within some time span — if_date","title":"Interpret if any n elements drawn from a date vector could be some days apart within some time span — if_date","text":"Given vector dates x, interpret least one set n elements taken x satisfy adjacent elements set least certain days apart dates set within specified time span. identifying events/diseases administrative data, definitions often require, e.g., n diagnoses least days apart within years. function intended use optimized avoid looping n-size combinations x. function work remote table input.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/if_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interpret if any n elements drawn from a date vector could be some days apart within some time span — if_date","text":"","code":"if_date(   x,   n,   apart = NULL,   within = NULL,   detail = FALSE,   align = c(\"left\", \"right\"),   dup.rm = TRUE,   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/if_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interpret if any n elements drawn from a date vector could be some days apart within some time span — if_date","text":"x character Date vector n integer size draw apart integer specifying minimum gap (days) adjacent dates draw. within integer specifying maximum time span (days) draw. detail Logical whether return result per element x.default FALSE, returns one logical summarized (). Detail available apart supplied without within sets satisfied condition overlap, records within set may far apart; thus, unambiguous way label element. align Character, define time span record start (\"left\") end (\"right\") current date. Defaults \"left\". See 'flag_at' argument restrict_date() detail. dup.rm Logical whether multiple records date count one calculation. applicable within supplied without apart; duplicated dates impact apart present n dates must distinct apart. Default TRUE. ... Additional argument passing data.table::.IDate() date conversion.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/if_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interpret if any n elements drawn from a date vector could be some days apart within some time span — if_date","text":"Single vector logical whether draw x satisfied conditions","code":""},{"path":[]},{"path":"https://kevinhzq.github.io/healthdb/reference/if_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interpret if any n elements drawn from a date vector could be some days apart within some time span — if_date","text":"","code":"dates_of_records <- sample(seq(as.Date(\"2015-01-01\"), as.Date(\"2021-12-31\"), 7), 10)  # whether there is any 3 records at least 30 days apart within 2 years if_date(dates_of_records, n = 3, apart = 30, within = 365 * 2) #> [1] TRUE  # specified either apart or within or both if_date(dates_of_records, n = 2, within = 365) #> Warning: 'x' is deprecated in frollapply, use 'X' instead #> Warning: 'n' is deprecated in frollapply, use 'N' instead #> [1] TRUE"},{"path":"https://kevinhzq.github.io/healthdb/reference/lookup.html","id":null,"dir":"Reference","previous_headings":"","what":"Find value corresponding to the input vector using a look-up table — lookup","title":"Find value corresponding to the input vector using a look-up table — lookup","text":"Find value corresponding input vector using look-table","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/lookup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find value corresponding to the input vector using a look-up table — lookup","text":"","code":"lookup(x, link, lu, verbose = getOption(\"healthdb.verbose\"))"},{"path":"https://kevinhzq.github.io/healthdb/reference/lookup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find value corresponding to the input vector using a look-up table — lookup","text":"x variable name data.frame; function called inside dplyr::mutate(). link formula form: name_of_x_in_lu ~ name_of_target_value. left-hand-side can omitted x's name also x look-. lu Look-table data.frame class. verbose logical whether warn missing values output.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/lookup.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find value corresponding to the input vector using a look-up table — lookup","text":"vector matched values.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/lookup.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find value corresponding to the input vector using a look-up table — lookup","text":"","code":"df <- data.frame(drug_code = 1:10) lu <- data.frame(drug_id = 1:20, drug_code = as.character(1:10), drug_name = sample(letters, 20))  df %>% dplyr::mutate(   drug_nm = lookup(drug_code, drug_id ~ drug_name, lu),   # this will work as lu also has drug_code column   drug_nm = lookup(drug_code, ~drug_name, lu) ) #>    drug_code drug_nm #> 1          1       f #> 2          2       o #> 3          3       x #> 4          4       r #> 5          5       b #> 6          6       s #> 7          7       j #> 8          8       q #> 9          9       e #> 10        10       v"},{"path":"https://kevinhzq.github.io/healthdb/reference/make_test_dat.html","id":null,"dir":"Reference","previous_headings":"","what":"Make test data — make_test_dat","title":"Make test data — make_test_dat","text":"Make toy data set testing demo. internal use purpose intended called users.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/make_test_dat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make test data — make_test_dat","text":"","code":"make_test_dat(   vals_kept = c(\"304\", \"305\", 3040:3049, 3050:3059),   noise_val = \"999\",   IDs = 1:50,   date_range = seq(as.Date(\"2015-01-01\"), as.Date(\"2020-12-31\"), by = 1),   nrows = 100,   n_any = 50,   n_all = 10,   seed = NULL,   answer_id = NULL,   type = c(\"data.frame\", \"database\") )"},{"path":"https://kevinhzq.github.io/healthdb/reference/make_test_dat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make test data — make_test_dat","text":"vals_kept vector values suppose identified. noise_val vector values meant identified. IDs vector client IDs. date_range vector possible dates data. nrows Number rows output. n_any Number rows identified criteria target column contains certain values. n_all Number rows identified criteria target columns contain certain values. seed Seed random number generation. answer_id Column name indicator row identified: , , noise. type Output type, \"data.frame\" \"database\".","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/make_test_dat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make test data — make_test_dat","text":"data.frame remote table 'dbplyr'.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/make_test_dat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make test data — make_test_dat","text":"","code":"make_test_dat() %>% head() #>   uid clnt_id      dates diagx diagx_1 diagx_2 #> 1  40       1 2015-10-16  3048    3046     999 #> 2  70       1 2016-11-01   999     999     999 #> 3  31       1 2016-11-10  3045    3040    <NA> #> 4  84       1 2016-11-15   999     999    <NA> #> 5  78       2 2017-04-25   999    <NA>     999 #> 6  39       2 2018-09-19  3056    3053     999"},{"path":"https://kevinhzq.github.io/healthdb/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://kevinhzq.github.io/healthdb/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling `rhs(lhs)`.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/pool_case.html","id":null,"dir":"Reference","previous_headings":"","what":"Pool qualified clients from results of multiple definitions — pool_case","title":"Pool qualified clients from results of multiple definitions — pool_case","text":"function filters pools, .e., row bind, qualified clients/groups different source option summarize client. Unlike bind_source(), need supply variable names; function guess included names supplied definition build_def(). Whether client qualified relies flag variables set define_case(). Therefore, function intended use built-define_case() def_fn build_def().","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/pool_case.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pool qualified clients from results of multiple definitions — pool_case","text":"","code":"pool_case(   data,   def,   output_lvl = c(\"raw\", \"clnt\"),   include_src = c(\"all\", \"has_valid\", \"n_per_clnt\"),   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/pool_case.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pool qualified clients from results of multiple definitions — pool_case","text":"data list data.frame remote table output execute_def(). def tibble case definition generated build_def(). output_lvl Either: \"raw\" - output records (default), \"clnt\" - output one record per client summaries including date source first valid record ('first_valid_date/src'), latest record ('last_entry_date/src'). Source-specific record counts also provided (see return section). include_src Character. determines records sources included. matters clients identified , , sources. choice impact number client identified impact number records latest entry date. options one : \"\" - records sources included; \"has_valid\" - client, records sources contain least one valid record included; \"n_per_clnt\" - client, fewer n_per_clnt records source (see restrict_n()), records source removed. ... Additional arguments passing bind_source()","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/pool_case.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pool qualified clients from results of multiple definitions — pool_case","text":"data.frame remote table clients satisfied predefined case definition. Columns started \"raw_in_\" source-specific counts raw records, columns started \"valid_in_\" number valid entries (number flags) source.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/pool_case.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pool qualified clients from results of multiple definitions — pool_case","text":"","code":"# toy data df1 <- make_test_dat() df2 <- make_test_dat()  # use build_def to make a toy definition sud_def <- build_def(\"SUD\", # usually a disease name   src_lab = c(\"src1\", \"src2\"), # identify from multiple sources, e.g., hospitalization, ED visits.   # functions that filter the data with some criteria   def_fn = define_case,   fn_args = list(     vars = starts_with(\"diagx\"),     match = \"start\", # \"start\" will be applied to all sources as length = 1     vals = list(c(\"304\"), c(\"305\")),     clnt_id = \"clnt_id\", # list()/c() could be omitted for single element     # c() can be used in place of list     # if this argument only takes one value for each source     n_per_clnt = c(2, 3)   ) )  # save the definition for re-use # saveRDS(sud_def, file = some_path)  # execute definition sud_by_src <- sud_def %>% execute_def(with_data = list(src1 = df1, src2 = df2)) #>  #> Actions for definition SUD using source df1: #> → --------------Inclusion step-------------- #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value satisfied regular expression: ^304 #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other vars columns):  #>  304 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049  305 3050 3051 3052 3053  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #> 3054 3055 3056 3058 3059  999 NA's  #>    1    1    1    1    1    1    1  #> → --------------No. rows restriction-------------- #> ℹ Of the 26 clients in the input, 18 were flagged as 0 by restricting that each client must have at least 2 records  #> → -------------- Output all records-------------- #>  #> Actions for definition SUD using source df2: #> → --------------Inclusion step-------------- #> ℹ Identify records with condition(s): #> • where at least one of the diagx, diagx_1, diagx_2 column(s) in each record #> • contains a value satisfied regular expression: ^305 #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other vars columns):  #>  304 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049  305 3050 3051 3052 3053  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #> 3054 3055 3056 3057 3058 3059  999 NA's  #>    1    1    1    1    1    1    1    1  #> → --------------No. rows restriction-------------- #> ℹ Of the 26 clients in the input, 23 were flagged as 0 by restricting that each client must have at least 3 records  #> → -------------- Output all records--------------  # pool results from src1 and src2 together at client level pool_case(sud_by_src, sud_def, output_lvl = \"clnt\") #> # A tibble: 10 × 6 #>    def   clnt_id raw_in_src1 raw_in_src2 valid_in_src1 valid_in_src2 #>    <chr>   <int>       <dbl>       <dbl>         <int>         <int> #>  1 SUD         7           0           1             0             1 #>  2 SUD        13           1           1             1             0 #>  3 SUD        19           1           1             1             0 #>  4 SUD        30           1           1             1             0 #>  5 SUD        31           1           0             1             0 #>  6 SUD        34           1           0             1             0 #>  7 SUD        36           0           1             0             1 #>  8 SUD        38           1           0             1             0 #>  9 SUD        41           1           1             1             0 #> 10 SUD        44           1           1             1             1"},{"path":"https://kevinhzq.github.io/healthdb/reference/report_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Report number of distinct value in a column across data frames — report_n","title":"Report number of distinct value in a column across data frames — report_n","text":"function intended mimic dplyr::n_distinct() multiple inputs. useful report number clients series inclusion exclusion steps. use case getting Ns sample definition flowchart epidemiological study. also useful inline reporting Ns Rmarkdown document.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/report_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Report number of distinct value in a column across data frames — report_n","text":"","code":"report_n(..., on, force_proceed = getOption(\"healthdb.force_proceed\"))"},{"path":"https://kevinhzq.github.io/healthdb/reference/report_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Report number of distinct value in a column across data frames — report_n","text":"... Data frames remote tables (e.g., 'dbplyr') column report . must present data sources. force_proceed logical whether ask user input order proceed data local data.frames, query needs executed reporting. default fetching options (FALSE). Use options(healthdb.force_proceed = TRUE) suppress prompt .","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/report_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Report number of distinct value in a column across data frames — report_n","text":"sequence number distinct data frames","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/report_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Report number of distinct value in a column across data frames — report_n","text":"","code":"# some exclusions iris_1 <- subset(iris, Petal.Length > 1) iris_2 <- subset(iris, Petal.Length > 2)  # get n at each operation n <- report_n(iris, iris_1, iris_2, on = Species) n #> [1] 3 3 2  # get the difference at each step diff(n) #> [1]  0 -1 # data in a list iris_list <- list(iris_1, iris_2) report_n(rlang::splice(iris_list), on = Species) #> [1] 3 2 # if you loaded tidyverse, this will also work # report_n(!!!iris_list, on = Species)"},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove or flag groups failed to meet conditions based on dates — restrict_date","title":"Remove or flag groups failed to meet conditions based on dates — restrict_date","text":"client group, interpret n records least certain days apart within specified time span. identifying events/diseases administrative data, definitions often require, e.g., n diagnoses least days apart within years. function intended use optimized avoid looping n-size combinations dates per client.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove or flag groups failed to meet conditions based on dates — restrict_date","text":"","code":"restrict_date(   data,   clnt_id,   date_var,   n,   apart = NULL,   within = NULL,   uid = NULL,   mode = c(\"flag\", \"filter\"),   flag_at = c(\"left\", \"right\"),   dup.rm = TRUE,   force_collect = FALSE,   verbose = getOption(\"healthdb.verbose\"),   check_missing = FALSE,   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove or flag groups failed to meet conditions based on dates — restrict_date","text":"data Data frames remote tables (e.g., dbplyr::tbl_sql()) clnt_id Grouping variable (quoted/unquoted). date_var Variable name (quoted/unquoted) dates interpreted. n integer size draw. apart integer specifying minimum gap (days) adjacent dates draw. within integer specifying maximum time span (days) draw. uid Variable name unique row identifier. necessary SQL produce consistent result based sorting. mode Either: \"flag\" - add new column 'flag_restrict_date' indicating condition met (flag = 1 time period starting ending current record satisfied apart-within condition), \"filter\" - remove clients without qualified record data. Default \"flag\". flag_at Character, define flag placed start (\"left\") end (\"right\") time period contains n qualified records. Defaults \"left\". Note impact first last qualified/diagnosed dates client, e.g., using \"right\" first flag earliest date client became qualified. example, condition 2 records within year, c(\"2023-01-01\", \"2023-04-01\", \"2024-05-01\"), flag c(0, 1, 0) \"right\" c(1,0,0) \"left\". dup.rm Logical whether multiple records date count one calculation. applicable within supplied without apart; duplicated dates impact apart present n dates must distinct apart. Default TRUE. force_collect logical whether force downloading remote table apart NULL. remote table , apart implemented local data frame . Downloading data slow, user opt ; default FALSE stop error. verbose logical whether explain query report many groups removed. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . Reporting remote tables query executed immediately, thus result available summary without adding extra run (may slow) query. check_missing logical whether check remove missing entries date_var applying conditions. Default FALSE faster run time. ... Additional argument passing data.table::.IDate() date conversion.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove or flag groups failed to meet conditions based on dates — restrict_date","text":"subset input data satisfied dates requirement, raw input data new flag column.","code":""},{"path":[]},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove or flag groups failed to meet conditions based on dates — restrict_date","text":"","code":"sample_size <- 30 df <- data.frame(   clnt_id = sample(1:sample_size, sample_size, replace = TRUE),   service_dt = sample(seq(as.Date(\"2020-01-01\"), as.Date(\"2020-01-31\"), by = 1),     size = sample_size, replace = TRUE   ),   diagx = sample(letters, size = sample_size, replace = TRUE),   diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),   diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE) )  # Keep clients with 2 records that were 1 week apart within 1 month restrict_date(df, clnt_id, service_dt, n = 2, apart = 7, within = 30) #> ℹ Of the 20 clients in the input, 16 were flagged as 0 by restricting that each client must have 2 records that were at least 7 days apart within 30 days #> # A tibble: 30 × 6 #>    clnt_id service_dt diagx diagx_1 diagx_2 flag_restrict_date #>      <int> <date>     <chr> <chr>   <chr>                <dbl> #>  1       1 2020-01-11 g     v       m                        0 #>  2       3 2020-01-01 o     u       z                        0 #>  3       5 2020-01-01 o     v       l                        0 #>  4       5 2020-01-06 c     p       m                        0 #>  5       6 2020-01-08 b     c       i                        0 #>  6       7 2020-01-01 m     f       e                        1 #>  7       7 2020-01-16 l     r       d                        0 #>  8       8 2020-01-07 z     g       p                        0 #>  9      11 2020-01-23 z     w       o                        0 #> 10      12 2020-01-05 o     q       x                        0 #> # ℹ 20 more rows"},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove or flag groups with n less than some number — restrict_n","title":"Remove or flag groups with n less than some number — restrict_n","text":"Remove flags groups clients less number rows number distinct values variable. example, can used remove clients less n visits service different dates administrative records. offers filtering dplyr::n_distinct() functionality database input.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove or flag groups with n less than some number — restrict_n","text":"","code":"restrict_n(   data,   clnt_id,   n_per_clnt,   count_by = NULL,   mode = c(\"flag\", \"filter\"),   verbose = getOption(\"healthdb.verbose\") )"},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove or flag groups with n less than some number — restrict_n","text":"data Data.frames remote tables (e.g., dbplyr::tbl_sql()) clnt_id Grouping variable (quoted/unquoted). n_per_clnt single number specifying minimum number group size. count_by Another variable dictating counting unit n_per_clnt. default NULL meaning inclusion criteria number row, .e., dplyr::n() >= n_per_clnt. NULL, criteria becomes equivalent dplyr::n_distinct(count_by) >= n_per_clnt. mode Either \"flag\" - add new column 'flag_restrict_n' indicating client met condition (rows qualified client flag = 1), \"filter\" - remove clients meet condition data. Default \"flag\". verbose logical whether explain query report many groups removed. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . Reporting remote tables query executed immediately, thus result available summary without adding extra run (may slow) query.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove or flag groups with n less than some number — restrict_n","text":"subset input data satisfied group size requirement, raw input data new flag column.","code":""},{"path":[]},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove or flag groups with n less than some number — restrict_n","text":"","code":"# flag cyl groups with less than 8 cars restrict_n(mtcars, clnt_id = cyl, n_per_clnt = 8, mode = \"flag\") %>%   head() #> ℹ Of the 3 clients in the input, 1 were flagged as 0 by restricting that each client must have at least 8 records  #>    mpg cyl disp  hp drat    wt  qsec vs am gear carb flag_restrict_n #> 1 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4               0 #> 2 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4               0 #> 3 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1               1 #> 4 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1               0 #> 5 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2               1 #> 6 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1               0  # remove cyl groups with less than 2 types of gear boxes restrict_n(mtcars, clnt_id = cyl, n_per_clnt = 3, count_by = gear, mode = \"filter\") #> ℹ Of the 3 clients in the input, 1 were excluded by restricting that each client must have at least 3 records with distinct gear #>     mpg cyl  disp  hp drat    wt  qsec vs am gear carb flag_restrict_n #> 1  21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4               1 #> 2  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4               1 #> 3  21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1               1 #> 4  18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1               1 #> 5  19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4               1 #> 6  17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4               1 #> 7  19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6               1 #> 8  22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1               1 #> 9  24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2               1 #> 10 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2               1 #> 11 32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1               1 #> 12 30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2               1 #> 13 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1               1 #> 14 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1               1 #> 15 27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1               1 #> 16 26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2               1 #> 17 30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2               1 #> 18 21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2               1"},{"path":"https://kevinhzq.github.io/healthdb/news/index.html","id":"healthdb-050","dir":"Changelog","previous_headings":"","what":"healthdb 0.5.0","title":"healthdb 0.5.0","text":"CRAN release: 2026-01-08","code":""},{"path":"https://kevinhzq.github.io/healthdb/news/index.html","id":"bug-fix-0-5-0","dir":"Changelog","previous_headings":"","what":"Bug fix","title":"healthdb 0.5.0","text":"Fixed bug apart feature restrict_date() caused ‘dbplyr’ 2.5.1 update input order SQL translation difftime() flipped.","code":""},{"path":"https://kevinhzq.github.io/healthdb/news/index.html","id":"improvements-0-5-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"healthdb 0.5.0","text":"Added new define function age restriction - define_case_with_age()","code":""},{"path":"https://kevinhzq.github.io/healthdb/news/index.html","id":"healthdb-041","dir":"Changelog","previous_headings":"","what":"healthdb 0.4.1","title":"healthdb 0.4.1","text":"CRAN release: 2025-04-05","code":""},{"path":"https://kevinhzq.github.io/healthdb/news/index.html","id":"improvements-0-4-1","dir":"Changelog","previous_headings":"","what":"Improvements","title":"healthdb 0.4.1","text":"Functions take remote table input now checks whether connection database working properly.","code":""},{"path":"https://kevinhzq.github.io/healthdb/news/index.html","id":"healthdb-040","dir":"Changelog","previous_headings":"","what":"healthdb 0.4.0","title":"healthdb 0.4.0","text":"CRAN release: 2025-02-28","code":""},{"path":"https://kevinhzq.github.io/healthdb/news/index.html","id":"improvements-0-4-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"healthdb 0.4.0","text":"fetch_var() documentation now indicates accept input pipe. collapse_episode() now works remote table input. pool_case() now provides source first valid latest records linkage back source data.","code":""},{"path":"https://kevinhzq.github.io/healthdb/news/index.html","id":"healthdb-031","dir":"Changelog","previous_headings":"","what":"healthdb 0.3.1","title":"healthdb 0.3.1","text":"CRAN release: 2024-05-23","code":""},{"path":"https://kevinhzq.github.io/healthdb/news/index.html","id":"bug-fixes-0-3-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"healthdb 0.3.1","text":"Fixed critical bug introduced new code cleans window order remaining database output. problem related issue Inability remove window_order() leads weird, unpredictable results. bind_source() bind correctly every variable name argument single string (.e., selecting variables common names ). Fixed bug pool_case() every source flags, code fills missing flag == 1 trigger error.","code":""},{"path":"https://kevinhzq.github.io/healthdb/news/index.html","id":"healthdb-030","dir":"Changelog","previous_headings":"","what":"healthdb 0.3.0","title":"healthdb 0.3.0","text":"CRAN release: 2024-05-15","code":""},{"path":"https://kevinhzq.github.io/healthdb/news/index.html","id":"improvements-0-3-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"healthdb 0.3.0","text":"fetch_var() accept database input, prevent one--many joins checking slow remote database. functions accept database input now sort output avoid generating ‘ORDER ’ clause may trigger warning output chained subsequent operations. restrict_date() check missing date unless new check_missing argument set TRUE. checking time may negligible large database; user opt .","code":""},{"path":"https://kevinhzq.github.io/healthdb/news/index.html","id":"bug-fixes-0-3-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"healthdb 0.3.0","text":"Chaining pool_case() dplyr::compute() create table database longer give errors warnings related window order.","code":""},{"path":"https://kevinhzq.github.io/healthdb/news/index.html","id":"healthdb-020","dir":"Changelog","previous_headings":"","what":"healthdb 0.2.0","title":"healthdb 0.2.0","text":"CRAN release: 2024-05-05","code":""},{"path":"https://kevinhzq.github.io/healthdb/news/index.html","id":"improvements-0-2-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"healthdb 0.2.0","text":"apart argument restrict_date() now functional data.frame database input. restrict_date() give warning missing entries date_var. description dup.rm re-written clarify applicable apart absent. pool_case() now outputs number raw (raw_in_src) valid (valid_in_src) entries source. List element execute_def() output named definition source labels. verbose message, except data summaries, sent message instead text output, can suppressed via message = FALSE Rmarkdown.","code":""},{"path":"https://kevinhzq.github.io/healthdb/news/index.html","id":"bug-fixes-0-2-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"healthdb 0.2.0","text":"Fixed if_date() gave output shorter input detail dup.rm TRUE. if_date() now assume dates sorted returns elements original unsorted order. Fixed restrict_date() remote table might miss cases duplicated dates n > 2.","code":""}]
