[{"path":"https://kevinhzq.github.io/healthdb/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 healthdb authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://kevinhzq.github.io/healthdb/articles/Intro.html","id":"sec-what-it-does","dir":"Articles","previous_headings":"","what":"What it does","title":"Intro","text":"package designed identifying disease cases admin data epidemiological studies. implementation focused code readability re-usability. Three types functions included: Interactive functions (e.g., identify_row(), exclude(), fetch_var()) based filter joins dplyr tweaks fix SQL translation add features natively support SQL. also work local data.frame, use ‘data.table’ package (vignette(\"datatable-intro\", package = \"data.table\")) speed processing time large data. functions flexible dplyr::filter(), general enough useful outside health research. Call-building functions (e.g., build_def(), execute_def()) facilitate batch execution re-use case definitions. essence, build_def creates codes definitions (chain interactive functions, e.g., define_case()) immediately ran. execute_def runs built definitions different input data. Miscellaneous functions computing age, collapsing records within time range one episode, (-going effort) built-checks signalling things go wrong.","code":""},{"path":"https://kevinhzq.github.io/healthdb/articles/Intro.html","id":"motivation","dir":"Articles","previous_headings":"What it does","what":"Motivation","title":"Intro","text":"Administrative health data data often stored database strict security measures may disable permission write temporary tables. Writing queries without able cache intermediate results challenging, especially data large downloaded database R (.e., local memory) without filtering process. lack regular expression support SQL makes writing queries searching ICD codes even painful. ‘dbplyr’ package translates ‘dplyr’ syntax SQL also make nesting sub-queries easy pipe operator. ‘dbplyr’, complex query script can built nested sub-queries instead writing temporary tables cost performance (sub-queries ran called multiple times). Nevertheless, building complex queries ‘dbplyr’ useful approach push computation onto SQL server often much efficient resourceful user’s (virtual) machine. However, ‘dbplyr’ SQL translations failed places intended use case needs fixing. motivation package ease pain issues analyst regularly works healthcare database.","code":""},{"path":"https://kevinhzq.github.io/healthdb/articles/Intro.html","id":"sec-installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Intro","text":"Simply run: also need following packages demo.","code":"devtools::install_github(\"kevinHzq/healthdb\", build_vignettes = TRUE) library(dplyr) library(dbplyr) library(lubridate) library(glue) library(purrr) library(healthdb)"},{"path":"https://kevinhzq.github.io/healthdb/articles/Intro.html","id":"sec-intended-use-case","dir":"Articles","previous_headings":"","what":"Intended use case","title":"Intro","text":"Consider case definition substance use disorder (SUD) British Columbia Centre Disease Control’s Chronic Disease Dashboard, One hospitalization substance use disorder diagnostic code, Two physician visits substance use disorder diagnostic code within one year. going implement definition. First, let’s make demo data sets two sources: Physician claims multiple columns ICD-9 diagnostic codes Hospitalization ICD-10 codes","code":"# make_test_dat() makes either a toy data.frame or database table in memory with known number of rows that satisfy the query we will show later claim_db <- make_test_dat(vals_kept = c(\"303\", \"304\", \"305\", \"291\", \"292\", glue(\"30{30:59}\"), glue(\"29{10:29}\"), noise_val = c(\"999\", \"111\")), type = \"database\")  # this is a database table # note that in-memory SQLite database stores dates as numbers claim_db %>% head() #> # Source:   SQL [6 x 6] #> # Database: sqlite 3.45.2 [:memory:] #>     uid clnt_id dates diagx diagx_1 diagx_2 #>   <int>   <int> <dbl> <chr> <chr>   <chr>   #> 1    51       1 16660 999   999     999     #> 2    24       1 17464 3048  3040    NA      #> 3    14       2 17640 3041  3047    NA      #> 4    37       3 16948 2913  3035    999     #> 5    91       4 16712 999   999     999     #> 6    82       4 16760 999   999     NA hosp_df <- make_test_dat(vals_kept = c(glue(\"F{10:19}\"), glue(\"F{100:199}\"), noise_val = \"999\"), type = \"data.frame\")  # this is a local data.frame/tibble hosp_df %>% head() #>   uid clnt_id      dates diagx diagx_1 diagx_2 #> 1  43       1 2015-08-13  F156    F144    F168 #> 2  16       1 2017-10-25   F12    F132    <NA> #> 3   6       2 2018-04-19  F133    F128    <NA> #> 4  29       3 2016-05-27  F130    F164     999 #> 5  83       4 2015-10-04   999     999    <NA> #> 6  74       4 2015-11-21   999    <NA>     999"},{"path":"https://kevinhzq.github.io/healthdb/articles/Intro.html","id":"interactive-functions","dir":"Articles","previous_headings":"","what":"Interactive functions","title":"Intro","text":"Let’s focus physician claims. Extracting clients least two records within year difficult, involves steps. codes look like following using dplyr, however, work : 1. SQL support multiple patterns one LIKE operation, 2. dbply currently issue translating n_distinct. ’s use healthdb achieve steps: Identify rows contains target codes Bonus: remove clients exclusion codes step substance use disorder definition, disease definitions often require exclusion ICDs contradicts ones interest. Let’s say want remove clients code “111” . first identify “111” source, exclude clients output previous step’s result. exclude() take either data set (via excl argument) expression (condition argument) input. former, performs anti join matching argument (see dplyr::join_by()). latter, opposite filter, .e., filter(!(some_expression)). Restrict number records per client Restrict temporal pattern diagnoses restrict_date() also supports complicated patterns like n diagnoses least days apart within j years, “apart” feature requires relatively expensive computation implemented local data.frames . Note SQL interpret order dates, result deterministic duplicate dates within client. Therefore, unique row id colume (uid) supplied get consistent result. Fetch variables tables matching common keys point, result query downloaded. Hopefully, shrunken manageable size collection. data now contains diagnoses probably enough analyses. Let’s say want gather client demographics age sex sources. certainly can done multiple dplyr::left_join() calls. provide fetch_var() function make codes concise.","code":"## not run claim_db %>%   # identify the target codes   filter(if_any(starts_with(\"diagx_\"), ~ str_like(., c(\"291%\", \"292%\", \"303%\", \"304%\", \"305%\")))) %>%   # each clnt has at least 2 records on different dates   group_by(clnt_id) %>%   # the n_distinct step is mainly for reducing computation in the next step   filter(n_distinct(dates) >= 2) %>%   # any two dates within one year?   filter((max(dates) - min(dates)) <= 365) ## end result1 <- claim_db %>%   identify_row( vars = starts_with(\"diagx_\"), match = \"start\", vals = c(291:292, 303:305)   ) #>  #> Identify records with condition(s):  #>  - where at least one of the diagx_1, diagx_2 column(s) in each record  #>    - contains a value satisfied SQL LIKE pattern: 291% OR 292% OR 303% OR 304% OR 305%  #>  #> To see the final query generated by 'dbplyr', use dplyr::show_query() on the output.  #> To extract the SQL string, use dbplyr::remote_query(). result2 <- result1 %>%   exclude( excl = identify_row(claim_db, starts_with(\"diagx_\"), \"in\", \"111\"), by = \"clnt_id\"   ) #>  #> Identify records with condition(s):  #>  - where at least one of the diagx_1, diagx_2 column(s) in each record  #>    - contains a value exactly matched values in set: \"111\"  #>  #> To see the final query generated by 'dbplyr', use dplyr::show_query() on the output.  #> To extract the SQL string, use dbplyr::remote_query(). #>  #> Exclude records in `data` through anti_join with `excl` matching on (by argument): \"clnt_id\" result3 <- result2 %>% restrict_n(   clnt_id = clnt_id,   n_per_clnt = 2,   count_by = dates,   # here we use filter mode to remove records that failed the restriction   mode = \"filter\" ) #>  #> Apply restriction that each client must have at least 2 records with distinct dates. Clients/groups whichdid not meetthe condition were excluded. result4 <- result3 %>% restrict_date(   clnt_id = clnt_id,   date_var = dates,   n = 2,   within = 365,   uid = uid,   # here we use flag mode to flag records that met the restriction instead of removing those   mode = \"flag\" ) #>  #> Apply restriction that each client must have 2 records that were  within 365 days. Records that met the condition were flagged. # Class of result4 class(result4) #> [1] \"tbl_SQLiteConnection\" \"tbl_dbi\"              \"tbl_sql\"              #> [4] \"tbl_lazy\"             \"tbl\"  # execute query and download the result result_df <- result4 %>% collect()  # Number of rows in source nrow(claim_db %>% collect()) #> [1] 100  # Number of rows in the current result nrow(result_df) #> [1] 35 # make two look up tables age_tab <- data.frame(   clnt_id = 1:50,   age = sample(1:90, 50),   sex = sample(c(\"F\", \"M\"), 50, replace = TRUE) ) address_tab <- data.frame(   clnt_id = rep(1:50, 5), year = rep(2016:2020, each = 50),   area_code = sample(0:200, 50, replace = TRUE) )  # get year from dates for matching  result_df <- result_df %>% mutate(year = lubridate::year(as.Date(dates, origin = \"1970-01-01\")))  # note that keys must be present in all tables result_df %>%   fetch_var( keys = c(clnt_id, year), linkage = list(   # |clnt_id means matching on clnt_id only   age_tab ~ c(age, sex) | clnt_id,   address_tab ~ area_code )   ) %>%   head() #>  #> The data has 35 rows. After joining, variable(s) from age_tab has 35 rows, and variable(s) from address_tab has 35 rows #> # A tibble: 6 × 12 #>     uid clnt_id dates diagx diagx_1 diagx_2 flag_restrict_n flag_restrict_date #>   <int>   <int> <dbl> <chr> <chr>   <chr>             <int>              <int> #> 1    35       7 16810 2913  2923    999                   1                  1 #> 2    22       7 16897 3056  2917    999                   1                  1 #> 3    47       7 17096 3033  3051    3036                  1                  1 #> 4    10       7 17250 2923  3057    999                   1                  0 #> 5    41      10 16954 3033  305     2929                  1                  0 #> 6    44      10 17788 999   304     292                   1                  0 #> # ℹ 4 more variables: year <dbl>, age <int>, sex <chr>, area_code <int>"},{"path":"https://kevinhzq.github.io/healthdb/articles/Intro.html","id":"call-building-functions","dir":"Articles","previous_headings":"","what":"Call-building functions","title":"Intro","text":"complete definition, need repeat process shown hospitalization data. studies may use handful data sources define sample. packed steps 1-4 one function define_case(), provide tools perform batch execution different data parameters meet needs. Let’s look inside fn_call list column. Two calls define_case() made different parameters. data arguments left empty purpose re-usability. example, may want repeat analysis data different regions study periods. Executing definition simple. verbose option turned options(healthdb.verbose = FALSE), output message explain done. append multiple build_def() outputs together execute . Definition source labels added result identify outputs different calls. Let’s check results! point, result claim database (result[[1]]) collected locally. collect manually, filtering, combine result hospitalization data way want. just need simple row bind, bind_source() convenient naming feature.","code":"# build the full definition of SUD sud_def <- build_def(   # name of definition   def_lab = \"SUD\",   # place holder names for sources   src_labs = c(\"claim\", \"hosp\"),   def_fn = define_case, # you could alter it and supply your own function   # below are argumets of define_case   fn_args = list(     # if length = 1, the single element will be use for every source     vars = list(starts_with(\"diagx_\")),     match = \"start\", # match ICD starts with vals     vals = list(c(291:292, 303:305), glue(\"F{10:19}\")),     clnt_id = clnt_id,     n_per_clnt = c(2, 1),     date_var = dates,     within = c(365, NULL),     uid = uid,     mode = \"flag\"   ) )  sud_def #> # A tibble: 2 × 5 #>   def_lab src_labs def_fn      fn_args          fn_call    #>   <chr>   <chr>    <chr>       <list>           <list>     #> 1 SUD     claim    define_case <named list [9]> <language> #> 2 SUD     hosp     define_case <named list [9]> <language> sud_def$fn_call #> [[1]] #> define_case(data = , vars = starts_with(\"diagx_\"), match = \"start\",  #>     vals = c(291:292, 303:305), clnt_id = clnt_id, n_per_clnt = 2,  #>     date_var = dates, within = 365, uid = uid, mode = \"flag\") #>  #> [[2]] #> define_case(data = , vars = starts_with(\"diagx_\"), match = \"start\",  #>     vals = glue(\"F{10:19}\"), clnt_id = clnt_id, n_per_clnt = 1,  #>     date_var = dates, within = NULL, uid = uid, mode = \"flag\") # execute the definition result_list <- sud_def %>%   execute_def(with_data = list(     claim = claim_db,     hosp = hosp_df   )) #>  #> Processing source: claim_db #> --------------Inclusion step-------------- #>  #> Identify records with condition(s):  #>  - where at least one of the diagx_1, diagx_2 column(s) in each record  #>    - contains a value satisfied SQL LIKE pattern: 291% OR 292% OR 303% OR 304% OR 305%  #>  #> To see the final query generated by 'dbplyr', use dplyr::show_query() on the output.  #> To extract the SQL string, use dbplyr::remote_query(). #>  #> --------------No. rows restriction-------------- #>  #> Apply restriction that each client must have at least 2 records with distinct dates. Clients/groups whichmetthe condition were flagged.  #>  #> --------------Time span restriction-------------- #>  #> Apply restriction that each client must have 2 records that were  within 365 days. Records that met the condition were flagged.  #>  #> -------------- Output all records-------------- #>  #> Processing source: hosp_df #> --------------Inclusion step-------------- #>  #> Identify records with condition(s):  #>  - where at least one of the diagx_1, diagx_2 column(s) in each record  #>    - contains a value satisfied regular expression: ^F10|^F11|^F12|^F13|^F14|^F15|^F16|^F17|^F18|^F19  #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other columns):  #>  999 F100 F101 F105 F109 F112 F113 F115 F116 F119 F120 F121 F122 F125 F128 F130  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #> F131 F132 F134 F140 F142 F144 F145 F148 F150 F157 F158 F159 F161 F162 F164 F167  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #> F168 F170 F171 F174 F176 F178 F180 F184 F187 F188 F191 F194 F195 F197 F198 NA's  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #>  #> -------------- Output all records-------------- # view the results purrr::walk(result_list, ~ head(.) %>% print()) #> # Source:     SQL [6 x 10] #> # Database:   sqlite 3.45.2 [:memory:] #> # Ordered by: dates, uid #>   def   src     uid clnt_id dates diagx diagx_1 diagx_2 flag_restrict_n #>   <chr> <chr> <int>   <int> <dbl> <chr> <chr>   <chr>             <int> #> 1 SUD   claim    24       1 17464 3048  3040    NA                    0 #> 2 SUD   claim    14       2 17640 3041  3047    NA                    0 #> 3 SUD   claim    37       3 16948 2913  3035    999                   0 #> 4 SUD   claim    18       4 18151 305   3056    999                   0 #> 5 SUD   claim    38       5 18248 3055  3054    999                   0 #> 6 SUD   claim    46       6 17273 2922  3048    2927                  0 #> # ℹ 1 more variable: flag_restrict_date <int> #>   def  src uid clnt_id      dates diagx diagx_1 diagx_2 #> 1 SUD hosp  43       1 2015-08-13  F156    F144    F168 #> 2 SUD hosp  16       1 2017-10-25   F12    F132    <NA> #> 3 SUD hosp   6       2 2018-04-19  F133    F128    <NA> #> 4 SUD hosp  29       3 2016-05-27  F130    F164     999 #> 5 SUD hosp  10       4 2019-09-12  F138    F120     999 #> 6 SUD hosp  30       5 2019-12-18  F192    F100     999 bind_source(result_list,   # output_name = c(names in the list elements)   src = \"src\",   uid = \"uid\",   clnt_id = \"clnt_id\",   flag_date = c(\"flag_restrict_date\", NA),   force_proceed = TRUE ) #> # A tibble: 99 × 5 #>    src_No src     uid clnt_id flag_date #>     <int> <chr> <int>   <int>     <int> #>  1      1 claim    24       1         0 #>  2      1 claim    14       2         0 #>  3      1 claim    37       3         0 #>  4      1 claim    18       4         0 #>  5      1 claim    38       5         0 #>  6      1 claim    46       6         0 #>  7      1 claim    35       7         1 #>  8      1 claim    22       7         1 #>  9      1 claim    47       7         1 #> 10      1 claim    10       7         0 #> # ℹ 89 more rows"},{"path":"https://kevinhzq.github.io/healthdb/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kevin Hu. Author, maintainer, copyright holder.","code":""},{"path":"https://kevinhzq.github.io/healthdb/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hu K (2024). healthdb: Working Healthcare Database. R package version 0.1.0, https://kevinhzq.github.io/healthdb/, https://github.com/KevinHzq/healthdb.","code":"@Manual{,   title = {healthdb: Working with Healthcare Database},   author = {Kevin Hu},   year = {2024},   note = {R package version 0.1.0, https://kevinhzq.github.io/healthdb/},   url = {https://github.com/KevinHzq/healthdb}, }"},{"path":"https://kevinhzq.github.io/healthdb/index.html","id":"healthdb-","dir":"","previous_headings":"","what":"Working with Healthcare Database","title":"Working with Healthcare Database","text":"goal ‘healthdb’ provide set tools identifying diseases events healthcare database preparing data epidemiological studies. features abilities natively support database, matching strings ‘stringr’ style regular expression using ‘LIKE’ operator multiple patterns vector. Three types functions included: interactive functions – customizing complex definitions; call building functions – batch execution simple definition; miscellaneous functions – data wrangling, computing age comorbidity index, etc. package tested SQL Server SQLite access SQL dialects. Please report bugs encounter issues dialects. Administrative health data data often stored database strict security measures may disable permission write temporary tables. Writing queries without able cache intermediate results challenging, especially data large downloaded database R (.e., local memory) without filtering process. package leverages ‘dbplyr’, particularly ability chain subqueries, order implement common disease definition one-shot big query. Outputs fully compatible ‘dplyr’ functions. Common disease definitions often form n primary care/hospitalization/prescription records International Classification Diseases (ICD) codes within time span. See example implementing case definition.","code":""},{"path":"https://kevinhzq.github.io/healthdb/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Working with Healthcare Database","text":"Install CRAN: also install development version GitHub :","code":"install.packages(\"healthdb\") # install.packages(\"devtools\") devtools::install_github(\"KevinHzq/healthdb\")"},{"path":"https://kevinhzq.github.io/healthdb/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Working with Healthcare Database","text":"Case definition: One hospitalization substance use disorder (SUD) diagnostic code, Two physician claims substance use disorder diagnostic code within one year. going implement definition. First, let’s make demo data sets two sources: Physician claims Hospitalization ’s use healthdb implement SUD definition : Identify rows contains target codes claim database Restrict number records per client Restrict temporal pattern diagnoses Repeat steps hospitalization row bind results. output functions, including identify_row(), exclude(), restrict_n(), restrict_date() can piped ‘dplyr’ functions manipulations. Therefore, wrangling along ‘dplyr’ provide maximum flexibility implementing complex algorithms. However, code look repetitive multiple data sources involved. See “Intro” vignette (vignette(\"Intro\")) much concise way work multiple sources definitions (‘Call-building functions’ section).","code":"library(healthdb) library(tidyverse)  # make_test_dat() makes either a toy data.frame or database table in memory with known number of rows that satisfy the query we will show later claim_db <- make_test_dat(vals_kept = c(\"303\", \"304\", \"305\", \"291\", \"292\", str_glue(\"30{30:59}\"), str_glue(\"29{10:29}\"), noise_val = c(\"999\", \"111\")), type = \"database\")  # this is a database table # note that in-memory SQLite database stores dates as numbers claim_db %>% head() #> # Source:   SQL [6 x 6] #> # Database: sqlite 3.45.2 [:memory:] #>     uid clnt_id dates diagx diagx_1 diagx_2 #>   <int>   <int> <dbl> <chr> <chr>   <chr>   #> 1    51       1 16660 999   999     999     #> 2    24       1 17464 3048  3040    <NA>    #> 3    14       2 17640 3041  3047    <NA>    #> 4    37       3 16948 2913  3035    999     #> 5    91       4 16712 999   999     999     #> 6    82       4 16760 999   999     <NA> hosp_df <- make_test_dat(vals_kept = c(str_glue(\"F{10:19}\"), str_glue(\"F{100:199}\"), noise_val = \"999\"), type = \"data.frame\")  # this is a local data.frame/tibble hosp_df %>% head() #>   uid clnt_id      dates diagx diagx_1 diagx_2 #> 1  43       1 2015-08-13  F156    F144    F168 #> 2  16       1 2017-10-25   F12    F132    <NA> #> 3   6       2 2018-04-19  F133    F128    <NA> #> 4  29       3 2016-05-27  F130    F164     999 #> 5  83       4 2015-10-04   999     999    <NA> #> 6  74       4 2015-11-21   999    <NA>     999 result1 <- claim_db %>%   identify_row( vars = starts_with(\"diagx_\"), match = \"start\", vals = c(291:292, 303:305)   ) #>  #> Identify records with condition(s):  #>  - where at least one of the diagx_1, diagx_2 column(s) in each record  #>    - contains a value satisfied SQL LIKE pattern: 291% OR 292% OR 303% OR 304% OR 305%  #>  #> To see the final query generated by 'dbplyr', use dplyr::show_query() on the output.  #> To extract the SQL string, use dbplyr::remote_query(). result2 <- result1 %>% restrict_n(   clnt_id = clnt_id,   n_per_clnt = 2,   count_by = dates,   # here we use filter mode to remove records that failed the restriction   mode = \"filter\" ) #>  #> Apply restriction that each client must have at least 2 records with distinct dates. Clients/groups whichdid not meetthe condition were excluded. result2 %>% head() #> # Source:     SQL [6 x 7] #> # Database:   sqlite 3.45.2 [:memory:] #> # Ordered by: dates #>     uid clnt_id dates diagx diagx_1 diagx_2 flag_restrict_n #>   <int>   <int> <dbl> <chr> <chr>   <chr>             <int> #> 1    35       7 16810 2913  2923    999                   1 #> 2    22       7 16897 3056  2917    999                   1 #> 3    47       7 17096 3033  3051    3036                  1 #> 4    10       7 17250 2923  3057    999                   1 #> 5    41      10 16954 3033  305     2929                  1 #> 6    44      10 17788 999   304     292                   1 result3 <- result2 %>% restrict_date(   clnt_id = clnt_id,   date_var = dates,   n = 2,   within = 365,   uid = uid,   # here we use flag mode to flag records that met the restriction instead of removing those   mode = \"flag\" ) #>  #> Apply restriction that each client must have 2 records that were  within 365 days. Records that met the condition were flagged. result3 %>% head() #> # Source:     SQL [6 x 8] #> # Database:   sqlite 3.45.2 [:memory:] #> # Ordered by: dates, uid #>     uid clnt_id dates diagx diagx_1 diagx_2 flag_restrict_n flag_restrict_date #>   <int>   <int> <dbl> <chr> <chr>   <chr>             <int>              <int> #> 1    35       7 16810 2913  2923    999                   1                  1 #> 2    22       7 16897 3056  2917    999                   1                  1 #> 3    47       7 17096 3033  3051    3036                  1                  1 #> 4    10       7 17250 2923  3057    999                   1                  0 #> 5    41      10 16954 3033  305     2929                  1                  0 #> 6    44      10 17788 999   304     292                   1                  0"},{"path":"https://kevinhzq.github.io/healthdb/reference/bind_source.html","id":null,"dir":"Reference","previous_headings":"","what":"Row-bind a list of data.frames or remote tables — bind_source","title":"Row-bind a list of data.frames or remote tables — bind_source","text":"Row-bind list data.frames remote tables","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/bind_source.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Row-bind a list of data.frames or remote tables — bind_source","text":"","code":"bind_source(data, ..., force_proceed = getOption(\"healthdb.force_proceed\"))"},{"path":"https://kevinhzq.github.io/healthdb/reference/bind_source.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Row-bind a list of data.frames or remote tables — bind_source","text":"data list data.frame remote tables, e.g., output execute_def(). ... Named arguments variable included output. argument name new name output, right hand side argument character vector original names. name vector list elements data matched position. output variable came sources, fill name vector length equal number sources NA, e.g., var come second three sources, var = c(NA, 'nm_in_src2', NA). force_proceed logical whether ask user input order proceed remote tables needed collected binding. default TRUE let user aware downloading process may slow. Use options(healthdb.force_proceed = FALSE) suppress prompt .","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/bind_source.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Row-bind a list of data.frames or remote tables — bind_source","text":"data.frame remote table containing combined rows input list variables specified ...","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/bind_source.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Row-bind a list of data.frames or remote tables — bind_source","text":"","code":"df1 <- subset(iris, Species == \"setosa\") df2 <- subset(iris, Species == \"versicolor\") df3 <- subset(iris, Species == \"virginica\")  bind_source(list(df1, df2, df3),   s_l = \"Sepal.Length\",   s_w = \"Sepal.Width\",   p_l_setosa = c(\"Petal.Length\", NA, NA),   p_l_virginica = c(NA, NA, \"Petal.Length\") ) #>     src_No s_l s_w p_l_setosa p_l_virginica #> 1        1 5.1 3.5        1.4            NA #> 2        1 4.9 3.0        1.4            NA #> 3        1 4.7 3.2        1.3            NA #> 4        1 4.6 3.1        1.5            NA #> 5        1 5.0 3.6        1.4            NA #> 6        1 5.4 3.9        1.7            NA #> 7        1 4.6 3.4        1.4            NA #> 8        1 5.0 3.4        1.5            NA #> 9        1 4.4 2.9        1.4            NA #> 10       1 4.9 3.1        1.5            NA #> 11       1 5.4 3.7        1.5            NA #> 12       1 4.8 3.4        1.6            NA #> 13       1 4.8 3.0        1.4            NA #> 14       1 4.3 3.0        1.1            NA #> 15       1 5.8 4.0        1.2            NA #> 16       1 5.7 4.4        1.5            NA #> 17       1 5.4 3.9        1.3            NA #> 18       1 5.7 3.8        1.7            NA #> 19       1 5.1 3.8        1.5            NA #> 20       1 5.4 3.4        1.7            NA #> 21       1 5.1 3.7        1.5            NA #> 22       1 4.6 3.6        1.0            NA #> 23       1 5.1 3.3        1.7            NA #> 24       1 4.8 3.4        1.9            NA #> 25       1 5.0 3.0        1.6            NA #> 26       1 5.0 3.4        1.6            NA #> 27       1 5.2 3.5        1.5            NA #> 28       1 5.2 3.4        1.4            NA #> 29       1 4.7 3.2        1.6            NA #> 30       1 4.8 3.1        1.6            NA #> 31       1 5.4 3.4        1.5            NA #> 32       1 5.2 4.1        1.5            NA #> 33       1 5.5 4.2        1.4            NA #> 34       1 5.0 3.2        1.2            NA #> 35       1 5.5 3.5        1.3            NA #> 36       1 4.9 3.6        1.4            NA #> 37       1 4.4 3.0        1.3            NA #> 38       1 5.1 3.4        1.5            NA #> 39       1 5.0 3.5        1.3            NA #> 40       1 4.5 2.3        1.3            NA #> 41       1 4.4 3.2        1.3            NA #> 42       1 5.0 3.5        1.6            NA #> 43       1 5.1 3.8        1.9            NA #> 44       1 5.1 3.8        1.6            NA #> 45       1 4.6 3.2        1.4            NA #> 46       1 5.3 3.7        1.5            NA #> 47       1 5.0 3.3        1.4            NA #> 48       2 7.0 3.2         NA            NA #> 49       2 6.4 3.2         NA            NA #> 50       2 6.9 3.1         NA            NA #> 51       2 5.5 2.3         NA            NA #> 52       2 6.5 2.8         NA            NA #> 53       2 5.7 2.8         NA            NA #> 54       2 6.3 3.3         NA            NA #> 55       2 4.9 2.4         NA            NA #> 56       2 6.6 2.9         NA            NA #> 57       2 5.2 2.7         NA            NA #> 58       2 5.0 2.0         NA            NA #> 59       2 5.9 3.0         NA            NA #> 60       2 6.0 2.2         NA            NA #> 61       2 6.1 2.9         NA            NA #> 62       2 5.6 2.9         NA            NA #> 63       2 6.7 3.1         NA            NA #> 64       2 5.6 3.0         NA            NA #> 65       2 5.8 2.7         NA            NA #> 66       2 6.2 2.2         NA            NA #> 67       2 5.6 2.5         NA            NA #> 68       2 5.9 3.2         NA            NA #> 69       2 6.1 2.8         NA            NA #> 70       2 6.3 2.5         NA            NA #> 71       2 6.4 2.9         NA            NA #> 72       2 6.6 3.0         NA            NA #> 73       2 6.8 2.8         NA            NA #> 74       2 6.7 3.0         NA            NA #> 75       2 6.0 2.9         NA            NA #> 76       2 5.7 2.6         NA            NA #> 77       2 5.5 2.4         NA            NA #> 78       2 6.0 2.7         NA            NA #> 79       2 5.4 3.0         NA            NA #> 80       2 6.0 3.4         NA            NA #> 81       2 6.3 2.3         NA            NA #> 82       2 5.5 2.5         NA            NA #> 83       2 5.5 2.6         NA            NA #> 84       2 6.1 3.0         NA            NA #> 85       2 5.8 2.6         NA            NA #> 86       2 5.0 2.3         NA            NA #> 87       2 5.6 2.7         NA            NA #> 88       2 5.7 3.0         NA            NA #> 89       2 5.7 2.9         NA            NA #> 90       2 6.2 2.9         NA            NA #> 91       2 5.1 2.5         NA            NA #> 92       3 6.3 3.3         NA           6.0 #> 93       3 5.8 2.7         NA           5.1 #> 94       3 7.1 3.0         NA           5.9 #> 95       3 6.3 2.9         NA           5.6 #> 96       3 6.5 3.0         NA           5.8 #> 97       3 7.6 3.0         NA           6.6 #> 98       3 4.9 2.5         NA           4.5 #> 99       3 7.3 2.9         NA           6.3 #> 100      3 6.7 2.5         NA           5.8 #> 101      3 7.2 3.6         NA           6.1 #> 102      3 6.5 3.2         NA           5.1 #> 103      3 6.4 2.7         NA           5.3 #> 104      3 6.8 3.0         NA           5.5 #> 105      3 5.7 2.5         NA           5.0 #> 106      3 5.8 2.8         NA           5.1 #> 107      3 6.4 3.2         NA           5.3 #> 108      3 6.5 3.0         NA           5.5 #> 109      3 7.7 3.8         NA           6.7 #> 110      3 7.7 2.6         NA           6.9 #> 111      3 6.0 2.2         NA           5.0 #> 112      3 6.9 3.2         NA           5.7 #> 113      3 5.6 2.8         NA           4.9 #> 114      3 7.7 2.8         NA           6.7 #> 115      3 6.3 2.7         NA           4.9 #> 116      3 6.7 3.3         NA           5.7 #> 117      3 7.2 3.2         NA           6.0 #> 118      3 6.2 2.8         NA           4.8 #> 119      3 6.1 3.0         NA           4.9 #> 120      3 6.4 2.8         NA           5.6 #> 121      3 7.2 3.0         NA           5.8 #> 122      3 7.4 2.8         NA           6.1 #> 123      3 7.9 3.8         NA           6.4 #> 124      3 6.3 2.8         NA           5.1 #> 125      3 6.1 2.6         NA           5.6 #> 126      3 7.7 3.0         NA           6.1 #> 127      3 6.3 3.4         NA           5.6 #> 128      3 6.4 3.1         NA           5.5 #> 129      3 6.0 3.0         NA           4.8 #> 130      3 6.9 3.1         NA           5.4 #> 131      3 6.7 3.1         NA           5.6 #> 132      3 6.9 3.1         NA           5.1 #> 133      3 6.8 3.2         NA           5.9 #> 134      3 6.7 3.0         NA           5.2 #> 135      3 6.3 2.5         NA           5.0 #> 136      3 6.5 3.0         NA           5.2 #> 137      3 6.2 3.4         NA           5.4 #> 138      3 5.9 3.0         NA           5.1"},{"path":"https://kevinhzq.github.io/healthdb/reference/build_def.html","id":null,"dir":"Reference","previous_headings":"","what":"Build case definition function calls — build_def","title":"Build case definition function calls — build_def","text":"function assembles function calls supplied functions required arguments, leaving data argument empty easy re-use definition calls different data batch execution (see execute_def() detail). useful defining multiple diseases/events across multiple sources.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/build_def.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build case definition function calls — build_def","text":"","code":"build_def(def_lab, src_labs, def_fn = define_case, fn_args)"},{"path":"https://kevinhzq.github.io/healthdb/reference/build_def.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build case definition function calls — build_def","text":"def_lab single character label definition, e.g., disease. src_labs character vector place-holder names data sources used execute definition. def_fn list functions (default: define_case()) filter source data sets keep clients met case definition. length list either 1 equal length src_labs. length = 1, function applied sources; otherwise, def_fn match src_lab position. User can supply custom functions must put input data first argument name data. fn_args named list arguments passing def_fn. element list name argument source-specific def_fn, element length also either 1 equal number sources. def_fn functions taking different sets arguments, include union one list.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/build_def.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build case definition function calls — build_def","text":"tibble number rows equal length src_labs, containing input arguments synthetic function call fn_call column.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/build_def.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build case definition function calls — build_def","text":"","code":"build_def(\"SUD\", # usually a disease name   src_lab = c(\"src1\", \"src2\"), # identify from multiple sources, e.g., hospitalization, ED visits.   # functions that filter the data with some criteria,   # including mean here for src2 as a trivial example   # to show only valid arguments will be in the call   def_fn = list(define_case, mean),   fn_args = list(     vars = list(starts_with(\"diagx\"), \"diagx_2\"),     match = \"start\", # \"start\" will be applied to all sources as length = 1     vals = list(c(\"304\"), c(\"305\")),     clnt_id = \"clnt_id\",     # c() can be used in place of list     # if this argument only takes one value for each source     n_per_clnt = c(2, 3),     x = list(1:10) # src2 with mean as def_fn will only accept this argument   ) ) #> # A tibble: 2 × 5 #>   def_lab src_labs def_fn      fn_args          fn_call      #>   <chr>   <chr>    <chr>       <named list>     <named list> #> 1 SUD     src1     define_case <named list [6]> <language>   #> 2 SUD     src2     mean        <named list [6]> <language>"},{"path":"https://kevinhzq.github.io/healthdb/reference/collapse_episode.html","id":null,"dir":"Reference","previous_headings":"","what":"Grouping records into episodes by date range — collapse_episode","title":"Grouping records into episodes by date range — collapse_episode","text":"function useful collapsing, e.g., medication dispensation hospitalization, records episodes records' dates n days gap apart. length gap can relaxed another grouping variable.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/collapse_episode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Grouping records into episodes by date range — collapse_episode","text":"","code":"collapse_episode(   data,   clnt_id,   start_dt,   end_dt = NULL,   gap,   overwrite = NULL,   gap_overwrite = Inf,   .dt_trans = data.table::as.IDate,   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/collapse_episode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Grouping records into episodes by date range — collapse_episode","text":"data data.frame contains id date variables. clnt_id Column name subject/person ID. start_dt Column name starting date records. end_dt Column name end date records. default NULL assuming record last one day start date used calculate gaps records. gap number days used separate episodes. inclusive upper bound + 1. example, gap = 8 means collapsing records 7 days apart. overwrite Column name grouping variable determining whether consecutive records related different gap value. example, dispensing records may original prescription number, different gap value can assigned situation, e.g., days two records > gap, records still belong prescription. gap_overwrite different gap value used related records. default Inf, means records overwrite variable collapsed. .dt_trans Function transform start_dt/end_dt. Default [data.table::.IDate()]. ... Additional arguments passing .dt_trans function.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/collapse_episode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Grouping records into episodes by date range — collapse_episode","text":"original data.frame new columns indicating episode grouping","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/collapse_episode.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Grouping records into episodes by date range — collapse_episode","text":"","code":"# make toy data df <- make_test_dat()  head(df) #>   uid clnt_id      dates diagx diagx_1 diagx_2 #> 1  20       1 2018-09-14  3042    3057     999 #> 2   6       3 2016-05-13  3056    3043     999 #> 3  95       3 2016-08-29   999     999     999 #> 4  33       4 2018-01-21  3049    3056    <NA> #> 5  60       4 2018-11-17   999    <NA>    <NA> #> 6  51       4 2019-04-28   999    <NA>    <NA>  # collapse records no more than 90 days apart collapse_episode(df, clnt_id, dates, gap = 91) #>     uid clnt_id      dates diagx diagx_1 diagx_2 epi_id epi_no epi_seq #> 1    20       1 2018-09-14  3042    3057     999      1      1       1 #> 2     6       3 2016-05-13  3056    3043     999      2      1       1 #> 3    95       3 2016-08-29   999     999     999      3      2       1 #> 4    33       4 2018-01-21  3049    3056    <NA>      4      1       1 #> 5    60       4 2018-11-17   999    <NA>    <NA>      5      2       1 #> 6    51       4 2019-04-28   999    <NA>    <NA>      6      3       1 #> 7    30       5 2016-10-23  3044    3056     999      7      1       1 #> 8    87       5 2017-08-04   999     999     999      8      2       1 #> 9    99       5 2017-09-03   999    <NA>    <NA>      8      2       2 #> 10   61       5 2018-08-06   999    <NA>    <NA>      9      3       1 #> 11   92       5 2019-09-10   999     999    <NA>     10      4       1 #> 12    7       5 2020-01-01  3049    3050     999     11      5       1 #> 13   15       6 2019-01-06   305    3041    <NA>     12      1       1 #> 14   46       7 2015-05-07  3046    3049    3044     13      1       1 #> 15   16       7 2015-12-19  3040    3046    <NA>     14      2       1 #> 16    4       7 2016-11-02  3046    3056    <NA>     15      3       1 #> 17   65       9 2020-08-11   999    <NA>     999     16      1       1 #> 18   98      10 2015-08-30   999    <NA>    <NA>     17      1       1 #> 19   10      10 2016-05-13   304    3050    <NA>     18      2       1 #> 20   13      10 2016-05-27  3042    3040    <NA>     18      2       2 #> 21   72      10 2016-12-25   999     999    <NA>     19      3       1 #> 22   62      12 2019-10-31   999     999    <NA>     20      1       1 #> 23   83      13 2019-10-30   999     999     999     21      1       1 #> 24   97      13 2020-07-12   999     999    <NA>     22      2       1 #> 25   93      14 2016-02-02   999    <NA>     999     23      1       1 #> 26   29      15 2016-01-18  3044    3046    <NA>     24      1       1 #> 27   48      16 2017-03-16  3047    3053    3042     25      1       1 #> 28   37      16 2018-01-18  3041    3054     999     26      2       1 #> 29   64      17 2018-05-03   999    <NA>    <NA>     27      1       1 #> 30   12      17 2020-04-09  3054    3048     999     28      2       1 #> 31  100      19 2016-11-28   999    <NA>     999     29      1       1 #> 32   53      19 2016-12-06   999     999    <NA>     29      1       2 #> 33   39      20 2019-12-23  3043    3057    <NA>     30      1       1 #> 34   71      22 2015-10-29   999     999    <NA>     31      1       1 #> 35   77      22 2017-08-27   999     999    <NA>     32      2       1 #> 36   57      22 2019-05-01   999     999    <NA>     33      3       1 #> 37   59      23 2015-02-02   999     999    <NA>     34      1       1 #> 38   96      23 2016-12-14   999     999    <NA>     35      2       1 #> 39   14      23 2019-12-18  3045    3053     999     36      3       1 #> 40   21      23 2020-04-11  3046    3054    <NA>     37      4       1 #> 41   25      24 2016-11-16  3043    3045    <NA>     38      1       1 #> 42   68      24 2018-05-17   999    <NA>     999     39      2       1 #> 43   27      25 2015-08-13  3046    3058     999     40      1       1 #> 44   94      26 2016-07-01   999    <NA>    <NA>     41      1       1 #> 45   90      26 2018-07-20   999    <NA>     999     42      2       1 #> 46   50      27 2016-03-25  3041    3047    3040     43      1       1 #> 47   43      27 2019-09-24  3054    3044     305     44      2       1 #> 48    5      28 2015-07-16  3045     999    <NA>     45      1       1 #> 49    8      29 2015-02-11   305    <NA>     999     46      1       1 #> 50   22      30 2017-04-17  3051    3048     999     47      1       1 #> 51    1      31 2017-01-23  3058     304    <NA>     48      1       1 #> 52   91      31 2019-06-24   999    <NA>     999     49      2       1 #> 53   45      32 2015-02-28  3052    3042    3042     50      1       1 #> 54   31      33 2016-03-16  3054     305     999     51      1       1 #> 55   70      33 2016-06-05   999    <NA>     999     51      1       2 #> 56   54      34 2015-11-02   999     999    <NA>     52      1       1 #> 57   47      34 2017-02-07  3055    3041    3043     53      2       1 #> 58   69      34 2019-01-08   999     999    <NA>     54      3       1 #> 59   28      35 2019-05-07  3055    3052     999     55      1       1 #> 60   55      36 2015-09-04   999     999    <NA>     56      1       1 #> 61   82      36 2016-03-03   999     999    <NA>     57      2       1 #> 62   26      36 2018-11-02  3058    3047    <NA>     58      3       1 #> 63   18      36 2019-08-24  3050    3053     999     59      4       1 #> 64   42      37 2016-01-21  3049    3041    3050     60      1       1 #> 65   56      38 2016-01-24   999     999    <NA>     61      1       1 #> 66    9      38 2016-07-12  3054    3049     999     62      2       1 #> 67   88      39 2015-10-16   999    <NA>     999     63      1       1 #> 68   23      39 2016-10-22   305    3048     999     64      2       1 #> 69   76      39 2016-11-04   999     999    <NA>     64      2       2 #> 70   24      39 2017-08-07  3053    3047    <NA>     65      3       1 #> 71   52      39 2019-09-24   999     999     999     66      4       1 #> 72   89      39 2020-09-16   999    <NA>     999     67      5       1 #> 73   86      39 2020-12-09   999    <NA>    <NA>     67      5       2 #> 74   79      40 2016-08-27   999     999     999     68      1       1 #> 75   67      41 2015-10-04   999    <NA>    <NA>     69      1       1 #> 76   38      41 2019-04-12  3043    3046    <NA>     70      2       1 #> 77   17      42 2016-06-02  3052    3055     999     71      1       1 #> 78   81      42 2016-11-17   999     999    <NA>     72      2       1 #> 79    3      42 2017-04-18  3052    3044    <NA>     73      3       1 #> 80   74      42 2018-10-01   999    <NA>     999     74      4       1 #> 81   19      43 2017-02-18  3041    3051    <NA>     75      1       1 #> 82    2      43 2017-10-03  3053     305    <NA>     76      2       1 #> 83   41      43 2017-12-13  3058    3045    3043     76      2       2 #> 84   85      43 2020-07-03   999    <NA>     999     77      3       1 #> 85   58      44 2015-11-21   999     999     999     78      1       1 #> 86   73      44 2017-06-21   999    <NA>     999     79      2       1 #> 87   35      44 2017-11-08   304    3053     999     80      3       1 #> 88   40      45 2016-12-29  3055     999    <NA>     81      1       1 #> 89   63      46 2015-04-28   999     999    <NA>     82      1       1 #> 90   11      46 2016-01-10  3054    3046     999     83      2       1 #> 91   75      46 2017-10-26   999     999    <NA>     84      3       1 #> 92   49      46 2017-11-08  3055    3059    3051     84      3       2 #> 93   80      47 2016-08-08   999    <NA>    <NA>     85      1       1 #> 94   36      47 2016-08-21  3043    3058    <NA>     85      1       2 #> 95   78      47 2016-10-24   999     999     999     85      1       3 #> 96   66      47 2020-07-14   999     999    <NA>     86      2       1 #> 97   44      47 2020-10-23  3043    3054    3040     87      3       1 #> 98   34      48 2016-08-06  3053    3056    <NA>     88      1       1 #> 99   32      49 2019-08-23  3058    3049    <NA>     89      1       1 #> 100  84      50 2015-07-12   999     999     999     90      1       1 #>     epi_start_dt epi_stop_dt #> 1     2018-09-14  2018-09-14 #> 2     2016-05-13  2016-05-13 #> 3     2016-08-29  2016-08-29 #> 4     2018-01-21  2018-01-21 #> 5     2018-11-17  2018-11-17 #> 6     2019-04-28  2019-04-28 #> 7     2016-10-23  2016-10-23 #> 8     2017-08-04  2017-09-03 #> 9     2017-08-04  2017-09-03 #> 10    2018-08-06  2018-08-06 #> 11    2019-09-10  2019-09-10 #> 12    2020-01-01  2020-01-01 #> 13    2019-01-06  2019-01-06 #> 14    2015-05-07  2015-05-07 #> 15    2015-12-19  2015-12-19 #> 16    2016-11-02  2016-11-02 #> 17    2020-08-11  2020-08-11 #> 18    2015-08-30  2015-08-30 #> 19    2016-05-13  2016-05-27 #> 20    2016-05-13  2016-05-27 #> 21    2016-12-25  2016-12-25 #> 22    2019-10-31  2019-10-31 #> 23    2019-10-30  2019-10-30 #> 24    2020-07-12  2020-07-12 #> 25    2016-02-02  2016-02-02 #> 26    2016-01-18  2016-01-18 #> 27    2017-03-16  2017-03-16 #> 28    2018-01-18  2018-01-18 #> 29    2018-05-03  2018-05-03 #> 30    2020-04-09  2020-04-09 #> 31    2016-11-28  2016-12-06 #> 32    2016-11-28  2016-12-06 #> 33    2019-12-23  2019-12-23 #> 34    2015-10-29  2015-10-29 #> 35    2017-08-27  2017-08-27 #> 36    2019-05-01  2019-05-01 #> 37    2015-02-02  2015-02-02 #> 38    2016-12-14  2016-12-14 #> 39    2019-12-18  2019-12-18 #> 40    2020-04-11  2020-04-11 #> 41    2016-11-16  2016-11-16 #> 42    2018-05-17  2018-05-17 #> 43    2015-08-13  2015-08-13 #> 44    2016-07-01  2016-07-01 #> 45    2018-07-20  2018-07-20 #> 46    2016-03-25  2016-03-25 #> 47    2019-09-24  2019-09-24 #> 48    2015-07-16  2015-07-16 #> 49    2015-02-11  2015-02-11 #> 50    2017-04-17  2017-04-17 #> 51    2017-01-23  2017-01-23 #> 52    2019-06-24  2019-06-24 #> 53    2015-02-28  2015-02-28 #> 54    2016-03-16  2016-06-05 #> 55    2016-03-16  2016-06-05 #> 56    2015-11-02  2015-11-02 #> 57    2017-02-07  2017-02-07 #> 58    2019-01-08  2019-01-08 #> 59    2019-05-07  2019-05-07 #> 60    2015-09-04  2015-09-04 #> 61    2016-03-03  2016-03-03 #> 62    2018-11-02  2018-11-02 #> 63    2019-08-24  2019-08-24 #> 64    2016-01-21  2016-01-21 #> 65    2016-01-24  2016-01-24 #> 66    2016-07-12  2016-07-12 #> 67    2015-10-16  2015-10-16 #> 68    2016-10-22  2016-11-04 #> 69    2016-10-22  2016-11-04 #> 70    2017-08-07  2017-08-07 #> 71    2019-09-24  2019-09-24 #> 72    2020-09-16  2020-12-09 #> 73    2020-09-16  2020-12-09 #> 74    2016-08-27  2016-08-27 #> 75    2015-10-04  2015-10-04 #> 76    2019-04-12  2019-04-12 #> 77    2016-06-02  2016-06-02 #> 78    2016-11-17  2016-11-17 #> 79    2017-04-18  2017-04-18 #> 80    2018-10-01  2018-10-01 #> 81    2017-02-18  2017-02-18 #> 82    2017-10-03  2017-12-13 #> 83    2017-10-03  2017-12-13 #> 84    2020-07-03  2020-07-03 #> 85    2015-11-21  2015-11-21 #> 86    2017-06-21  2017-06-21 #> 87    2017-11-08  2017-11-08 #> 88    2016-12-29  2016-12-29 #> 89    2015-04-28  2015-04-28 #> 90    2016-01-10  2016-01-10 #> 91    2017-10-26  2017-11-08 #> 92    2017-10-26  2017-11-08 #> 93    2016-08-08  2016-10-24 #> 94    2016-08-08  2016-10-24 #> 95    2016-08-08  2016-10-24 #> 96    2020-07-14  2020-07-14 #> 97    2020-10-23  2020-10-23 #> 98    2016-08-06  2016-08-06 #> 99    2019-08-23  2019-08-23 #> 100   2015-07-12  2015-07-12"},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Elixhauser Comorbidity Index — compute_comorbidity","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"function computes unweighted Elixhauser Comorbidity Index data.frame remote table input. ICD codes used identify 31 disease categories Quan et al. (2005).","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"","code":"compute_comorbidity(   data,   vars,   icd_ver = c(\"ICD-10\", \"ICD-9-CM-3digits\", \"ICD-9-CM-5digits\"),   clnt_id,   uid = NULL,   sum_by = c(\"row\", \"clnt\"),   excl = NULL )"},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"data Data.frames remote tables (e.g., dbplyr::tbl_sql()) vars expression passing dplyr::select(). can quoted/unquoted column names, helper functions, dplyr::starts_with(). icd_ver One c(\"ICD-10\", \"ICD-9-CM-3digits\", \"ICD-9-CM-5digits\"). Specify ICD code version used data. ICD-10 ICD-9-CM 5 digits version Quan et al. (2005). ICD-9-CM 3 digits version adopted Manitoba Centre Health Policy. uses 3-digit 5-digit codes search. See web page cautions limitations 3 digit version data 3-digit data (http://mchp-appserv.cpe.umanitoba.ca/viewConcept.php?printer=Y&conceptID=1436#CAUTIONS). clnt_id Grouping variable (quoted/unquoted). uid Variable name unique row identifier. necessary SQL produce consistent result based sorting. sum_by One \"row\" \"clnt\". \"row\" option computes total score row (default), \"clnt\" option summarizes total score clnt_id. disease categories counted calculation regardless multiple records category. excl character vector disease categories labels excluded total score calculation. useful categories exposure/outcome interest, goal measure comorbidity excluding disease. See detail list categories labels.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"data.frame remote table binary indicators categories columns.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"List disease categories - labels (quote): Congestive Heart Failure - \"chf\" Cardiac Arrhythmia - \"arrhy\" Valvular Disease - \"vd\" Pulmonary Circulation Disorders - \"pcd\" Peripheral Vascular Disorders - \"pvd\" Hypertension Uncomplicated - \"hptn_nc\" Hypertension complicated - \"hptn_C\" Paralysis - \"para\" Neurological Disorders - \"Othnd\" Chronic Pulmonary Disease - \"copd\" Diabetes Uncomplicated - \"diab_nc\" Diabetes Complicated - \"diab_c\" Hypothyroidism - \"hptothy\" Renal Failure - \"rf\" Liver Disease - \"ld\" Peptic Ulcer Disease excluding bleeding - \"pud_nb\" AIDS/HIV - \"hiv\" Lymphoma - \"lymp\" Metastatic Cancer - \"mets\" Solid Tumor without Metastasis - \"tumor\" Rheumatoid Arthritis/collagen - \"rheum_a\" Coagulopathy - \"coag\" Obesity - \"obesity\" Weight Loss - \"wl\" Fluid Electrolyte Disorders - \"fluid\" Blood Loss Anemia - \"bla\" Deficiency Anemia - \"da\" Alcohol Abuse - \"alcohol\" Drug Abuse - \"drug\" Psychoses - \"psycho\" Depression - \"dep\"","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"Quan H, Sundararajan V, Halfon P, Fong , Burnand B, Luthi JC, Saunders LD, Beck CA, Feasby TE, Ghali WA. Coding algorithms defining comorbidities ICD-9-CM ICD-10 administrative data. Med Care 2005;43(11):1130-1139.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_comorbidity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Elixhauser Comorbidity Index — compute_comorbidity","text":"","code":"# make ICD-9 toy data df <- data.frame(   uid = 1:10, clnt_id = sample(1:3, 10, replace = TRUE),   diagx_1 = c(\"193\", \"2780\", \"396\", \"4254\", \"4150\", \"401\", \"401\", \"0932\", \"5329\", \"2536\"),   diagx_2 = c(NA, NA, \"72930\", \"V6542\", \"493\", \"405\", \"5880\", \"2409\", \"714\", NA) )  # compute Elixhauser Comorbidity Index by row # uid is needed for by row calculation # 3 categories were excluded in total_eci compute_comorbidity(df,   vars = starts_with(\"diagx\"),   icd_ver = \"ICD-9-CM-5digits\",   clnt_id = clnt_id, uid = uid,   excl = c(\"drug\", \"psycho\", \"dep\") ) #> # A tibble: 10 × 34 #>    clnt_id   uid   chf arrhy    vd   pcd   pvd hptn_nc hptn_c  para othnd  copd #>      <int> <int> <dbl> <dbl> <dbl> <dbl> <dbl>   <dbl>  <dbl> <dbl> <dbl> <dbl> #>  1       1     3     0     0     1     0     0       0      0     0     0     0 #>  2       1     4     1     0     0     0     0       0      0     0     0     0 #>  3       1     5     0     0     0     1     0       0      0     0     0     1 #>  4       1     8     0     0     1     0     0       0      0     0     0     0 #>  5       1    10     0     0     0     0     0       0      0     0     0     0 #>  6       2     1     0     0     0     0     0       0      0     0     0     0 #>  7       2     2     0     0     0     0     0       0      0     0     0     0 #>  8       2     7     0     0     0     0     0       1      0     0     0     0 #>  9       3     6     0     0     0     0     0       1      1     0     0     0 #> 10       3     9     0     0     0     0     0       0      0     0     0     0 #> # ℹ 22 more variables: diab_nc <dbl>, diab_c <dbl>, hptothy <dbl>, rf <dbl>, #> #   ld <dbl>, pud_nb <dbl>, hiv <dbl>, lymp <dbl>, mets <dbl>, tumor <dbl>, #> #   rheum_a <dbl>, coag <dbl>, obesity <dbl>, wl <dbl>, fluid <dbl>, bla <dbl>, #> #   da <dbl>, alcohol <dbl>, drug <dbl>, psycho <dbl>, dep <dbl>, #> #   total_eci <dbl>  # compute ECI by person compute_comorbidity(df,   vars = starts_with(\"diagx\"),   icd_ver = \"ICD-9-CM-5digits\",   clnt_id = clnt_id,   sum_by = \"clnt\" ) #> # A tibble: 3 × 33 #>   clnt_id   chf arrhy    vd   pcd   pvd hptn_nc hptn_c  para othnd  copd diab_nc #>     <int> <dbl> <dbl> <dbl> <dbl> <dbl>   <dbl>  <dbl> <dbl> <dbl> <dbl>   <dbl> #> 1       1     1     0     1     1     0       0      0     0     0     1       0 #> 2       2     0     0     0     0     0       1      0     0     0     0       0 #> 3       3     0     0     0     0     0       1      1     0     0     0       0 #> # ℹ 21 more variables: diab_c <dbl>, hptothy <dbl>, rf <dbl>, ld <dbl>, #> #   pud_nb <dbl>, hiv <dbl>, lymp <dbl>, mets <dbl>, tumor <dbl>, #> #   rheum_a <dbl>, coag <dbl>, obesity <dbl>, wl <dbl>, fluid <dbl>, bla <dbl>, #> #   da <dbl>, alcohol <dbl>, drug <dbl>, psycho <dbl>, dep <dbl>, #> #   total_eci <dbl>"},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_duration.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute duration between two dates — compute_duration","title":"Compute duration between two dates — compute_duration","text":"function meant data frame input used dplyr::mutate() compute age duration two character Date columns. vector breaks given, output converted factor labels generated automatically.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_duration.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute duration between two dates — compute_duration","text":"","code":"compute_duration(   from,   to,   lower_brks = NULL,   unit = c(\"year\", \"day\", \"week\", \"month\"),   trans = FALSE,   .transfn = lubridate::ymd,   verbose = getOption(\"healthdb.verbose\"),   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_duration.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute duration between two dates — compute_duration","text":"character Date vector start dates. character Date vector end dates. lower_brks numeric vector lower breaks passing base base::cut() function convert numeric result factor. level labels auto generated. example, level labels c(\"<19\", \"19-24\", \"25-34\", \"35-44\", \"45-54\", \"55+\") lower_brks = c(0, 19, 25, 35, 45, 55). Default NULL (conversion). unit character string specifying unit output. One \"year\" (default), \"day\", \"week\", \"month\". trans logical whether transform .transfn function .transfn function transforming inputs. Default lubridate::ymd(). verbose logical whether print summary warning missing values. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . ... Additional arguments passing base::cut().","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_duration.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute duration between two dates — compute_duration","text":"numeric factor vector duration.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/compute_duration.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute duration between two dates — compute_duration","text":"","code":"# toy data n <- 5 df <- data.frame(id = 1:n, start_dt = sample(seq(as.Date(\"1970-01-01\"), as.Date(\"2000-12-31\"), by = 1), size = n), end_dt = sample(seq(as.Date(\"2001-01-01\"), as.Date(\"2023-12-31\"), by = 1), size = n))  # get age group at a cut-off df %>% dplyr::mutate(  age_grp = compute_duration(start_dt, \"2023-01-01\", lower_brks = c(0, 19, 25, 35, 45, 55)) ) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   23.55   26.92   32.80   36.64   49.18   50.74  #>   <19 19-24 25-34 35-44 45-54   55+  #>     0     1     2     0     2     0  #>   id   start_dt     end_dt age_grp #> 1  1 1990-03-16 2012-09-28   25-34 #> 2  2 1999-06-13 2011-01-18   19-24 #> 3  3 1996-02-01 2017-10-03   25-34 #> 4  4 1972-04-05 2012-06-05   45-54 #> 5  5 1973-10-27 2004-05-09   45-54  # compute gaps between two dates in weeks df %>% dplyr::mutate(  gap_wks = compute_duration(start_dt, end_dt, unit = \"week\") ) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   605.3  1130.7  1176.0  1320.2  1593.1  2095.9  #>   id   start_dt     end_dt   gap_wks #> 1  1 1990-03-16 2012-09-28 1176.0000 #> 2  2 1999-06-13 2011-01-18  605.2857 #> 3  3 1996-02-01 2017-10-03 1130.7143 #> 4  4 1972-04-05 2012-06-05 2095.8571 #> 5  5 1973-10-27 2004-05-09 1593.1429"},{"path":"https://kevinhzq.github.io/healthdb/reference/cut_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut the time period in one row into multiple rows by interval — cut_period","title":"Cut the time period in one row into multiple rows by interval — cut_period","text":"function cutting time periods segments, useful subsequent overlap joins. original period (per row) expanded multiple rows weeks, months, etc. data.frame input accepted output size greater input. Thus, remote tables collected running function optimal performance.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/cut_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut the time period in one row into multiple rows by interval — cut_period","text":"","code":"cut_period(   data,   start,   end,   len,   unit = c(\"day\", \"week\", \"month\", \"quarter\", \"year\"),   .dt_trans = NULL )"},{"path":"https://kevinhzq.github.io/healthdb/reference/cut_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut the time period in one row into multiple rows by interval — cut_period","text":"data Input data.frame row start end dates start Record start date column (unquoted) end Record end date column (unquoted) len integer, interval used divide record duration unit One \"day\" (default), \"week\", \"month\", \"quarter, \"year\" used combination len specify time length interval. .dt_trans Function transform start/end, lubridate::ymd(). Default NULL.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/cut_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut the time period in one row into multiple rows by interval — cut_period","text":"Data frame row now segment period defined c(start, end) original row. Original variables retained repeated segment plus new variables defining segment interval.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/cut_period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut the time period in one row into multiple rows by interval — cut_period","text":"","code":"# toy data df <- data.frame(sample_id = 1, period_id = 1, start_date = \"2015-01-01\", end_date = \"2019-12-31\")  # divide period into segments (multiple rows per period) df_seg <- cut_period(   data = df, start = start_date, end = end_date,   len = 30, .dt_trans = lubridate::ymd )  # categorize segment_id as factor df_seg$segment <- cut(df_seg$segment_id,   breaks = c(0, 1, 2, Inf),   labels = c(\"< 1 month\", \"1 - 2 months\", \"Remainder\") )"},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify diseases/events from administrative records — define_case","title":"Identify diseases/events from administrative records — define_case","text":"function composite identify_row(), exclude(), restrict_n(), restrict_date(). aimed implement common case definitions epidemiological studies using administrative database one-shot big query. intended use case definitions form , e.g., two physician visits diagnostic code least 30 days apart within two years. component functions mentioned chained following order arguments supplied: identify_row(vals) %>% exclude(identify_row(excl_vals), = clnt_id) %>% restrict_n() %>% restrict_date(). necessary steps chain ran arguments missing, see verbose output done. Note date_var supplied, n_per_clnt counted distinct dates instead number records.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify diseases/events from administrative records — define_case","text":"","code":"define_case(   data,   vars,   match = \"in\",   vals,   clnt_id,   n_per_clnt = 1,   date_var = NULL,   apart = NULL,   within = NULL,   uid = NULL,   excl_vals = NULL,   excl_args = NULL,   keep = c(\"all\", \"first\", \"last\"),   if_all = FALSE,   mode = c(\"flag\", \"filter\"),   force_collect = FALSE,   verbose = getOption(\"healthdb.verbose\"),   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify diseases/events from administrative records — define_case","text":"data Data.frames remote tables (e.g., dbplyr::tbl_sql()) vars expression passing dplyr::select(). can quoted/unquoted column names, helper functions, dplyr::starts_with(). match One \"\", \"start\", \"regex\", \"like\", \"\", \"glue_sql\". determines values matched. See identify_row() detail. vals Depending match, takes different input. See identify_row(). clnt_id Grouping variable (quoted/unquoted). n_per_clnt single number specifying minimum number group size. date_var Variable name (quoted/unquoted) dates interpreted. apart integer specifying minimum gap (days) adjacent dates draw. option implemented data.frame input. within integer specifying maximum time span (days) draw. uid Variable name unique row identifier. necessary SQL produce consistent result based sorting. excl_vals vals clients/groups values going removed result. intended exclusion criteria case definition. excl_args named list arguments passing second identify_row() call excl_vals. supplied, var, match if_all first call re-used. keep One : \"first\" (keeping client's earliest record), \"last\" (keeping latest), \"\" (keeping relevant records, default). Note \"first\"/\"last\" used \"flag\" mode. if_all logical whether combining predicates (multiple columns selected vars) instead . Default FALSE, e.g., var1 vals var2 vals. mode Either: \"flag\" - add new columns starting \"flag_\" indicating client met condition, \"filter\" - remove clients meet condition data. passed restrict_n() restrict_date(). Default \"flag\". force_collect logical whether force downloading result table local data.frame. Downloading data slow, user opt ; default FALSE. verbose logical whether printing explanation operation. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . ... Additional arguments, e.g., mode, passing restrict_date().","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify diseases/events from administrative records — define_case","text":"subset input data satisfied specified case definition.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/define_case.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify diseases/events from administrative records — define_case","text":"","code":"sample_size <- 30 df <- data.frame(   clnt_id = rep(1:3, each = 10),   service_dt = sample(seq(as.Date(\"2020-01-01\"), as.Date(\"2020-01-31\"), by = 1),     size = sample_size, replace = TRUE   ),   diagx = sample(letters, size = sample_size, replace = TRUE),   diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),   diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE) )  # define from one source define_case(df,   vars = starts_with(\"diagx\"), \"in\", vals = letters[1:4],   clnt_id = clnt_id, date_var = service_dt,   excl_args = list(if_all = TRUE),   # remove non-case   mode = \"filter\",   # keeping the first record   keep = \"first\" ) #>  #> --------------Inclusion step-------------- #>  #> Identify records with condition(s):  #>  - where at least one of the diagx, diagx_1, diagx_2 column(s) in each record  #>    - contains a value exactly matched values in set: letters[1:4]  #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other columns):  #>    a    b    c    d    f    g    i    k    m    n    p    q    r    s    v    w  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #>    x    z NA's  #>    1    1    1  #>  #> -------------- Output first records-------------- #> # A tibble: 3 × 5 #>   clnt_id service_dt diagx diagx_1 diagx_2 #>     <int> <date>     <chr> <chr>   <chr>   #> 1       1 2020-01-02 q     d       w       #> 2       2 2020-01-07 g     a       p       #> 3       3 2020-01-02 m     k       d        # multiple sources with purrr::pmap # arguments with length = 1 will be recycle to match the number of sources # wrap expressions/unquoted variables with bquote(), # or rlang:exprs() to prevent immediate evaluation, # or just use quoted variable names purrr::pmap(   list(     data = list(df, df),     vars = rlang::exprs(starts_with(\"diagx\")),     match = c(\"in\", \"start\"),     vals = list(letters[1:4], letters[5:10]),     clnt_id = list(bquote(clnt_id)), n_per_clnt = c(2, 3),     date_var = \"service_dt\",     excl_vals = list(letters[11:13], letters[14:16]),     excl_args = list(list(if_all = TRUE), list(if_all = FALSE))   ),   define_case ) #>  #> --------------Inclusion step-------------- #>  #> Identify records with condition(s):  #>  - where at least one of the diagx, diagx_1, diagx_2 column(s) in each record  #>    - contains a value exactly matched values in set: c(\"a\", \"b\", \"c\", \"d\")  #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other columns):  #>    a    b    c    d    f    g    i    k    m    n    p    q    r    s    v    w  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #>    x    z NA's  #>    1    1    1  #>  #> --------------Exclusion step-------------- #>  #> Identify records with condition(s):  #>  - where all of the diagx, diagx_1, diagx_2 column(s) in each record  #>    - contains a value exactly matched values in set: c(\"k\", \"l\", \"m\")  #>  #> All unique value(s) and frequency in the result :  #> integer(0) #>  #> Exclude records in `data` through anti_join with `excl` matching on (by argument): \"clnt_id\"  #>  #> Of the 3 \"clnt_id\" in data, 0 were excluded. #>  #> --------------No. rows restriction-------------- #>  #> Of the 3 clients in the input, 0 were flagged as 0 by restricting that each client must have at least 2 records with distinct service_dt  #>  #> -------------- Output all records-------------- #>  #> --------------Inclusion step-------------- #>  #> Identify records with condition(s):  #>  - where at least one of the diagx, diagx_1, diagx_2 column(s) in each record  #>    - contains a value satisfied regular expression: ^e|^f|^g|^h|^i|^j  #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other columns):  #>    a    b    d    e    f    g    h    i    j    k    l    m    o    p    r    s  #>    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1    1  #>    t    u    v    w    x    y    z NA's  #>    1    1    1    1    1    1    1    1  #>  #> --------------Exclusion step-------------- #>  #> Identify records with condition(s):  #>  - where at least one of the diagx, diagx_1, diagx_2 column(s) in each record  #>    - contains a value satisfied regular expression: ^n|^o|^p  #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other columns):  #> a b e g j l n o p r t u  #> 1 1 1 1 1 1 1 1 1 1 1 1  #>  #> Exclude records in `data` through anti_join with `excl` matching on (by argument): \"clnt_id\"  #>  #> Of the 3 \"clnt_id\" in data, 3 were excluded. #>  #> --------------No. rows restriction-------------- #>  #> Of the 0 clients in the input, 0 were flagged as 0 by restricting that each client must have at least 3 records with distinct service_dt  #>  #> -------------- Output all records-------------- #> [[1]] #>    clnt_id service_dt diagx diagx_1 diagx_2 flag_restrict_n #> 1        1 2020-01-04     d       f       s               1 #> 2        1 2020-01-19     n       b       n               1 #> 3        1 2020-01-11     z       g       a               1 #> 4        1 2020-01-18     q    <NA>       b               1 #> 5        1 2020-01-02     q       d       w               1 #> 6        2 2020-01-29     b       d       i               1 #> 7        2 2020-01-07     g       a       p               1 #> 8        3 2020-01-05     p       b       r               1 #> 9        3 2020-01-12     s       c       v               1 #> 10       3 2020-01-07     x       s       c               1 #> 11       3 2020-01-21     s       d       d               1 #> 12       3 2020-01-02     m       k       d               1 #>  #> [[2]] #> [1] clnt_id         service_dt      diagx           diagx_1         #> [5] diagx_2         flag_restrict_n #> <0 rows> (or 0-length row.names) #>"},{"path":"https://kevinhzq.github.io/healthdb/reference/exclude.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove rows based on conditions or another data set — exclude","title":"Remove rows based on conditions or another data set — exclude","text":"function combines dplyr::anti_join(), negation dplyr::filter(). second data set supplied excl argument, anti join performed; otherwise, data filtered expression given via condition argument, filter result turn removed using dplyr::setdiff().","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/exclude.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove rows based on conditions or another data set — exclude","text":"","code":"exclude(   data,   excl = NULL,   by = NULL,   condition = NULL,   verbose = getOption(\"healthdb.verbose\"),   report_on = NULL,   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/exclude.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove rows based on conditions or another data set — exclude","text":"data Data.frames remote tables (e.g., vignette(\"dbplyr\", package = \"dbplyr)). subset removed data. excl Data frames remote tables (e.g., 'dbplyr'). Rows/values present removed data match. passed dplyr::anti_join() second argument. Column names matched dplyr::anti_join(), expressions dplyr::join_by(). See dplyr::anti_join()'s argument detail. Default NULL setdiff(data, excl). condition expression passed dplyr::filter(). rows satisfy condition removed data. verbose logical whether printing explanation operation. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . report_on quoted/unquoted column name counting many distinct values removed data, e.g., counting many client IDs removed. Default NULL. ... Additional arguments passing dplyr::filter()/dplyr::anti_join() finer control matching, e.g., na action, -group filtering, etc.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/exclude.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove rows based on conditions or another data set — exclude","text":"data frame remote table subset data.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/exclude.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove rows based on conditions or another data set — exclude","text":"","code":"# exclude with condition cyl4 <- exclude(mtcars, condition = cyl == 4, report_on = cyl) #>  #> Exclude a subset of `data` that satisfies condition: cyl == 4  #> Consider being explicit about NA, e.g., condition = var == 'val' | is.na(var) #>  #> Of the 3 cyl in data, 1 were excluded.  # exclude with another data exclude(mtcars, cyl4, dplyr::join_by(cyl), report_on = cyl) #>  #> Exclude records in `data` through anti_join with `excl` matching on (by argument): dplyr::join_by(cyl)  #>  #> Of the 3 cyl in data, 2 were excluded. #>                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb #> Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1 #> Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2 #> Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2 #> Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1 #> Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2 #> Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1 #> Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1 #> Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1 #> Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2 #> Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2 #> Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2"},{"path":"https://kevinhzq.github.io/healthdb/reference/execute_def.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute parameterized case definitions — execute_def","title":"Execute parameterized case definitions — execute_def","text":"function executes function calls stored output tibble [build_def()] data objects supplied named list returns results list. intended facilitate re-use pre-defined calls different data.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/execute_def.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute parameterized case definitions — execute_def","text":"","code":"execute_def(   def,   with_data,   bind = FALSE,   force_proceed = getOption(\"healthdb.force_proceed\") )"},{"path":"https://kevinhzq.github.io/healthdb/reference/execute_def.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Execute parameterized case definitions — execute_def","text":"def tibble created [build_def()]. with_data named list elements form src_lab = data, 'src_lab' corresponds src_labs argument [build_def()] 'data' data object passed calls stored def. names (length) `with_data` must match unique values src_labs `def`. bind logical whether row-binding records multiple sources one table. Note binding may fail ways difficult anticipate advance, data type conflict (e.g., Date vs. character) variables name different sources. default FALSE. TRUE, behavior try return unbinded result failed. force_proceed logical whether ask user input order proceed remote tables needed collected binding. default TRUE let user aware downloading process may slow. Use options(healthdb.force_proceed = FALSE) suppress prompt .","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/execute_def.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Execute parameterized case definitions — execute_def","text":"single (bind = TRUE) list data.frames remote tables.","code":""},{"path":[]},{"path":"https://kevinhzq.github.io/healthdb/reference/execute_def.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Execute parameterized case definitions — execute_def","text":"","code":"# toy data sample_size <- 30 df <- data.frame(   clnt_id = rep(1:3, each = 10),   service_dt = sample(seq(as.Date(\"2020-01-01\"), as.Date(\"2020-01-31\"), by = 1),     size = sample_size, replace = TRUE   ),   diagx = sample(letters, size = sample_size, replace = TRUE),   diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),   diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE) )  # make df a database table db <- dbplyr::tbl_memdb(df)  # use build_def to make a toy definition sud_def <- build_def(\"SUD\", # usually a disease name   src_lab = c(\"src1\", \"src2\"), # identify from multiple sources, e.g., hospitalization, ED visits.   # functions that filter the data with some criteria   def_fn = define_case,   fn_args = list(     vars = starts_with(\"diagx\"),     match = \"start\", # \"start\" will be applied to all sources as length = 1     vals = list(c(\"304\"), c(\"305\")),     clnt_id = \"clnt_id\", # list()/c() could be omitted for single element     # c() can be used in place of list     # if this argument only takes one value for each source     n_per_clnt = c(2, 3)   ) )  # save the definition for re-use # saveRDS(sud_def, file = some_path)  sud_def %>% execute_def(with_data = list(src1 = df, src2 = db), force_proceed = TRUE) #>  #> Processing source: df #> --------------Inclusion step-------------- #>  #> Identify records with condition(s):  #>  - where at least one of the diagx, diagx_1, diagx_2 column(s) in each record  #>    - contains a value satisfied regular expression: ^304  #>  #> All unique value(s) and frequency in the result (as the conditions require just one of the columns containing target values; irrelevant values may come from other columns):  #> integer(0) #>  #> --------------No. rows restriction-------------- #>  #> Of the 0 clients in the input, 0 were flagged as 0 by restricting that each client must have at least 2 records   #>  #> -------------- Output all records-------------- #>  #> Processing source: db #> --------------Inclusion step-------------- #>  #> Identify records with condition(s):  #>  - where at least one of the diagx, diagx_1, diagx_2 column(s) in each record  #>    - contains a value satisfied SQL LIKE pattern: 305%  #>  #> To see the final query generated by 'dbplyr', use dplyr::show_query() on the output.  #> To extract the SQL string, use dbplyr::remote_query(). #>  #> --------------No. rows restriction-------------- #>  #> Apply restriction that each client must have at least 3 records. Clients/groups whichmetthe condition were flagged.  #>  #> -------------- Output all records-------------- #> [[1]] #> [1] def             src             clnt_id         service_dt      #> [5] diagx           diagx_1         diagx_2         flag_restrict_n #> <0 rows> (or 0-length row.names) #>  #> [[2]] #> # Source:   SQL [0 x 8] #> # Database: sqlite 3.45.2 [:memory:] #> # ℹ 8 variables: def <lgl>, src <lgl>, clnt_id <int>, service_dt <dbl>, #> #   diagx <chr>, diagx_1 <chr>, diagx_2 <chr>, flag_restrict_n <lgl> #>"},{"path":"https://kevinhzq.github.io/healthdb/reference/fetch_var.html","id":null,"dir":"Reference","previous_headings":"","what":"Get variables from multiple tables with common ID columns — fetch_var","title":"Get variables from multiple tables with common ID columns — fetch_var","text":"function fetches variables different tables linked common IDs. calls dplyr::left_join() multiple times different source tables (y argument join) gather variables. meant replace left_join() simplify syntax situation started table study sample wanted gather covariates different sources linked common client IDs, often case working healthcare databases. said, function replace repetitions simple joins allows one--one matching.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/fetch_var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get variables from multiple tables with common ID columns — fetch_var","text":"","code":"fetch_var(data, keys, linkage, verbose = getOption(\"healthdb.verbose\"), ...)"},{"path":"https://kevinhzq.github.io/healthdb/reference/fetch_var.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get variables from multiple tables with common ID columns — fetch_var","text":"data local data.frame, tibble. used x argument left_join(). keys vector quoted/unquoted variable names, 'tidyselect' expression (see dplyr::select()). variables must present data used argument left_join(). y tables must subset . linkage list formulas form \"from_tab ~ get_vars|by_keys\": source table left-hand-side variables right-hand-side source table variables keys, use \"|\" RHS specify subset keys used. example, given keys 3 variables, list( y1 ~ tidyselect_expr1, y2 ~ tidyselect_expr2|key1 + key2) meaning: table y1 get variables picked tidyselect expression matching 3 keys; table y2 get variables matching key1 key2. verbose logical whether report number rows joining source. Default getting options. Use options(healthdb.verbose = FALSE) suppress . ... Additional arguments passing left_join().","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/fetch_var.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get variables from multiple tables with common ID columns — fetch_var","text":"data.frame tibble containing original columns x new variables matched tables based specified linkage.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/fetch_var.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get variables from multiple tables with common ID columns — fetch_var","text":"","code":"# make toy data size <- 30 n <- 10 df1 <- data.frame(   id = sample(1:n, size = size, replace = TRUE),   service_dt = sample(seq(as.Date(\"2020-01-01\"), as.Date(\"2022-01-31\"), by = 1),     size = size   ) ) %>%   dplyr::mutate(year = lubridate::year(service_dt)) df2 <- data.frame(   id = rep(1:n, size / n), year = rep(2020:2022, each = n),   status_1 = sample(0:1, size = size, replace = TRUE),   status_2 = sample(0:1, size = size, replace = TRUE) ) df3 <- data.frame(id = 1:n, sex = sample(c(\"F\", \"M\"), size = n, replace = TRUE))  # simple joins # note that for left_join(df1, df2), boths keys have to be used, # otherwise, error as the relation would not be one-to-one fetch_var(df1,   keys = c(id, year),   linkage = list(     df2 ~ starts_with(\"s\"), # match both keys without '|'     df3 ~ sex | id   ) # match by id only; otherwise failed because df3 has no year ) #>  #> The data has 30 rows. After joining, variable(s) from df2 has 30 rows, and variable(s) from df3 has 30 rows  #>    id service_dt year status_1 status_2 sex #> 1   3 2020-04-24 2020        0        1   F #> 2   6 2021-12-12 2021        1        0   F #> 3   1 2021-03-02 2021        0        1   F #> 4  10 2020-06-12 2020        0        0   F #> 5  10 2020-02-29 2020        0        0   F #> 6   4 2020-07-21 2020        0        0   F #> 7   9 2020-06-09 2020        0        1   M #> 8   2 2021-07-29 2021        1        0   F #> 9   5 2020-05-19 2020        0        1   F #> 10  3 2021-08-01 2021        0        1   F #> 11  6 2020-01-25 2020        1        1   F #> 12  7 2021-03-23 2021        1        0   M #> 13  2 2021-04-16 2021        1        0   F #> 14  1 2021-04-21 2021        0        1   F #> 15  2 2020-03-13 2020        0        0   F #> 16 10 2020-04-06 2020        0        0   F #> 17  7 2020-12-29 2020        0        1   M #> 18  3 2022-01-24 2022        1        1   F #> 19  6 2021-01-13 2021        1        0   F #> 20  5 2021-04-23 2021        0        0   F #> 21  9 2021-03-16 2021        1        1   M #> 22  8 2020-05-09 2020        0        0   M #> 23  2 2021-11-03 2021        1        0   F #> 24  7 2021-04-27 2021        1        0   M #> 25  4 2020-01-18 2020        0        0   F #> 26  7 2021-12-21 2021        1        0   M #> 27  5 2020-12-31 2020        0        1   F #> 28  4 2020-03-24 2020        0        0   F #> 29 10 2021-02-13 2021        1        0   F #> 30  4 2021-02-16 2021        1        0   F  # example if some y is remote # make df2 as database table db2 <- dbplyr::tbl_memdb(df2)  fetch_var(df1,   keys = c(id, year),   linkage = list(     db2 ~ starts_with(\"s\"),     df3 ~ sex | id   ),   copy = TRUE # pass to left_join for forced collection of remote table ) #>  #> The data has 30 rows. After joining, variable(s) from db2 has 30 rows, and variable(s) from df3 has 30 rows  #>    id service_dt year status_1 status_2 sex #> 1   3 2020-04-24 2020        0        1   F #> 2   6 2021-12-12 2021        1        0   F #> 3   1 2021-03-02 2021        0        1   F #> 4  10 2020-06-12 2020        0        0   F #> 5  10 2020-02-29 2020        0        0   F #> 6   4 2020-07-21 2020        0        0   F #> 7   9 2020-06-09 2020        0        1   M #> 8   2 2021-07-29 2021        1        0   F #> 9   5 2020-05-19 2020        0        1   F #> 10  3 2021-08-01 2021        0        1   F #> 11  6 2020-01-25 2020        1        1   F #> 12  7 2021-03-23 2021        1        0   M #> 13  2 2021-04-16 2021        1        0   F #> 14  1 2021-04-21 2021        0        1   F #> 15  2 2020-03-13 2020        0        0   F #> 16 10 2020-04-06 2020        0        0   F #> 17  7 2020-12-29 2020        0        1   M #> 18  3 2022-01-24 2022        1        1   F #> 19  6 2021-01-13 2021        1        0   F #> 20  5 2021-04-23 2021        0        0   F #> 21  9 2021-03-16 2021        1        1   M #> 22  8 2020-05-09 2020        0        0   M #> 23  2 2021-11-03 2021        1        0   F #> 24  7 2021-04-27 2021        1        0   M #> 25  4 2020-01-18 2020        0        0   F #> 26  7 2021-12-21 2021        1        0   M #> 27  5 2020-12-31 2020        0        1   F #> 28  4 2020-03-24 2020        0        0   F #> 29 10 2021-02-13 2021        1        0   F #> 30  4 2021-02-16 2021        1        0   F"},{"path":"https://kevinhzq.github.io/healthdb/reference/healthdb-package.html","id":null,"dir":"Reference","previous_headings":"","what":"healthdb: Working with Healthcare Database — healthdb-package","title":"healthdb: Working with Healthcare Database — healthdb-package","text":"system identifying diseases events healthcare databases preparing data epidemiological studies. includes capabilities supported 'SQL', matching strings 'stringr' style regular expressions, can compute comorbidity scores (Quan et al. (2005) doi:10.1097/01.mlr.0000182534.19832.83 ) directly database server. implementation based 'dbplyr' full 'tidyverse' compatibility.","code":""},{"path":[]},{"path":"https://kevinhzq.github.io/healthdb/reference/healthdb-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"healthdb: Working with Healthcare Database — healthdb-package","text":"Maintainer: Kevin Hu kevin.hu@bccdc.ca (ORCID) [copyright holder]","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/identify_row.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify rows with a match — identify_row","title":"Identify rows with a match — identify_row","text":"Filter rows values satisfy specified conditions. functionality identical dplyr::filter() combined dplyr::if_any() dplyr::if_all(), used 'data.table' package vignette(\"datatable-intro\", package = \"data.table\") data.frame method, regular regular expression support remote database tables. motivation take away pain working databases often support regular expression 'LIKE' operator multiple string patterns.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/identify_row.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify rows with a match — identify_row","text":"","code":"identify_row(   data,   vars,   match = c(\"in\", \"start\", \"regex\", \"like\", \"between\", \"glue_sql\"),   vals,   if_all = FALSE,   verbose = getOption(\"healthdb.verbose\"),   query_only = TRUE,   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/identify_row.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify rows with a match — identify_row","text":"data Data.frames remote tables (e.g., dbplyr::tbl_sql()) vars expression passing dplyr::select(). can quoted/unquoted column names, helper functions, dplyr::starts_with(). match One \"\", \"start\", \"regex\", \"like\", \"\", \"glue_sql\". determines values matched. operations type: \"\": var %% vals (default) \"regex\": stringr::str_detect(var, vals). remote tables, unique values vars collected locally matching (may slow). \"like\": stringr::str_like(var, vals). remote tables, var LIKE val. \"start\": regex LIKE modified vals, e.g., \"^val1|^val2\" \"va1%|val2%\" \"\": dplyr::(var, val1, val2) \"glue_sql\": remote table , gives full control clause using dplyr::filter(dbplyr::sql(glue::glue_sql(...))) vals Depending match, takes different input: \"\": vector values (numeric/character/Date) \"start\": vector numeric/character modified regex LIKE pattern string adding \"^\" front \"%\" end \"regex\"/\"like\": string expression \"\": vector numeric date exactly two elements, e.g., c(lower, upper) \"glue_sql\": string SQL clause, passed glue::glue_sql(). See examples detail. if_all logical whether combining predicates (multiple columns selected vars) instead . Default FALSE, e.g., var1 vals var2 vals. verbose logical whether printing explanation result overview query. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . Result overview remote tables query executed immediately, thus result available summary without adding extra run (may slow) query. query_only logical whether keeping output remote table (Default TRUE) downloading query result tibble (FALSE). argument ignored input data data.frame/tibble. ... remote table method . Additional arguments passing glue::glue_sql() parameterized queries.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/identify_row.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify rows with a match — identify_row","text":"data.frame tbl_sql object depending input.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/identify_row.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify rows with a match — identify_row","text":"","code":"#applying to data.frame; both sepal length and width in range 3-5 identify_row(iris, starts_with(\"Sepal\"), \"between\", c(3, 5), if_all = TRUE) #>  #> Identify records with condition(s):  #>  - where all of the Sepal.Length, Sepal.Width column(s) in each record  #>    - contains a value between range (bounds included): c(3, 5)  #>  #> Summary of values in the result :  #> Range: [1] 3 5 #>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species #> 1           4.9         3.0          1.4         0.2  setosa #> 2           4.7         3.2          1.3         0.2  setosa #> 3           4.6         3.1          1.5         0.2  setosa #> 4           5.0         3.6          1.4         0.2  setosa #> 5           4.6         3.4          1.4         0.3  setosa #> 6           5.0         3.4          1.5         0.2  setosa #> 7           4.9         3.1          1.5         0.1  setosa #> 8           4.8         3.4          1.6         0.2  setosa #> 9           4.8         3.0          1.4         0.1  setosa #> 10          4.3         3.0          1.1         0.1  setosa #> 11          4.6         3.6          1.0         0.2  setosa #> 12          4.8         3.4          1.9         0.2  setosa #> 13          5.0         3.0          1.6         0.2  setosa #> 14          5.0         3.4          1.6         0.4  setosa #> 15          4.7         3.2          1.6         0.2  setosa #> 16          4.8         3.1          1.6         0.2  setosa #> 17          4.9         3.1          1.5         0.2  setosa #> 18          5.0         3.2          1.2         0.2  setosa #> 19          4.9         3.6          1.4         0.1  setosa #> 20          4.4         3.0          1.3         0.2  setosa #> 21          5.0         3.5          1.3         0.3  setosa #> 22          4.4         3.2          1.3         0.2  setosa #> 23          5.0         3.5          1.6         0.6  setosa #> 24          4.8         3.0          1.4         0.3  setosa #> 25          4.6         3.2          1.4         0.2  setosa #> 26          5.0         3.3          1.4         0.2  setosa  #applying to remote table; species starts with se or ends with ca iris_db <- dbplyr::memdb_frame(iris) identify_row(iris_db, Species, \"like\", c(\"se%\", \"%ca\")) #>  #> Identify records with condition(s):  #>  - where the Species column(s) in each record  #>    - contains a value satisfied SQL LIKE pattern: se% OR %ca  #>  #> To see the final query generated by 'dbplyr', use dplyr::show_query() on the output.  #> To extract the SQL string, use dbplyr::remote_query(). #> # Source:   SQL [?? x 5] #> # Database: sqlite 3.45.2 [:memory:] #>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species #>           <dbl>       <dbl>        <dbl>       <dbl> <chr>   #>  1          4.3         3            1.1         0.1 setosa  #>  2          4.4         2.9          1.4         0.2 setosa  #>  3          4.4         3            1.3         0.2 setosa  #>  4          4.4         3.2          1.3         0.2 setosa  #>  5          4.5         2.3          1.3         0.3 setosa  #>  6          4.6         3.1          1.5         0.2 setosa  #>  7          4.6         3.2          1.4         0.2 setosa  #>  8          4.6         3.4          1.4         0.3 setosa  #>  9          4.6         3.6          1           0.2 setosa  #> 10          4.7         3.2          1.3         0.2 setosa  #> # ℹ more rows  #using glue_sql to write the WHERE clause #use {`vars`} to refer to the variables selected by vars #supply additional values required in the query through '...' #note that if you use LIKE here, you cannot supply multiple patterns in what identify_row(iris_db, Species, \"glue_sql\",  \"{`vars`} LIKE {what}\",   what = \"se%\") #>  #> Identify records with condition(s):  #>  - where the Species column(s) in each record  #>    - contains a value satisfied SQL WHERE clause: `Species` LIKE 'se%'  #>  #> To see the final query generated by 'dbplyr', use dplyr::show_query() on the output.  #> To extract the SQL string, use dbplyr::remote_query(). #> # Source:   SQL [?? x 5] #> # Database: sqlite 3.45.2 [:memory:] #>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species #>           <dbl>       <dbl>        <dbl>       <dbl> <chr>   #>  1          5.1         3.5          1.4         0.2 setosa  #>  2          4.9         3            1.4         0.2 setosa  #>  3          4.7         3.2          1.3         0.2 setosa  #>  4          4.6         3.1          1.5         0.2 setosa  #>  5          5           3.6          1.4         0.2 setosa  #>  6          5.4         3.9          1.7         0.4 setosa  #>  7          4.6         3.4          1.4         0.3 setosa  #>  8          5           3.4          1.5         0.2 setosa  #>  9          4.4         2.9          1.4         0.2 setosa  #> 10          4.9         3.1          1.5         0.1 setosa  #> # ℹ more rows  #add * after a vector identify_row(iris_db, Species, \"glue_sql\",  \"{`vars`} IN ({what*})\",  what = c(\"setosa\", \"virginica\")) #>  #> Identify records with condition(s):  #>  - where the Species column(s) in each record  #>    - contains a value satisfied SQL WHERE clause: `Species` IN ('setosa', 'virginica')  #>  #> To see the final query generated by 'dbplyr', use dplyr::show_query() on the output.  #> To extract the SQL string, use dbplyr::remote_query(). #> # Source:   SQL [?? x 5] #> # Database: sqlite 3.45.2 [:memory:] #>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species #>           <dbl>       <dbl>        <dbl>       <dbl> <chr>   #>  1          5.1         3.5          1.4         0.2 setosa  #>  2          4.9         3            1.4         0.2 setosa  #>  3          4.7         3.2          1.3         0.2 setosa  #>  4          4.6         3.1          1.5         0.2 setosa  #>  5          5           3.6          1.4         0.2 setosa  #>  6          5.4         3.9          1.7         0.4 setosa  #>  7          4.6         3.4          1.4         0.3 setosa  #>  8          5           3.4          1.5         0.2 setosa  #>  9          4.4         2.9          1.4         0.2 setosa  #> 10          4.9         3.1          1.5         0.1 setosa  #> # ℹ more rows"},{"path":"https://kevinhzq.github.io/healthdb/reference/if_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Interpret if n dates drawn from a vector could be some days apart within some years — if_date","title":"Interpret if n dates drawn from a vector could be some days apart within some years — if_date","text":"Given vector dates x, interpret least one set n elements taken x satisfy adjacent elements set least certain days apart dates set within specified time span. identifying events/diseases administrative data, definitions often require, e.g., n diagnoses least days apart within years. function intended use optimized avoid looping n-size combinations x. function work remote table input.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/if_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interpret if n dates drawn from a vector could be some days apart within some years — if_date","text":"","code":"if_date(   x,   n,   apart = NULL,   within = NULL,   detail = FALSE,   align = c(\"left\", \"right\"),   dup.rm = TRUE,   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/if_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interpret if n dates drawn from a vector could be some days apart within some years — if_date","text":"x character Date vector n integer size draw apart integer specifying minimum gap (days) adjacent dates draw. within integer specifying maximum time span (days) draw. detail Logical whether return result per element x.default FALSE, returns one logical summarized (). align Character, define time span record start (\"left\") end (\"right\") current date. Defaults \"left\". See 'flag_at' argument restrict_date() detail. dup.rm Logical whether duplicated dates x removed calculation. Default TRUE. ... Additional argument passing data.table::.IDate() date conversion.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/if_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interpret if n dates drawn from a vector could be some days apart within some years — if_date","text":"Single vector logical whether draw x satisfied conditions","code":""},{"path":[]},{"path":"https://kevinhzq.github.io/healthdb/reference/if_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interpret if n dates drawn from a vector could be some days apart within some years — if_date","text":"","code":"dates_of_records <- sample(seq(as.Date(\"2015-01-01\"), as.Date(\"2021-12-31\"), 7), 10)  # whether there is any 3 records at least 30 days apart within 2 years if_date(dates_of_records, n = 3, apart = 30, within = 365 * 2) #> [1] TRUE  # specified either apart or within or both if_date(dates_of_records, n = 2, within = 365) #> [1] TRUE"},{"path":"https://kevinhzq.github.io/healthdb/reference/lookup.html","id":null,"dir":"Reference","previous_headings":"","what":"Find value corresponding to input vector using a look-up table — lookup","title":"Find value corresponding to input vector using a look-up table — lookup","text":"Find value corresponding input vector using look-table","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/lookup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find value corresponding to input vector using a look-up table — lookup","text":"","code":"lookup(x, link, lu, verbose = getOption(\"healthdb.verbose\"))"},{"path":"https://kevinhzq.github.io/healthdb/reference/lookup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find value corresponding to input vector using a look-up table — lookup","text":"x variable name data.frame; function called inside dplyr::mutate(). link formula form: name_of_x_in_lu ~ name_of_target_value. left-hand-side can omitted x's name also x look-. lu Look-table data.frame class. verbose logical whether warn missing values output.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/lookup.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find value corresponding to input vector using a look-up table — lookup","text":"vector matched values.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/lookup.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find value corresponding to input vector using a look-up table — lookup","text":"","code":"df <- data.frame(drug_code = 1:10) lu <- data.frame(drug_id = 1:20, drug_code = as.character(1:10), drug_name = sample(letters, 20))  df %>% dplyr::mutate(   drug_nm = lookup(drug_code, drug_id ~ drug_name, lu),   # this will work as lu also has drug_code column   drug_nm = lookup(drug_code, ~ drug_name, lu) ) #>    drug_code drug_nm #> 1          1       n #> 2          2       s #> 3          3       r #> 4          4       m #> 5          5       i #> 6          6       y #> 7          7       b #> 8          8       g #> 9          9       u #> 10        10       o"},{"path":"https://kevinhzq.github.io/healthdb/reference/make_test_dat.html","id":null,"dir":"Reference","previous_headings":"","what":"Make test data — make_test_dat","title":"Make test data — make_test_dat","text":"Make toy data set testing demo. internal use purpose intended called users.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/make_test_dat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make test data — make_test_dat","text":"","code":"make_test_dat(   vals_kept = c(\"304\", \"305\", 3040:3049, 3050:3059),   noise_val = \"999\",   IDs = 1:50,   date_range = seq(as.Date(\"2015-01-01\"), as.Date(\"2020-12-31\"), by = 1),   nrows = 100,   n_any = 50,   n_all = 10,   seed = 2023,   answer_id = NULL,   type = c(\"data.frame\", \"database\") )"},{"path":"https://kevinhzq.github.io/healthdb/reference/make_test_dat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make test data — make_test_dat","text":"vals_kept vector values suppose identified. noise_val vector values meant identified. IDs vector client IDs. date_range vector possible dates data. nrows Number rows output. n_any Number rows identified criteria target column contains certain values. n_all Number rows identified criteria target columns contain certain values. seed Seed random number generation. answer_id Column name indicator row identified: , , noise. type Output type, \"data.frame\" \"database\".","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/make_test_dat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make test data — make_test_dat","text":"data.frame remote table 'dbplyr'.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/make_test_dat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make test data — make_test_dat","text":"","code":"make_test_dat() #>     uid clnt_id      dates diagx diagx_1 diagx_2 #> 1    20       1 2018-09-14  3042    3057     999 #> 2     6       3 2016-05-13  3056    3043     999 #> 3    95       3 2016-08-29   999     999     999 #> 4    33       4 2018-01-21  3049    3056    <NA> #> 5    60       4 2018-11-17   999    <NA>    <NA> #> 6    51       4 2019-04-28   999    <NA>    <NA> #> 7    30       5 2016-10-23  3044    3056     999 #> 8    87       5 2017-08-04   999     999     999 #> 9    99       5 2017-09-03   999    <NA>    <NA> #> 10   61       5 2018-08-06   999    <NA>    <NA> #> 11   92       5 2019-09-10   999     999    <NA> #> 12    7       5 2020-01-01  3049    3050     999 #> 13   15       6 2019-01-06   305    3041    <NA> #> 14   46       7 2015-05-07  3046    3049    3044 #> 15   16       7 2015-12-19  3040    3046    <NA> #> 16    4       7 2016-11-02  3046    3056    <NA> #> 17   65       9 2020-08-11   999    <NA>     999 #> 18   98      10 2015-08-30   999    <NA>    <NA> #> 19   10      10 2016-05-13   304    3050    <NA> #> 20   13      10 2016-05-27  3042    3040    <NA> #> 21   72      10 2016-12-25   999     999    <NA> #> 22   62      12 2019-10-31   999     999    <NA> #> 23   83      13 2019-10-30   999     999     999 #> 24   97      13 2020-07-12   999     999    <NA> #> 25   93      14 2016-02-02   999    <NA>     999 #> 26   29      15 2016-01-18  3044    3046    <NA> #> 27   48      16 2017-03-16  3047    3053    3042 #> 28   37      16 2018-01-18  3041    3054     999 #> 29   64      17 2018-05-03   999    <NA>    <NA> #> 30   12      17 2020-04-09  3054    3048     999 #> 31  100      19 2016-11-28   999    <NA>     999 #> 32   53      19 2016-12-06   999     999    <NA> #> 33   39      20 2019-12-23  3043    3057    <NA> #> 34   71      22 2015-10-29   999     999    <NA> #> 35   77      22 2017-08-27   999     999    <NA> #> 36   57      22 2019-05-01   999     999    <NA> #> 37   59      23 2015-02-02   999     999    <NA> #> 38   96      23 2016-12-14   999     999    <NA> #> 39   14      23 2019-12-18  3045    3053     999 #> 40   21      23 2020-04-11  3046    3054    <NA> #> 41   25      24 2016-11-16  3043    3045    <NA> #> 42   68      24 2018-05-17   999    <NA>     999 #> 43   27      25 2015-08-13  3046    3058     999 #> 44   94      26 2016-07-01   999    <NA>    <NA> #> 45   90      26 2018-07-20   999    <NA>     999 #> 46   50      27 2016-03-25  3041    3047    3040 #> 47   43      27 2019-09-24  3054    3044     305 #> 48    5      28 2015-07-16  3045     999    <NA> #> 49    8      29 2015-02-11   305    <NA>     999 #> 50   22      30 2017-04-17  3051    3048     999 #> 51    1      31 2017-01-23  3058     304    <NA> #> 52   91      31 2019-06-24   999    <NA>     999 #> 53   45      32 2015-02-28  3052    3042    3042 #> 54   31      33 2016-03-16  3054     305     999 #> 55   70      33 2016-06-05   999    <NA>     999 #> 56   54      34 2015-11-02   999     999    <NA> #> 57   47      34 2017-02-07  3055    3041    3043 #> 58   69      34 2019-01-08   999     999    <NA> #> 59   28      35 2019-05-07  3055    3052     999 #> 60   55      36 2015-09-04   999     999    <NA> #> 61   82      36 2016-03-03   999     999    <NA> #> 62   26      36 2018-11-02  3058    3047    <NA> #> 63   18      36 2019-08-24  3050    3053     999 #> 64   42      37 2016-01-21  3049    3041    3050 #> 65   56      38 2016-01-24   999     999    <NA> #> 66    9      38 2016-07-12  3054    3049     999 #> 67   88      39 2015-10-16   999    <NA>     999 #> 68   23      39 2016-10-22   305    3048     999 #> 69   76      39 2016-11-04   999     999    <NA> #> 70   24      39 2017-08-07  3053    3047    <NA> #> 71   52      39 2019-09-24   999     999     999 #> 72   89      39 2020-09-16   999    <NA>     999 #> 73   86      39 2020-12-09   999    <NA>    <NA> #> 74   79      40 2016-08-27   999     999     999 #> 75   67      41 2015-10-04   999    <NA>    <NA> #> 76   38      41 2019-04-12  3043    3046    <NA> #> 77   17      42 2016-06-02  3052    3055     999 #> 78   81      42 2016-11-17   999     999    <NA> #> 79    3      42 2017-04-18  3052    3044    <NA> #> 80   74      42 2018-10-01   999    <NA>     999 #> 81   19      43 2017-02-18  3041    3051    <NA> #> 82    2      43 2017-10-03  3053     305    <NA> #> 83   41      43 2017-12-13  3058    3045    3043 #> 84   85      43 2020-07-03   999    <NA>     999 #> 85   58      44 2015-11-21   999     999     999 #> 86   73      44 2017-06-21   999    <NA>     999 #> 87   35      44 2017-11-08   304    3053     999 #> 88   40      45 2016-12-29  3055     999    <NA> #> 89   63      46 2015-04-28   999     999    <NA> #> 90   11      46 2016-01-10  3054    3046     999 #> 91   75      46 2017-10-26   999     999    <NA> #> 92   49      46 2017-11-08  3055    3059    3051 #> 93   80      47 2016-08-08   999    <NA>    <NA> #> 94   36      47 2016-08-21  3043    3058    <NA> #> 95   78      47 2016-10-24   999     999     999 #> 96   66      47 2020-07-14   999     999    <NA> #> 97   44      47 2020-10-23  3043    3054    3040 #> 98   34      48 2016-08-06  3053    3056    <NA> #> 99   32      49 2019-08-23  3058    3049    <NA> #> 100  84      50 2015-07-12   999     999     999"},{"path":"https://kevinhzq.github.io/healthdb/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://kevinhzq.github.io/healthdb/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling `rhs(lhs)`.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/pool_case.html","id":null,"dir":"Reference","previous_headings":"","what":"Pooling qualified clients from multiple sources — pool_case","title":"Pooling qualified clients from multiple sources — pool_case","text":"function filters pools, .e., row bind, qualified clients/groups different source option summarize client. Unlike bind_source(), need supply variable names; function guess included names supplied definition build_def(). Whether client qualified relies flag variables set define_case(). Therefore, function intended use built-define_case() def_fn build_def().","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/pool_case.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pooling qualified clients from multiple sources — pool_case","text":"","code":"pool_case(   data,   def,   output_lvl = c(\"raw\", \"clnt\"),   include_src = c(\"all\", \"has_valid\", \"n_per_clnt\"),   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/pool_case.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pooling qualified clients from multiple sources — pool_case","text":"data list data.frame remote table output execute_def(). def tibble case definition generated build_def(). output_lvl Either: \"raw\" - output records (default), \"clnt\" - output one record per client summaries including date first valid record ('first_valid_date'), date latest record ('last_entry_date'), sources contain valid records. include_src Character. determines records sources included. matters clients identified , , sources. choice impact number client identified impact number records latest entry date. options one : \"\" - records sources included; \"has_valid\" - client, records sources contain least one valid record included; \"n_per_clnt\" - client, fewer n_per_clnt records source (see restrict_n()), records source removed. ... Additional arguments passing bind_source()","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/pool_case.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pooling qualified clients from multiple sources — pool_case","text":"data.frame remote table clients satisfied predefined case definition.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/pool_case.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pooling qualified clients from multiple sources — pool_case","text":"","code":"# toy data sample_size <- 30 df <- data.frame(   clnt_id = rep(1:3, each = 10),   service_dt = sample(seq(as.Date(\"2020-01-01\"), as.Date(\"2020-01-31\"), by = 1),     size = sample_size, replace = TRUE   ),   diagx = sample(letters, size = sample_size, replace = TRUE),   diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),   diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE) )  # make df a database table db <- dbplyr::tbl_memdb(df) #> Error in db_copy_to(dest$con, name, df, overwrite = overwrite, types = types,     temporary = temporary, unique_indexes = unique_indexes, indexes = indexes,     analyze = analyze, in_transaction = in_transaction, ...): Can't copy data to table `df`. #> Caused by error in `dplyr::db_write_table()`: #> ! Can't write table table `df`. #> Caused by error: #> ! Table `df` exists in database, and both overwrite and append are FALSE  # use build_def to make a toy definition sud_def <- build_def(\"SUD\", # usually a disease name   src_lab = c(\"src1\", \"src2\"), # identify from multiple sources, e.g., hospitalization, ED visits.   # functions that filter the data with some criteria   def_fn = define_case,   fn_args = list(     vars = starts_with(\"diagx\"),     match = \"start\", # \"start\" will be applied to all sources as length = 1     vals = list(c(\"304\"), c(\"305\")),     clnt_id = \"clnt_id\", # list()/c() could be omitted for single element     # c() can be used in place of list     # if this argument only takes one value for each source     n_per_clnt = c(2, 3)   ) )  # save the definition for re-use # saveRDS(sud_def, file = some_path)  # execute definition sud_by_src <- sud_def %>% execute_def(with_data = list(src1 = db, src2 = db)) #> Error: object 'db' not found  # pool results from src1 and src2 together at client level sud_pooled <- pool_case(sud_by_src, sud_def, output_lvl = \"clnt\") #> Error in eval(expr, envir, enclos): object 'sud_by_src' not found"},{"path":"https://kevinhzq.github.io/healthdb/reference/report_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Report number of distinct value in a column across data frames — report_n","title":"Report number of distinct value in a column across data frames — report_n","text":"function intended mimic dplyr::n_distinct() multiple inputs. useful report number clients series inclusion exclusion steps. use case getting Ns sample definition flowchart epidemiological study. also useful inline reporting Ns Rmarkdown document.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/report_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Report number of distinct value in a column across data frames — report_n","text":"","code":"report_n(..., on, force_proceed = getOption(\"healthdb.force_proceed\"))"},{"path":"https://kevinhzq.github.io/healthdb/reference/report_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Report number of distinct value in a column across data frames — report_n","text":"... Data frames remote tables (e.g., 'dbplyr') column report . must present data sources. force_proceed logical whether ask user input order proceed data local data.frames, query needs executed reporting. default fetching options. Use options(healthdb.force_proceed = FALSE) suppress prompt .","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/report_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Report number of distinct value in a column across data frames — report_n","text":"sequence number distinct data frames","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/report_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Report number of distinct value in a column across data frames — report_n","text":"","code":"# some exclusions iris_1 <- subset(iris, Petal.Length > 1) iris_2 <- subset(iris, Petal.Length > 2)  # get n at each operation n <- report_n(iris, iris_1, iris_2, on = Species) n #> [1] 3 3 2  # get the difference at each step diff(n) #> [1]  0 -1"},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_date.html","id":null,"dir":"Reference","previous_headings":"","what":"Removes or flags groups failed to meet conditions based on dates — restrict_date","title":"Removes or flags groups failed to meet conditions based on dates — restrict_date","text":"client group, interpret n records least certain days apart within specified time span. identifying events/diseases administrative data, definitions often require, e.g., n diagnoses least days apart within years. function intended use optimized avoid looping n-size combinations dates per client.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Removes or flags groups failed to meet conditions based on dates — restrict_date","text":"","code":"restrict_date(   data,   clnt_id,   date_var,   n,   apart = NULL,   within = NULL,   uid = NULL,   mode = c(\"flag\", \"filter\"),   flag_at = c(\"left\", \"right\"),   dup.rm = TRUE,   force_collect = FALSE,   verbose = getOption(\"healthdb.verbose\"),   ... )"},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Removes or flags groups failed to meet conditions based on dates — restrict_date","text":"data Data frames remote tables (e.g., vignette(\"dbplyr\", package = \"dbplyr)) clnt_id Grouping variable (quoted/unquoted). date_var Variable name (quoted/unquoted) dates interpreted. n integer size draw. apart integer specifying minimum gap (days) adjacent dates draw. option implemented data.frame input. within integer specifying maximum time span (days) draw. uid Variable name unique row identifier. necessary SQL produce consistent result based sorting. mode Either: \"flag\" - add new column 'flag_restrict_date' indicating condition met (flag = 1 time period starting ending current record satisfied apart-within condition), \"filter\" - remove clients without qualified record data. Default \"flag\". flag_at Character, define flag placed start (\"left\") end (\"right\") time period contains n qualified records. Defaults \"left\". Note impact first last qualified/diagnosed dates client, e.g., using \"right\" first flag earliest date client became qualified. example, condition 2 records within year, c(\"2023-01-01\", \"2023-04-01\", \"2024-05-01\"), flag c(0, 1, 0) \"right\" c(1,0,0) \"left\". dup.rm Logical whether duplicated dates removed calculation. Default TRUE. force_collect logical whether force downloading remote table apart NULL. remote table , apart implemented local data frame . Downloading data slow, user opt ; default FALSE stop error. verbose logical whether explain query report many groups removed. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . Reporting remote tables query executed immediately, thus result available summary without adding extra run (may slow) query. ... Additional argument passing data.table::.IDate() date conversion.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Removes or flags groups failed to meet conditions based on dates — restrict_date","text":"subset input data satisfied dates requirement, raw input data new flag column.","code":""},{"path":[]},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Removes or flags groups failed to meet conditions based on dates — restrict_date","text":"","code":"sample_size <- 30 df <- data.frame(clnt_id = sample(1:sample_size, sample_size, replace = TRUE),  service_dt = sample(seq(as.Date(\"2020-01-01\"), as.Date(\"2020-01-31\"), by = 1),                      size = sample_size, replace = TRUE),  diagx = sample(letters, size = sample_size, replace = TRUE),  diagx_1 = sample(c(NA, letters), size = sample_size, replace = TRUE),  diagx_2 = sample(c(NA, letters), size = sample_size, replace = TRUE))  #Keep clients with 2 records that were 1 week apart within 1 month restrict_date(df, clnt_id, service_dt, n = 2, apart = 7, within = 30) #>  #>  Of the 19 clients in the input, 13 were flagged as 0 by restricting that each client must have 2 records that were at least 7 days apart within 30 days.  #> # A tibble: 30 × 6 #>    clnt_id service_dt diagx diagx_1 diagx_2 flag_restrict_date #>      <int> <date>     <chr> <chr>   <chr>                <dbl> #>  1       1 2020-01-20 v     s       g                        0 #>  2       3 2020-01-26 c     v       b                        0 #>  3       4 2020-01-02 i     o       e                        0 #>  4       5 2020-01-10 l     x       o                        1 #>  5       5 2020-01-15 a     u       v                        1 #>  6       5 2020-01-24 p     x       r                        0 #>  7       5 2020-01-26 h     g       g                        0 #>  8       6 2020-01-16 v     x       i                        0 #>  9       7 2020-01-05 m     p       f                        1 #> 10       7 2020-01-28 h     e       d                        0 #> # ℹ 20 more rows"},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Removes or flags groups with n less than some number — restrict_n","title":"Removes or flags groups with n less than some number — restrict_n","text":"Remove flags groups clients less number rows number distinct values variable. example, can used remove clients less n visits service different dates administrative records. offers filtering dplyr::n_distinct() functionality database input.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Removes or flags groups with n less than some number — restrict_n","text":"","code":"restrict_n(   data,   clnt_id,   n_per_clnt,   count_by = NULL,   mode = c(\"flag\", \"filter\"),   verbose = getOption(\"healthdb.verbose\") )"},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Removes or flags groups with n less than some number — restrict_n","text":"data Data.frames remote tables (e.g., vignette(\"dbplyr\", package = \"dbplyr)) clnt_id Grouping variable (quoted/unquoted). n_per_clnt single number specifying minimum number group size. count_by Another variable dictating counting unit n_per_clnt. default NULL meaning inclusion criteria number row, .e., dplyr::n() >= n_per_clnt. NULL, criteria becomes equivalent dplyr::n_distinct(count_by) >= n_per_clnt. mode Either \"flag\" - add new column 'flag_restrict_n' indicating client met condition (rows qualified client flag = 1), \"filter\" - remove clients meet condition data. Default \"flag\". verbose logical whether explain query report many groups removed. Default fetching options. Use options(healthdb.verbose = FALSE) suppress . Reporting remote tables query executed immediately, thus result available summary without adding extra run (may slow) query.","code":""},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Removes or flags groups with n less than some number — restrict_n","text":"subset input data satisfied group size requirement, raw input data new flag column.","code":""},{"path":[]},{"path":"https://kevinhzq.github.io/healthdb/reference/restrict_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Removes or flags groups with n less than some number — restrict_n","text":"","code":"#remove cyl groups with less than 8 cars restrict_n(mtcars, clnt_id = cyl, n_per_clnt = 8) #>  #> Of the 3 clients in the input, 1 were flagged as 0 by restricting that each client must have at least 8 records   #>     mpg cyl  disp  hp drat    wt  qsec vs am gear carb flag_restrict_n #> 1  21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4               0 #> 2  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4               0 #> 3  22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1               1 #> 4  21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1               0 #> 5  18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2               1 #> 6  18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1               0 #> 7  14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4               1 #> 8  24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2               1 #> 9  22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2               1 #> 10 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4               0 #> 11 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4               0 #> 12 16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3               1 #> 13 17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3               1 #> 14 15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3               1 #> 15 10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4               1 #> 16 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4               1 #> 17 14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4               1 #> 18 32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1               1 #> 19 30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2               1 #> 20 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1               1 #> 21 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1               1 #> 22 15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2               1 #> 23 15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2               1 #> 24 13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4               1 #> 25 19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2               1 #> 26 27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1               1 #> 27 26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2               1 #> 28 30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2               1 #> 29 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4               1 #> 30 19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6               0 #> 31 15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8               1 #> 32 21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2               1  #remove cyl groups with less than 2 types of gear boxes restrict_n(mtcars, clnt_id = cyl, n_per_clnt = 3, count_by = gear) #>  #> Of the 3 clients in the input, 1 were flagged as 0 by restricting that each client must have at least 3 records with distinct gear  #>     mpg cyl  disp  hp drat    wt  qsec vs am gear carb flag_restrict_n #> 1  21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4               1 #> 2  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4               1 #> 3  22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1               1 #> 4  21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1               1 #> 5  18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2               0 #> 6  18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1               1 #> 7  14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4               0 #> 8  24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2               1 #> 9  22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2               1 #> 10 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4               1 #> 11 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4               1 #> 12 16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3               0 #> 13 17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3               0 #> 14 15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3               0 #> 15 10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4               0 #> 16 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4               0 #> 17 14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4               0 #> 18 32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1               1 #> 19 30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2               1 #> 20 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1               1 #> 21 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1               1 #> 22 15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2               0 #> 23 15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2               0 #> 24 13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4               0 #> 25 19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2               0 #> 26 27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1               1 #> 27 26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2               1 #> 28 30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2               1 #> 29 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4               0 #> 30 19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6               1 #> 31 15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8               0 #> 32 21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2               1"},{"path":"https://kevinhzq.github.io/healthdb/news/index.html","id":"healthdb-010","dir":"Changelog","previous_headings":"","what":"healthdb 0.1.0","title":"healthdb 0.1.0","text":"CRAN release: 2024-04-27 Initial CRAN submission.","code":""}]
